From 4ff6c956c0ff7d279cd76b0d4a1a8f2da90ab176 Mon Sep 17 00:00:00 2001
From: ranhui_xia <ranhui_xia@realsil.com.cn>
Date: Fri, 13 Dec 2013 09:51:13 +0800
Subject: [PATCH 13/13] Realtek BT: Add LE HID(HOGP) support for bluedroid

Fix some bugs on LE HID in native bluedroid stack

Signed-off-by: ranhui_xia <ranhui_xia@realsil.com.cn>
---
 bta/dm/bta_dm_act.c         |  12 ++++
 bta/gatt/bta_gattc_act.c    |   6 +-
 bta/gatt/bta_gattc_api.c    |  27 +++++++++
 bta/gatt/bta_gattc_cache.c  |  21 ++++++-
 bta/gatt/bta_gattc_utils.c  |   7 +++
 bta/hh/bta_hh_act.c         |   9 +++
 bta/hh/bta_hh_le.c          | 139 ++++++++++++++++++++++++++++++++++++++++----
 bta/hh/bta_hh_main.c        |   2 +-
 bta/include/bta_gatt_api.h  |   2 +-
 btif/co/bta_dm_co.c         |   6 +-
 btif/src/btif_dm.c          |  51 +++++++++++++++-
 stack/btm/btm_ble.c         |   5 ++
 stack/btm/btm_ble_bgconn.c  |  10 +++-
 stack/btm/btm_ble_gap.c     | 103 +++++++++++++++++++++++++++++++-
 stack/btm/btm_devctl.c      |   5 ++
 stack/gatt/gatt_cl.c        |   1 +
 stack/gatt/gatt_utils.c     |   2 +-
 stack/hcic/hciblecmds.c     |   5 ++
 stack/include/btm_ble_api.h |  27 ++++++++-
 stack/l2cap/l2c_api.c       |   9 +++
 stack/l2cap/l2c_ble.c       |   6 +-
 stack/srvc/srvc_dis.c       |   7 ++-
 stack/srvc/srvc_eng.c       |   8 ++-
 tools/gen-buildcfg.sh       |   0
 24 files changed, 442 insertions(+), 28 deletions(-)
 mode change 100644 => 100755 tools/gen-buildcfg.sh

diff --git a/bta/dm/bta_dm_act.c b/bta/dm/bta_dm_act.c
index 2f2e501..45a72de 100644
--- a/bta/dm/bta_dm_act.c
+++ b/bta/dm/bta_dm_act.c
@@ -1194,7 +1194,13 @@ void bta_dm_search_start (tBTA_DM_MSG *p_data)
         return;
     }
 
+    //REALTEK MODIFIED START
+    /*original code
     BTM_ClearInqDb(NULL);
+    */
+    //BTM_ClearInqDb(NULL);
+    //REALTEK MODIFIED END
+
     /* save search params */
     bta_dm_search_cb.p_search_cback = p_data->search.p_cback;
     bta_dm_search_cb.services = p_data->search.services;
@@ -5049,7 +5055,12 @@ void bta_dm_ble_set_adv_config (tBTA_DM_MSG *p_data)
 
 #if ((defined BTA_GATT_INCLUDED) &&  (BTA_GATT_INCLUDED == TRUE))
 #ifndef BTA_DM_GATT_CLOSE_DELAY_TOUT
+//REALTEK MODIFIED START
+/*original code
 #define BTA_DM_GATT_CLOSE_DELAY_TOUT    1000
+*/
+#define BTA_DM_GATT_CLOSE_DELAY_TOUT    0
+//REALTEK MODIFIED END
 #endif
 
 /*******************************************************************************
@@ -5261,6 +5272,7 @@ void btm_dm_start_gatt_discovery (BD_ADDR bd_addr)
     if (bdcmp(bta_dm_search_cb.pending_close_bda, bd_addr) == 0 &&
         bta_dm_search_cb.conn_id != BTA_GATT_INVALID_CONN_ID)
     {
+        APPL_TRACE_DEBUG0("Stop gatt_close_timer");
         memset(bta_dm_search_cb.pending_close_bda, 0, BD_ADDR_LEN);
         bta_sys_stop_timer(&bta_dm_search_cb.gatt_close_timer);
         btm_dm_start_disc_gatt_services(bta_dm_search_cb.conn_id);
diff --git a/bta/gatt/bta_gattc_act.c b/bta/gatt/bta_gattc_act.c
index 8ab7992..013869a 100644
--- a/bta/gatt/bta_gattc_act.c
+++ b/bta/gatt/bta_gattc_act.c
@@ -1380,9 +1380,10 @@ void bta_gattc_search(tBTA_GATTC_CLCB *p_clcb, tBTA_GATTC_DATA *p_data)
 {
     tBTA_GATT_STATUS    status = GATT_INTERNAL_ERROR;
     tBTA_GATTC cb_data;
-    APPL_TRACE_DEBUG1("bta_gattc_search conn_id=%d",p_clcb->bta_conn_id);
+    APPL_TRACE_DEBUG2("bta_gattc_search conn_id=%d, p_srcb(%p)",p_clcb->bta_conn_id, p_clcb->p_srcb);
     if (p_clcb->p_srcb && p_clcb->p_srcb->p_srvc_cache)
     {
+        APPL_TRACE_DEBUG1("bta_gattc_search p_srvc_cache(%p)",p_clcb->p_srcb->p_srvc_cache);
         status = BTA_GATT_OK;
         /* search the local cache of a server device */
         bta_gattc_search_service(p_clcb, p_data->api_search.p_srvc_uuid);
@@ -1788,7 +1789,8 @@ void bta_gattc_process_indicate(UINT16 conn_id, tGATTC_OPTYPE op, tGATT_CL_COMPL
     BD_ADDR             remote_bda;
     tBTA_GATTC_IF       gatt_if;
 
-    if (!GATT_GetConnectionInfor(conn_id, &gatt_if, remote_bda))
+    APPL_TRACE_ERROR1("indication/notif handle = 0x%04x", handle);
+	if (!GATT_GetConnectionInfor(conn_id, &gatt_if, remote_bda))
     {
         APPL_TRACE_ERROR0("indication/notif for unknown app");
         return;
diff --git a/bta/gatt/bta_gattc_api.c b/bta/gatt/bta_gattc_api.c
index fff1a55..f021df8 100644
--- a/bta/gatt/bta_gattc_api.c
+++ b/bta/gatt/bta_gattc_api.c
@@ -58,6 +58,8 @@ void BTA_GATTC_Disable(void)
 {
     BT_HDR  *p_buf;
 
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
+
     if (bta_sys_is_register(BTA_ID_GATTC) == FALSE)
     {
         APPL_TRACE_WARNING0("GATTC Module not enabled/already disabled");
@@ -89,6 +91,7 @@ void BTA_GATTC_AppRegister(tBT_UUID *p_app_uuid, tBTA_GATTC_CBACK *p_client_cb)
 {
     tBTA_GATTC_API_REG  *p_buf;
 
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
     if (bta_sys_is_register(BTA_ID_GATTC) == FALSE)
     {
         GKI_sched_lock();
@@ -124,6 +127,7 @@ void BTA_GATTC_AppDeregister(tBTA_GATTC_IF client_if)
 {
     tBTA_GATTC_API_DEREG  *p_buf;
 
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
     if ((p_buf = (tBTA_GATTC_API_DEREG *) GKI_getbuf(sizeof(tBTA_GATTC_API_DEREG))) != NULL)
     {
         p_buf->hdr.event = BTA_GATTC_API_DEREG_EVT;
@@ -151,6 +155,7 @@ void BTA_GATTC_Open(tBTA_GATTC_IF client_if, BD_ADDR remote_bda, BOOLEAN is_dire
 {
     tBTA_GATTC_API_OPEN  *p_buf;
 
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
     if ((p_buf = (tBTA_GATTC_API_OPEN *) GKI_getbuf(sizeof(tBTA_GATTC_API_OPEN))) != NULL)
     {
         p_buf->hdr.event = BTA_GATTC_API_OPEN_EVT;
@@ -182,6 +187,7 @@ void BTA_GATTC_Open(tBTA_GATTC_IF client_if, BD_ADDR remote_bda, BOOLEAN is_dire
 void BTA_GATTC_CancelOpen(tBTA_GATTC_IF client_if, BD_ADDR remote_bda, BOOLEAN is_direct)
 {
     tBTA_GATTC_API_CANCEL_OPEN  *p_buf;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if ((p_buf = (tBTA_GATTC_API_CANCEL_OPEN *) GKI_getbuf(sizeof(tBTA_GATTC_API_CANCEL_OPEN))) != NULL)
     {
@@ -210,6 +216,7 @@ void BTA_GATTC_CancelOpen(tBTA_GATTC_IF client_if, BD_ADDR remote_bda, BOOLEAN i
 void BTA_GATTC_Close(UINT16 conn_id)
 {
     BT_HDR  *p_buf;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if ((p_buf = (BT_HDR *) GKI_getbuf(sizeof(BT_HDR))) != NULL)
     {
@@ -242,6 +249,7 @@ void BTA_GATTC_ServiceSearchRequest (UINT16 conn_id, tBT_UUID *p_srvc_uuid)
 {
     tBTA_GATTC_API_SEARCH  *p_buf;
     UINT16  len = sizeof(tBTA_GATTC_API_SEARCH) + sizeof(tBT_UUID);
+    APPL_TRACE_DEBUG2("%s, %p", __FUNCTION__, p_srvc_uuid);
 
     if ((p_buf = (tBTA_GATTC_API_SEARCH *) GKI_getbuf(len)) != NULL)
     {
@@ -258,6 +266,7 @@ void BTA_GATTC_ServiceSearchRequest (UINT16 conn_id, tBT_UUID *p_srvc_uuid)
         else
             p_buf->p_srvc_uuid = NULL;
 
+        APPL_TRACE_DEBUG1("p_buf(%p)",p_buf);
         bta_sys_sendmsg(p_buf);
     }
     return;
@@ -288,6 +297,7 @@ tBTA_GATT_STATUS  BTA_GATTC_GetFirstChar (UINT16 conn_id, tBTA_GATT_SRVC_ID *p_s
                                           tBTA_GATT_CHAR_PROP *p_property)
 {
     tBTA_GATT_STATUS    status;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (!p_srvc_id || !p_char_result)
         return BTA_GATT_ILLEGAL_PARAMETER;
@@ -328,6 +338,7 @@ tBTA_GATT_STATUS  BTA_GATTC_GetNextChar (UINT16 conn_id,
                                          tBTA_GATT_CHAR_PROP    *p_property)
 {
     tBTA_GATT_STATUS    status;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (!p_start_char_id || !p_char_result)
         return BTA_GATT_ILLEGAL_PARAMETER;
@@ -368,6 +379,7 @@ tBTA_GATT_STATUS  BTA_GATTC_GetFirstCharDescr (UINT16 conn_id, tBTA_GATTC_CHAR_I
                                                 tBTA_GATTC_CHAR_DESCR_ID *p_descr_result)
 {
     tBTA_GATT_STATUS    status;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (!p_char_id || !p_descr_result)
         return BTA_GATT_ILLEGAL_PARAMETER;
@@ -414,6 +426,7 @@ tBTA_GATT_STATUS  BTA_GATTC_GetNextCharDescr (UINT16 conn_id,
                                              tBTA_GATTC_CHAR_DESCR_ID *p_descr_result)
 {
     tBTA_GATT_STATUS    status;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (!p_start_descr_id || !p_descr_result)
         return BTA_GATT_ILLEGAL_PARAMETER;
@@ -457,6 +470,7 @@ tBTA_GATT_STATUS  BTA_GATTC_GetFirstIncludedService(UINT16 conn_id, tBTA_GATT_SR
                                                     tBT_UUID *p_uuid_cond, tBTA_GATTC_INCL_SVC_ID *p_result)
 {
     tBTA_GATT_STATUS    status;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (!p_srvc_id || !p_result)
         return BTA_GATT_ILLEGAL_PARAMETER;
@@ -499,6 +513,7 @@ tBTA_GATT_STATUS  BTA_GATTC_GetNextIncludedService(UINT16 conn_id,
                                                    tBTA_GATTC_INCL_SVC_ID *p_result)
 {
     tBTA_GATT_STATUS    status;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (!p_start_id || !p_result)
         return BTA_GATT_ILLEGAL_PARAMETER;
@@ -535,6 +550,7 @@ void BTA_GATTC_ReadCharacteristic(UINT16 conn_id, tBTA_GATTC_CHAR_ID *p_char_id,
                                   tBTA_GATT_AUTH_REQ auth_req)
 {
     tBTA_GATTC_API_READ  *p_buf;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if ((p_buf = (tBTA_GATTC_API_READ *) GKI_getbuf(sizeof(tBTA_GATTC_API_READ))) != NULL)
     {
@@ -571,6 +587,7 @@ void BTA_GATTC_ReadCharDescr (UINT16 conn_id,
 {
     tBTA_GATTC_API_READ  *p_buf;
     UINT16  len = (UINT16)(sizeof(tBTA_GATT_ID) + sizeof(tBTA_GATTC_API_READ));
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if ((p_buf = (tBTA_GATTC_API_READ *) GKI_getbuf(len)) != NULL)
     {
@@ -612,6 +629,7 @@ void BTA_GATTC_ReadMultiple(UINT16 conn_id, tBTA_GATTC_MULTI *p_read_multi,
     UINT16      len = (UINT16)(sizeof(tBTA_GATTC_API_READ_MULTI) +
                                p_read_multi->num_attr * sizeof(tBTA_GATTC_ATTR_ID));
     UINT8       i;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if ((p_buf = (tBTA_GATTC_API_READ_MULTI *) GKI_getbuf(len)) != NULL)
     {
@@ -661,6 +679,7 @@ void BTA_GATTC_WriteCharValue ( UINT16 conn_id,
                                 tBTA_GATT_AUTH_REQ auth_req)
 {
     tBTA_GATTC_API_WRITE  *p_buf;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if ((p_buf = (tBTA_GATTC_API_WRITE *) GKI_getbuf((UINT16)(sizeof(tBTA_GATTC_API_WRITE) + len))) != NULL)
     {
@@ -708,6 +727,7 @@ void BTA_GATTC_WriteCharDescr (UINT16 conn_id,
 {
     tBTA_GATTC_API_WRITE  *p_buf;
     UINT16  len = sizeof(tBTA_GATTC_API_WRITE) + sizeof(tBTA_GATT_ID);
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (p_data != NULL)
         len += p_data->len;
@@ -759,6 +779,7 @@ void BTA_GATTC_PrepareWrite  (UINT16 conn_id, tBTA_GATTC_CHAR_ID *p_char_id,
                               tBTA_GATT_AUTH_REQ auth_req)
 {
     tBTA_GATTC_API_WRITE  *p_buf;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if ((p_buf = (tBTA_GATTC_API_WRITE *) GKI_getbuf((UINT16)(sizeof(tBTA_GATTC_API_WRITE) + len))) != NULL)
     {
@@ -801,6 +822,7 @@ void BTA_GATTC_PrepareWrite  (UINT16 conn_id, tBTA_GATTC_CHAR_ID *p_char_id,
 void BTA_GATTC_ExecuteWrite  (UINT16 conn_id, BOOLEAN is_execute)
 {
     tBTA_GATTC_API_EXEC  *p_buf;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if ((p_buf = (tBTA_GATTC_API_EXEC *) GKI_getbuf((UINT16)sizeof(tBTA_GATTC_API_EXEC))) != NULL)
     {
@@ -831,6 +853,7 @@ void BTA_GATTC_ExecuteWrite  (UINT16 conn_id, BOOLEAN is_execute)
 void BTA_GATTC_SendIndConfirm (UINT16 conn_id, tBTA_GATTC_CHAR_ID *p_char_id)
 {
     tBTA_GATTC_API_CONFIRM  *p_buf;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     APPL_TRACE_API3("BTA_GATTC_SendIndConfirm conn_id=%d service uuid1=0x%x char uuid=0x%x",
                     conn_id, p_char_id->srvc_id.id.uuid.uu.uuid16, p_char_id->char_id.uuid.uu.uuid16);
@@ -871,6 +894,7 @@ tBTA_GATT_STATUS BTA_GATTC_RegisterForNotifications (tBTA_GATTC_IF client_if,
     tBTA_GATTC_RCB      *p_clreg;
     tBTA_GATT_STATUS    status = BTA_GATT_ILLEGAL_PARAMETER;
     UINT8               i;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (!p_char_id)
     {
@@ -950,6 +974,7 @@ tBTA_GATT_STATUS BTA_GATTC_DeregisterForNotifications (tBTA_GATTC_IF client_if,
     tBTA_GATTC_RCB      *p_clreg;
     tBTA_GATT_STATUS    status = BTA_GATT_ILLEGAL_PARAMETER;
     UINT8               i;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (!p_char_id)
     {
@@ -1005,6 +1030,7 @@ tBTA_GATT_STATUS BTA_GATTC_DeregisterForNotifications (tBTA_GATTC_IF client_if,
 void BTA_GATTC_Refresh(BD_ADDR remote_bda)
 {
     tBTA_GATTC_API_OPEN  *p_buf;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if ((p_buf = (tBTA_GATTC_API_OPEN *) GKI_getbuf(sizeof(tBTA_GATTC_API_OPEN))) != NULL)
     {
@@ -1036,6 +1062,7 @@ void BTA_GATTC_Refresh(BD_ADDR remote_bda)
 void BTA_GATTC_Listen(tBTA_GATTC_IF client_if, BOOLEAN start, BD_ADDR_PTR target_bda)
 {
     tBTA_GATTC_API_LISTEN  *p_buf;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if ((p_buf = (tBTA_GATTC_API_LISTEN *) GKI_getbuf((UINT16)(sizeof(tBTA_GATTC_API_LISTEN) + BD_ADDR_LEN))) != NULL)
     {
diff --git a/bta/gatt/bta_gattc_cache.c b/bta/gatt/bta_gattc_cache.c
index bc784d7..f7fc5f6 100644
--- a/bta/gatt/bta_gattc_cache.c
+++ b/bta/gatt/bta_gattc_cache.c
@@ -1231,9 +1231,19 @@ void bta_gattc_search_service(tBTA_GATTC_CLCB *p_clcb, tBT_UUID *p_uuid)
     tBTA_GATTC_SERV     *p_srcb = p_clcb->p_srcb;
     tBTA_GATTC_CACHE    *p_cache = p_srcb->p_srvc_cache;
     tBTA_GATTC          cb_data;
-
+    if(p_uuid != NULL)
+    {
+        APPL_TRACE_DEBUG2("Searchng service [0x%04x], len(%d)......",p_uuid->uu.uuid16, p_uuid->len);
+    }
     while (p_cache)
     {
+#if (defined BTA_GATT_DEBUG && BTA_GATT_DEBUG == TRUE)
+            APPL_TRACE_DEBUG3("Cacheed service [0x%04x], inst[%d] handle [%d]",
+                              p_cache->service_uuid.id.uuid.uu.uuid16,
+                              p_cache->service_uuid.id.inst_id,
+                              p_cache->s_handle);
+            APPL_TRACE_DEBUG1("p_cback(%p)", p_clcb->p_rcb->p_cback);
+#endif
         if (bta_gattc_uuid_compare(p_uuid, &p_cache->service_uuid.id.uuid, FALSE))
         {
 #if (defined BTA_GATT_DEBUG && BTA_GATT_DEBUG == TRUE)
@@ -1241,6 +1251,7 @@ void bta_gattc_search_service(tBTA_GATTC_CLCB *p_clcb, tBT_UUID *p_uuid)
                               p_cache->service_uuid.id.uuid.uu.uuid16,
                               p_cache->service_uuid.id.inst_id,
                               p_cache->s_handle);
+            APPL_TRACE_DEBUG1("p_cback(%p)", p_clcb->p_rcb->p_cback);
 #endif
             if (p_clcb->p_rcb->p_cback)
             {
@@ -1442,8 +1453,14 @@ tBTA_GATT_STATUS bta_gattc_query_cache(UINT16 conn_id,
             }
             else
             {
+
                 status = BTA_GATT_ERROR;
-                APPL_TRACE_ERROR0("No server cache available");
+                APPL_TRACE_ERROR1("No server cache available, psrcb = %p", p_clcb->p_srcb);
+				if(p_clcb->p_srcb)
+                APPL_TRACE_ERROR2("No server cache available, psrcb_list = %p, p_srvc_cache = %p",
+						p_clcb->p_srcb->p_srvc_list, p_clcb->p_srcb->p_srvc_cache);
+
+
             }
         }
         else
diff --git a/bta/hh/bta_hh_act.c b/bta/hh/bta_hh_act.c
index 1c83d07..b15fc1f 100644
--- a/bta/hh/bta_hh_act.c
+++ b/bta/hh/bta_hh_act.c
@@ -518,7 +518,16 @@ void bta_hh_api_disc_act(tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_data)
 
 #if BTA_HH_LE_INCLUDED == TRUE
     if (p_cb->is_le_device)

         bta_hh_le_api_disc_act(p_cb);

     else
 #endif
     {
diff --git a/bta/hh/bta_hh_le.c b/bta/hh/bta_hh_le.c
index 41512d4..7b333a7 100644
--- a/bta/hh/bta_hh_le.c
+++ b/bta/hh/bta_hh_le.c
@@ -31,7 +31,13 @@
 
 #define BTA_HH_LE_RPT_TYPE_VALID(x)     ((x) <= BTA_LE_HID_RPT_FEATURE && (x)>=BTA_LE_HID_RPT_INPUT)
 
+//REALTEK MODIFIED START
+/*original code
 #define BTA_HH_LE_RPT_INST_ID_MAP(s,c)  (UINT8)(((s)<<4)||(c))
+*/
+#define BTA_HH_LE_RPT_INST_ID_MAP(s,c)  (UINT8)(((s)<<4)|(c))
+//REALTEK MODIFIED END
+
 #define BTA_HH_LE_RPT_GET_SRVC_INST_ID(x)  (UINT8)(x  >> 4)
 #define BTA_HH_LE_RPT_GET_RPT_INST_ID(x)  (UINT8)(x & 0x0f)
 
@@ -41,6 +47,8 @@
 
 #define BTA_HH_SCPP_INST_DEF            0
 
+//REALTEK MODIFIED START
+/*original code
 #define BTA_HH_LE_DISC_CHAR_NUM     8
 static const UINT16 bta_hh_le_disc_char_uuid[BTA_HH_LE_DISC_CHAR_NUM] =
 {
@@ -51,8 +59,22 @@ static const UINT16 bta_hh_le_disc_char_uuid[BTA_HH_LE_DISC_CHAR_NUM] =
     GATT_UUID_HID_BT_KB_INPUT,
     GATT_UUID_HID_BT_KB_OUTPUT,
     GATT_UUID_HID_BT_MOUSE_INPUT,
-    GATT_UUID_HID_PROTO_MODE        /* always make sure this is the last attribute to discover */
+    GATT_UUID_HID_PROTO_MODE
+};
+*/
+#define BTA_HH_LE_DISC_CHAR_NUM     4
+static const UINT16 bta_hh_le_disc_char_uuid[BTA_HH_LE_DISC_CHAR_NUM] =
+{
+    GATT_UUID_HID_INFORMATION,
+    GATT_UUID_HID_REPORT_MAP,
+    GATT_UUID_HID_CONTROL_POINT,
+    GATT_UUID_HID_REPORT,
+    //GATT_UUID_HID_BT_KB_INPUT,
+    //GATT_UUID_HID_BT_KB_OUTPUT,
+    //GATT_UUID_HID_BT_MOUSE_INPUT,
+    //GATT_UUID_HID_PROTO_MODE        /* always make sure this is the last attribute to discover */
 };
+//REALTEK MODIFIED END
 
 #define BTA_LE_HID_RTP_UUID_MAX     5
 static const UINT16 bta_hh_uuid_to_rtp_type[BTA_LE_HID_RTP_UUID_MAX][2] =
@@ -196,6 +218,7 @@ void bta_hh_le_enable(void)
     char       app_name[LEN_UUID_128 + 1];
     tBT_UUID    app_uuid = {LEN_UUID_128,{0}};
     UINT8       xx;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     bta_hh_cb.gatt_if = BTA_GATTS_INVALID_IF;
 
@@ -223,6 +246,7 @@ void bta_hh_le_enable(void)
 void bta_hh_le_register_cmpl(tBTA_GATTC_REG *p_reg)
 {
     tBTA_HH_STATUS      status = BTA_HH_ERR;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (p_reg->status == BTA_GATT_OK)
     {
@@ -248,6 +272,7 @@ void bta_hh_le_register_cmpl(tBTA_GATTC_REG *p_reg)
 *******************************************************************************/
 void bta_hh_le_deregister(void)
 {
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
     BTA_GATTC_AppDeregister(bta_hh_cb.gatt_if);
 }
 
@@ -318,6 +343,7 @@ BOOLEAN bta_hh_le_add_hid_srvc_entry(tBTA_HH_DEV_CB *p_dev_cb, UINT8 idx)
 *******************************************************************************/
 void bta_hh_le_open_conn(tBTA_HH_DEV_CB *p_cb, BD_ADDR remote_bda)
 {
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
     /* update cb_index[] map */
     p_cb->hid_handle = BTA_HH_GET_LE_DEV_HDL(p_cb->index);
     memcpy(p_cb->addr, remote_bda, BD_ADDR_LEN);
@@ -575,6 +601,7 @@ tBTA_HH_STATUS bta_hh_le_read_char_dscrpt(tBTA_HH_DEV_CB *p_cb, UINT16 srvc_uuid
     tBT_UUID        descr_uuid;
     tBTA_GATTC_CHAR_DESCR_ID    descr_id;
     tBTA_HH_STATUS  status = BTA_HH_ERR;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     bta_hh_le_fill_16bits_srvc_id(TRUE, srvc_inst_id, srvc_uuid, &char_id.srvc_id);
     bta_hh_le_fill_16bits_char_id(char_inst_id, char_uuid, &char_id.char_id);
@@ -614,6 +641,7 @@ void bta_hh_le_read_rpt_ref_descr(tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_LE_RPT *p_rp
 {
     BOOLEAN started = FALSE;
     UINT16  srvc_uuid, char_uuid;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     while (p_rpt != NULL)
     {
@@ -679,6 +707,7 @@ void bta_hh_le_save_rpt_ref(tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_LE_RPT  *p_rpt,
                             tBTA_GATTC_READ *p_data)
 {
     UINT8 *pp;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     /* if the length of the descriptor value is right, parse it */
     if (p_data->status == BTA_GATT_OK &&
@@ -717,6 +746,7 @@ void bta_hh_le_save_ext_rpt_ref(tBTA_HH_DEV_CB *p_dev_cb,
                                 tBTA_GATTC_READ *p_data)
 {
     UINT8 *pp;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     /* if the length of the descriptor value is right, parse it
       assume it's a 16 bits UUID */
@@ -760,6 +790,8 @@ void bta_hh_le_register_input_notif(tBTA_HH_DEV_CB *p_dev_cb, UINT8 srvc_inst,
     {
         if (p_rpt->rpt_type == BTA_HH_RPTT_INPUT)
         {
+            APPL_TRACE_DEBUG1("bta_hh_le_register_input_notify, rpt type: 0x%04x", p_rpt->uuid);
+
             if (p_rpt->uuid == GATT_UUID_BATTERY_LEVEL)
                 srvc_uuid = UUID_SERVCLASS_BATTERY;
             else
@@ -831,6 +863,7 @@ void bta_hh_le_register_input_notif(tBTA_HH_DEV_CB *p_dev_cb, UINT8 srvc_inst,
 *******************************************************************************/
 void bta_hh_le_open_cmpl(tBTA_HH_DEV_CB *p_cb)
 {
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
     if ( p_cb->disc_active == BTA_HH_LE_DISC_NONE)
     {
 #if BTA_HH_DEBUG
@@ -865,6 +898,9 @@ BOOLEAN bta_hh_le_write_char_clt_cfg(tBTA_HH_DEV_CB *p_cb,
     tBTA_GATT_UNFMT             value;
     UINT8                      buf[2], *pp = buf;
 
+    APPL_TRACE_DEBUG3("bta_hh_le_write_char_clt_cfg, srvc_uuid = 0x%04x, char_uuid = 0x%04x, \
+	                    clt_cfg_value = 0x%02x", srvc_uuid16, char_uuid16, clt_cfg_value);
+
     bta_hh_le_fill_16bits_srvc_id(TRUE, srvc_inst_id, srvc_uuid16, &char_id.srvc_id);
     bta_hh_le_fill_16bits_char_id(char_inst_id, char_uuid16, &char_id.char_id);
 
@@ -883,7 +919,12 @@ BOOLEAN bta_hh_le_write_char_clt_cfg(tBTA_HH_DEV_CB *p_cb,
     {
         BTA_GATTC_WriteCharDescr(p_cb->conn_id,
                             &descr_id,
+                            //REALTEK MODIFIED START
+                            /*original code
                             BTA_GATTC_TYPE_WRITE_NO_RSP,
+                            */
+                            BTA_GATTC_TYPE_WRITE,
+                            //REALTEK MODIFIED END
                             &value,
                             BTA_GATT_AUTH_REQ_NONE);
 
@@ -905,23 +946,43 @@ BOOLEAN bta_hh_le_write_rpt_clt_cfg(tBTA_HH_DEV_CB *p_cb, UINT8 srvc_inst_id)
     tBTA_HH_LE_RPT  *p_rpt = &p_cb->hid_srvc[srvc_inst_id].report[p_cb->clt_cfg_idx];
     UINT16          srvc_uuid;
 
+    APPL_TRACE_DEBUG0("bta_hh_le_write_rpt_clt_cfg++");
     for (i = p_cb->clt_cfg_idx; i < BTA_HH_LE_RPT_MAX && p_rpt->in_use; i ++, p_rpt ++)
     {
         /* enable notification for all input report, regardless mode */
         if (p_rpt->rpt_type == BTA_HH_RPTT_INPUT)
-
         {
             if (p_rpt->uuid == GATT_UUID_BATTERY_LEVEL)
                 srvc_uuid = UUID_SERVCLASS_BATTERY;
             else
                 srvc_uuid = UUID_SERVCLASS_LE_HID;
 
+            //REALTEK ADD START
+            switch(p_rpt->uuid)
+            {
+                case GATT_UUID_HID_BT_KB_INPUT:
+                case GATT_UUID_HID_BT_MOUSE_INPUT:
+                    p_rpt->client_cfg_value = BTA_GATT_CLT_CONFIG_NONE;
+                break;
+                case GATT_UUID_HID_REPORT:
+                    p_rpt->client_cfg_value = BTA_GATT_CLT_CONFIG_NOTIFICATION;
+                break;
+                default:
+                break;
+            }
+            APPL_TRACE_DEBUG1("bta_hh_le_write_rpt_clt_cfg,  client_cfg_value = 0x%02x",p_rpt->client_cfg_value);
+            //REALTEK ADD END
             if (bta_hh_le_write_char_clt_cfg(p_cb,
                                              BTA_HH_LE_RPT_GET_SRVC_INST_ID(p_rpt->inst_id),
                                              srvc_uuid,
                                              BTA_HH_LE_RPT_GET_RPT_INST_ID(p_rpt->inst_id),
                                              p_rpt->uuid,
-                                             BTA_GATT_CLT_CONFIG_NOTIFICATION))
+                                             //REALTEK MODIFIED START
+                                            /*original code
+                                            BTA_GATT_CLT_CONFIG_NOTIFICATION))
+                                            */
+                                            p_rpt->client_cfg_value))
+                                            //REALTEK MODIFIED END
             {
                 p_cb->clt_cfg_idx = i;
                 return TRUE;
@@ -930,6 +991,7 @@ BOOLEAN bta_hh_le_write_rpt_clt_cfg(tBTA_HH_DEV_CB *p_cb, UINT8 srvc_inst_id)
 
     }
     p_cb->clt_cfg_idx = 0;
+    APPL_TRACE_DEBUG1("state = %d", p_cb->state);
 
     /* client configuration is completed, send open callback */
     if (p_cb->state == BTA_HH_W4_CONN_ST)
@@ -939,6 +1001,7 @@ BOOLEAN bta_hh_le_write_rpt_clt_cfg(tBTA_HH_DEV_CB *p_cb, UINT8 srvc_inst_id)
         /* discover scan parameter profile is act as report host */
         bta_hh_le_search_scps(p_cb);
     }
+    APPL_TRACE_DEBUG0("bta_hh_le_write_rpt_clt_cfg--");
     return FALSE;
 }
 
@@ -1013,6 +1076,7 @@ void bta_hh_le_get_protocol_mode(tBTA_HH_DEV_CB *p_cb)
     tBTA_GATTC_CHAR_ID  char_id;
     tBTA_HH_HSDATA    hs_data;
     UINT8 i;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     p_cb->w4_evt = BTA_HH_GET_PROTO_EVT;
 
@@ -1054,6 +1118,7 @@ void bta_hh_le_expl_rpt(tBTA_HH_DEV_CB *p_dev_cb,
                            tBTA_GATT_CHAR_PROP prop)
 {
     tBTA_GATTC_CHAR_ID  char_result;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     do
     {
@@ -1097,6 +1162,7 @@ void bta_hh_le_expl_rpt(tBTA_HH_DEV_CB *p_dev_cb,
 void bta_hh_le_expl_boot_rpt(tBTA_HH_DEV_CB *p_dev_cb, UINT16 char_uuid,
                                 tBTA_GATT_CHAR_PROP prop)
 {
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
     if (bta_hh_le_find_alloc_report_entry(p_dev_cb,
                                       p_dev_cb->cur_srvc_index,
                                       char_uuid,
@@ -1121,6 +1187,7 @@ void bta_hh_le_expl_boot_rpt(tBTA_HH_DEV_CB *p_dev_cb, UINT16 char_uuid,
 void bta_hh_le_dis_cback(BD_ADDR addr, tDIS_VALUE *p_dis_value)
 {
     tBTA_HH_DEV_CB *p_cb = bta_hh_le_find_dev_cb_by_bda(addr);
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
 
     if (p_cb == NULL || p_dis_value == NULL)
@@ -1158,6 +1225,7 @@ void bta_hh_le_dis_cback(BD_ADDR addr, tDIS_VALUE *p_dis_value)
 void bta_hh_le_pri_service_discovery(tBTA_HH_DEV_CB *p_cb)
 {
     tBT_UUID        pri_srvc;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     p_cb->disc_active |= (BTA_HH_LE_DISC_HIDS|BTA_HH_LE_DISC_DIS);
 
@@ -1214,6 +1282,7 @@ void bta_hh_le_encrypt_cback(BD_ADDR bd_addr, void *p_ref_data, tBTM_STATUS resu
 *******************************************************************************/
 void bta_hh_security_cmpl(tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_buf)
 {
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
     if (p_cb->status == BTA_HH_OK)
     {
         /*  discovery has been done for HID service */
@@ -1248,6 +1317,7 @@ void bta_hh_security_cmpl(tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_buf)
 void bta_hh_start_security(tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_buf)
 {
     UINT8           sec_flag=0;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     /* verify bond */
     BTM_GetSecurityFlags(p_cb->addr, &sec_flag);
@@ -1293,6 +1363,7 @@ void bta_hh_gatt_open(tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_buf)
     tBTA_GATTC_OPEN *p_data = &p_buf->le_open;
     UINT8           *p2;
     tHID_STATUS     status = BTA_HH_ERR;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     /* if received invalid callback data , ignore it */
     if (p_cb == NULL || p_data == NULL)
@@ -1341,6 +1412,7 @@ void bta_hh_le_close(tBTA_GATTC_CLOSE * p_data)
     tBTA_HH_DEV_CB *p_dev_cb = bta_hh_le_find_dev_cb_by_bda(p_data->remote_bda);
     tBTA_HH_LE_CLOSE    *p_buf = NULL;
     UINT16  sm_event = BTA_HH_GATT_CLOSE_EVT;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (p_dev_cb != NULL &&
         (p_buf = (tBTA_HH_LE_CLOSE *)GKI_getbuf(sizeof(tBTA_HH_LE_CLOSE))) != NULL)
@@ -1368,6 +1440,7 @@ void bta_hh_le_close(tBTA_GATTC_CLOSE * p_data)
 void bta_hh_le_search_result(tBTA_GATTC_SRVC_RES *p_srvc_result)
 {
     tBTA_HH_DEV_CB *p_dev_cb = bta_hh_le_find_dev_cb_by_conn_id(p_srvc_result->conn_id);
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (p_dev_cb != NULL)
     {
@@ -1473,11 +1546,13 @@ void bta_hh_le_srvc_expl_srvc(tBTA_HH_DEV_CB *p_dev_cb)
 void bta_hh_le_srvc_search_cmpl(tBTA_GATTC_SEARCH_CMPL *p_data)
 {
     tBTA_HH_DEV_CB *p_dev_cb = bta_hh_le_find_dev_cb_by_conn_id(p_data->conn_id);
-
+	APPL_TRACE_DEBUG2("bta_hh_le_srvc_search_cmpl++:p_dev_cb(%p), status(%d)",p_dev_cb, p_data->status);
     /* service search exception or no HID service is supported on remote */
     if (p_dev_cb == NULL)
         return;
 
+    APPL_TRACE_DEBUG1("bta_hh_le_srvc_search_cmpl:p_dev_cb->total_srvc(%d)",p_dev_cb->total_srvc);
+
     if(p_data->status != BTA_GATT_OK || p_dev_cb->total_srvc == 0)
     {
         p_dev_cb->status = BTA_HH_ERR_SDP;
@@ -1494,11 +1569,11 @@ void bta_hh_le_srvc_search_cmpl(tBTA_GATTC_SEARCH_CMPL *p_data)
         }
         else /* discover HID service */
         {
-        p_dev_cb->cur_srvc_index = 0;
-        bta_hh_le_srvc_expl_srvc(p_dev_cb);
+            p_dev_cb->cur_srvc_index = 0;
+            bta_hh_le_srvc_expl_srvc(p_dev_cb);
+        }
     }
 }
-}
 
 /*******************************************************************************
 **
@@ -1516,6 +1591,7 @@ static void bta_hh_le_search_hid_included(tBTA_HH_DEV_CB *p_dev_cb)
     tBTA_GATT_SRVC_ID srvc_id;
     tBTA_GATTC_CHAR_ID  char_result;
     tBTA_GATT_CHAR_PROP prop = 0;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     bta_hh_le_fill_16bits_srvc_id(TRUE, p_dev_cb->cur_srvc_index, UUID_SERVCLASS_LE_HID, &srvc_id);
 
@@ -1601,6 +1677,7 @@ static void bta_hh_le_search_hid_chars(tBTA_HH_DEV_CB *p_dev_cb)
     BOOLEAN     next = TRUE;
     UINT16      char_uuid = 0;
     tBTA_GATT_SRVC_ID srvc_id;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (p_dev_cb->hid_srvc[p_dev_cb->cur_srvc_index].cur_expl_char_idx == BTA_HH_LE_DISC_CHAR_NUM ||
         (p_dev_cb->status != BTA_HH_OK && p_dev_cb->status != BTA_HH_ERR_PROTO))
@@ -1689,6 +1766,7 @@ void bta_hh_le_save_rpt_map(tBTA_HH_DEV_CB *p_dev_cb, tBTA_GATTC_READ *p_data)
 {
     UINT8           *pp ;
     tBTA_HH_LE_HID_SRVC *p_srvc = &p_dev_cb->hid_srvc[p_data->srvc_id.id.inst_id];
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     pp = p_data->p_value->unformat.p_value;
 
@@ -1734,6 +1812,7 @@ void bta_hh_le_proc_get_rpt_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_GATTC_READ *p_da
     tBTA_HH_LE_RPT      *p_rpt;
     tBTA_HH_HSDATA      hs_data;
     UINT8               *pp ;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (p_dev_cb->w4_evt != BTA_HH_GET_RPT_EVT)
     {
@@ -1790,6 +1869,7 @@ void bta_hh_le_proc_read_proto_mode(tBTA_HH_DEV_CB *p_dev_cb, tBTA_GATTC_READ *p
     hs_data.status  = BTA_HH_ERR;
     hs_data.handle  = p_dev_cb->hid_handle;
     hs_data.rsp_data.proto_mode = p_dev_cb->mode;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (p_data->status == BTA_GATT_OK && p_data->p_value)
     {
@@ -1826,6 +1906,7 @@ void bta_hh_w4_le_read_char_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_DATA *p_buf)
 {
     tBTA_GATTC_READ     * p_data = (tBTA_GATTC_READ *)p_buf;
     UINT8               *pp ;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (p_data->char_id.uuid.uu.uuid16 == GATT_UUID_BATTERY_LEVEL)
     {
@@ -1886,6 +1967,7 @@ void bta_hh_w4_le_read_char_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_DATA *p_buf)
 void bta_hh_le_read_char_cmpl (tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_DATA *p_buf)
 {
     tBTA_GATTC_READ * p_data = (tBTA_GATTC_READ *)p_buf;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     switch (p_data->char_id.uuid.uu.uuid16)
     {
@@ -1922,6 +2004,7 @@ void bta_hh_le_read_descr_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_DATA *p_buf)
     tBTA_HH_LE_RPT  *p_rpt;
     tBTA_GATTC_READ * p_data = (tBTA_GATTC_READ *)p_buf;
     UINT8   *pp;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     /* if a report client configuration */
     if (p_data->descr_type.uuid.uu.uuid16 == GATT_UUID_CHAR_CLIENT_CONFIG)
@@ -1943,6 +2026,7 @@ void bta_hh_le_read_battery_level_descr_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_GATT
 {
     tBTA_HH_LE_RPT  *p_rpt;
     UINT16 descr_uuid = p_data->descr_type.uuid.uu.uuid16;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     /* read report reference descriptor for battery level is completed */
     if (descr_uuid == GATT_UUID_RPT_REF_DESCR)
@@ -1973,6 +2057,7 @@ void bta_hh_w4_le_read_descr_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_DATA *p_buf)
     tBTA_HH_LE_RPT  *p_rpt;
     tBTA_GATTC_READ * p_data = (tBTA_GATTC_READ *)p_buf;
     UINT16 char_uuid16;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (p_data == NULL)
         return;
@@ -2024,6 +2109,7 @@ void bta_hh_w4_le_read_descr_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_DATA *p_buf)
 void bta_hh_w4_le_write_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_DATA *p_buf)
 {
     tBTA_GATTC_WRITE    *p_data = (tBTA_GATTC_WRITE *)p_buf;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (p_data == NULL)
         return;
@@ -2056,6 +2142,7 @@ void bta_hh_le_write_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_DATA *p_buf)
     tBTA_GATTC_WRITE    *p_data = (tBTA_GATTC_WRITE *)p_buf;
     tBTA_HH_CBDATA      cback_data ;
     UINT16              cb_evt = p_dev_cb->w4_evt;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (p_data == NULL  || cb_evt == 0)
         return;
@@ -2113,6 +2200,7 @@ void bta_hh_le_write_char_descr_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_DATA *p_b
 {
     tBTA_GATTC_WRITE    *p_data = (tBTA_GATTC_WRITE *)p_buf;
     UINT8   srvc_inst_id, hid_inst_id;
+    APPL_TRACE_DEBUG0("bta_hh_le_write_char_descr_cmp");
 
     /* only write client configuration possible */
     if (p_data && p_data->descr_type.uuid.uu.uuid16 == GATT_UUID_CHAR_CLIENT_CONFIG)
@@ -2126,11 +2214,12 @@ void bta_hh_le_write_char_descr_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_DATA *p_b
             /* fall through */
         case GATT_UUID_HID_BT_KB_INPUT:
         case GATT_UUID_HID_BT_MOUSE_INPUT:
-        case GATT_UUID_HID_REPORT:
+		case GATT_UUID_HID_REPORT:
             if (p_data->status == BTA_GATT_OK)
                 p_dev_cb->hid_srvc[hid_inst_id].report[p_dev_cb->clt_cfg_idx ++].client_cfg_value =
                         BTA_GATT_CLT_CONFIG_NOTIFICATION;
 
+            APPL_TRACE_DEBUG1("hid_inst_id = %d", hid_inst_id);
             bta_hh_le_write_rpt_clt_cfg(p_dev_cb, hid_inst_id);
 
             break;
@@ -2169,6 +2258,7 @@ void bta_hh_le_input_rpt_notify(tBTA_GATTC_NOTIFY *p_data)
     UINT8           app_id;
     UINT8           *p_buf;
     tBTA_HH_LE_RPT  *p_rpt;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (p_dev_cb == NULL)
     {
@@ -2202,9 +2292,20 @@ void bta_hh_le_input_rpt_notify(tBTA_GATTC_NOTIFY *p_data)
 
     APPL_TRACE_ERROR1("Notification received on report ID: %d", p_rpt->rpt_id);
 
-    p_buf[0] = p_rpt->rpt_id;
-    memcpy(&p_buf[1], p_data->value, p_data->len);
-    p_data->len ++;
+    //REALTEK ADD START
+    if(p_rpt->rpt_id != 0)
+    {
+    //REALTEK ADD END
+        p_buf[0] = p_rpt->rpt_id;
+        memcpy(&p_buf[1], p_data->value, p_data->len);
+        p_data->len ++;
+    //REALTEK ADD START
+    }
+    else
+    {
+        memcpy(p_buf, p_data->value, p_data->len);
+    }
+    //REALTEK ADD END
 
     bta_hh_co_data((UINT8)p_dev_cb->hid_handle,
                     p_buf,
@@ -2233,6 +2334,7 @@ void bta_hh_le_open_fail(tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_data)
     tBTA_HH_CONN            conn_dat ;
     tBTA_HH_LE_HID_SRVC     *p_hid_srvc = &p_cb->hid_srvc[0];
     UINT8   i;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     p_cb->disc_active = BTA_HH_LE_DISC_NONE;
     /* Failure in opening connection or GATT discovery failure */
@@ -2268,6 +2370,7 @@ void bta_hh_le_open_fail(tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_data)
 void bta_hh_gatt_close(tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_data)
 {
     tBTA_HH_CBDATA          disc_dat = {BTA_HH_OK, 0};
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     /* finaliza device driver */
     bta_hh_co_close(p_cb->hid_handle, p_cb->app_id);
@@ -2308,6 +2411,7 @@ void bta_hh_gatt_close(tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_data)
 *******************************************************************************/
 void bta_hh_le_api_disc_act(tBTA_HH_DEV_CB *p_cb)
 {
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
     if (p_cb->conn_id != BTA_GATT_INVALID_CONN_ID)
         BTA_GATTC_Close(p_cb->conn_id);
 }
@@ -2326,6 +2430,7 @@ void bta_hh_le_get_rpt(tBTA_HH_DEV_CB *p_cb, UINT8 srvc_inst, tBTA_HH_RPT_TYPE r
     tBTA_HH_LE_RPT  *p_rpt = bta_hh_le_find_rpt_by_idtype(p_cb->hid_srvc[srvc_inst].report, p_cb->mode, r_type, rpt_id);
     tBTA_GATTC_CHAR_ID  char_id;
     UINT16  srvc_uuid = UUID_SERVCLASS_LE_HID;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (p_rpt == NULL)
     {
@@ -2362,6 +2467,7 @@ void bta_hh_le_write_rpt(tBTA_HH_DEV_CB *p_cb, UINT8 srvc_inst,
     tBTA_HH_LE_RPT  *p_rpt;
     tBTA_GATTC_CHAR_ID  char_id;
     UINT8   *p_value, rpt_id;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (p_buf == NULL || p_buf->len == 0)
     {
@@ -2412,6 +2518,7 @@ void bta_hh_le_suspend(tBTA_HH_DEV_CB *p_cb, tBTA_HH_TRANS_CTRL_TYPE ctrl_type)
     tBTA_GATTC_CHAR_ID  char_id;
 
     ctrl_type -= BTA_HH_CTRL_SUSPEND;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     for (i = 0; i < BTA_HH_LE_HID_SRVC_MAX; i ++)
     {
@@ -2438,6 +2545,7 @@ void bta_hh_le_suspend(tBTA_HH_DEV_CB *p_cb, tBTA_HH_TRANS_CTRL_TYPE ctrl_type)
 *******************************************************************************/
 void bta_hh_le_write_dev_act(tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_data)
 {
+	APPL_TRACE_DEBUG1("bta_hh_le_write_dev_act, type = %d", p_data->api_sndcmd.t_type);
     switch(p_data->api_sndcmd.t_type)
     {
         case HID_TRANS_SET_PROTOCOL:
@@ -2503,6 +2611,7 @@ void bta_hh_le_write_dev_act(tBTA_HH_DEV_CB *p_cb, tBTA_HH_DATA *p_data)
 void bta_hh_le_get_dscp_act(tBTA_HH_DEV_CB *p_cb)
 {
     UINT8 i;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     for (i = 0 ;i < BTA_HH_LE_HID_SRVC_MAX; i ++)
     {
@@ -2531,6 +2640,7 @@ static void bta_hh_le_add_dev_bg_conn(tBTA_HH_DEV_CB *p_cb, BOOLEAN check_bond)
 {
     UINT8           sec_flag=0;
     BOOLEAN         to_add = TRUE;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (check_bond)
     {
@@ -2621,6 +2731,7 @@ void bta_hh_le_update_scpp(tBTA_HH_DEV_CB *p_dev_cb, tBTA_HH_DATA *p_buf)
     tBTA_GATTC_CHAR_ID  char_id;
     UINT8   value[4], *p = value;
     tBTA_HH_CBDATA      cback_data ;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (!p_dev_cb->is_le_device ||
         p_dev_cb->mode != BTA_HH_PROTO_RPT_MODE ||
@@ -2743,6 +2854,7 @@ void bta_hh_le_hid_read_rpt_clt_cfg(BD_ADDR bd_addr, UINT8 rpt_id)
     tBTA_HH_DEV_CB *p_cb = NULL;
     tBTA_HH_LE_RPT *p_rpt ;
     UINT8           index = BTA_HH_IDX_INVALID;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     index = bta_hh_find_cb(bd_addr);
     if ((index = bta_hh_find_cb(bd_addr))== BTA_HH_IDX_INVALID)
@@ -2785,6 +2897,7 @@ void bta_hh_le_hid_read_rpt_clt_cfg(BD_ADDR bd_addr, UINT8 rpt_id)
 static void bta_hh_le_search_scps(tBTA_HH_DEV_CB *p_cb)
 {
     tBT_UUID        pri_srvc;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if ( p_cb->mode == BTA_HH_PROTO_RPT_MODE)
     {
@@ -2816,6 +2929,7 @@ static void bta_hh_le_search_scps_chars(tBTA_HH_DEV_CB *p_cb)
 
     p_cb->scps_supported = TRUE;
     bta_hh_le_fill_16bits_srvc_id(TRUE, 0, UUID_SERVCLASS_SCAN_PARAM, &srvc_id);
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     char_cond.len   = LEN_UUID_16;
     char_cond.uu.uuid16 = GATT_UUID_SCAN_REFRESH;
@@ -2827,6 +2941,7 @@ static void bta_hh_le_search_scps_chars(tBTA_HH_DEV_CB *p_cb)
                                 &char_result,
                                 &prop) == BTA_GATT_OK)
     {
+        APPL_TRACE_DEBUG1("prop = 0x%x",prop);
         if (prop & BTA_GATT_CHAR_PROP_BIT_NOTIFY)
             p_cb->scps_notify |= BTA_HH_LE_SCPS_NOTIFY_SPT;
         else
@@ -2849,6 +2964,7 @@ static void bta_hh_le_register_scpp_notif(tBTA_HH_DEV_CB *p_dev_cb, tBTA_GATT_ST
 {
     UINT8               sec_flag=0;
     tBTA_GATTC_CHAR_ID  char_id;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     /* if write scan parameter sucessful */
     /* if bonded and notification is not enabled, configure the client configuration */
@@ -2891,6 +3007,7 @@ static void bta_hh_le_register_scpp_notif_cmpl(tBTA_HH_DEV_CB *p_dev_cb, tBTA_GA
 {
     tBTA_HH_CBDATA      cback_data ;
     UINT16              cb_evt = p_dev_cb->w4_evt;
+    APPL_TRACE_DEBUG1("%s", __FUNCTION__);
 
     if (status == BTA_GATT_OK)
         p_dev_cb->scps_notify = (BTA_HH_LE_SCPS_NOTIFY_ENB | BTA_HH_LE_SCPS_NOTIFY_SPT);
diff --git a/bta/hh/bta_hh_main.c b/bta/hh/bta_hh_main.c
index bf54e57..4bf86c2 100644
--- a/bta/hh/bta_hh_main.c
+++ b/bta/hh/bta_hh_main.c
@@ -413,7 +413,7 @@ BOOLEAN bta_hh_hdl_event(BT_HDR *p_msg)
 {
     UINT8           index = BTA_HH_IDX_INVALID;
     tBTA_HH_DEV_CB *p_cb = NULL;
-
+	APPL_TRACE_DEBUG1("RTKDBG:p_msg->event:(%d)", p_msg->event);
     switch (p_msg->event)
     {
         case BTA_HH_API_ENABLE_EVT:
diff --git a/bta/include/bta_gatt_api.h b/bta/include/bta_gatt_api.h
index 93eadd5..da5f0fb 100644
--- a/bta/include/bta_gatt_api.h
+++ b/bta/include/bta_gatt_api.h
@@ -40,7 +40,7 @@
 
 
 #ifndef     BTA_GATT_DEBUG
-#define     BTA_GATT_DEBUG       FALSE
+#define     BTA_GATT_DEBUG      TRUE
 #endif
 
 /*****************************************************************************
diff --git a/btif/co/bta_dm_co.c b/btif/co/bta_dm_co.c
index fd91817..5c1d302 100644
--- a/btif/co/bta_dm_co.c
+++ b/btif/co/bta_dm_co.c
@@ -27,8 +27,12 @@
 #endif
 #if (defined BLE_INCLUDED && BLE_INCLUDED == TRUE)
 #include "bte_appl.h"
-
+//REALTEK MODIFIED START
+/* original code
 tBTE_APPL_CFG bte_appl_cfg = { 0x5, 0x4, 0x7, 0x7, 0x10 };
+*/
+tBTE_APPL_CFG bte_appl_cfg = { 0x5, 0x4, 0x0, 0x1, 0x10 };
+//REALTEK MODIFIED END
 #endif
 
 /*******************************************************************************
diff --git a/btif/src/btif_dm.c b/btif/src/btif_dm.c
index 2cbf3fa..efd9d41 100644
--- a/btif/src/btif_dm.c
+++ b/btif/src/btif_dm.c
@@ -283,6 +283,7 @@ BOOLEAN check_cod(const bt_bdaddr_t *remote_bdaddr, uint32_t cod)
                                sizeof(uint32_t), &remote_cod);
     if (btif_storage_get_remote_device_property((bt_bdaddr_t *)remote_bdaddr, &prop_name) == BT_STATUS_SUCCESS)
     {
+		BTIF_TRACE_DEBUG1("remote_cod = 0x%x", remote_cod);
         if ((remote_cod & 0x7ff) == cod)
             return TRUE;
     }
@@ -496,10 +497,58 @@ static void btif_dm_cb_hid_remote_name(tBTM_REMOTE_DEV_NAME *p_remote_name)
 static void btif_dm_cb_create_bond(bt_bdaddr_t *bd_addr)
 {
     BOOLEAN is_hid = check_cod(bd_addr, COD_HID_POINTING);
-
+    //REALTEK ADD START
+    BOOLEAN is_hid_major = check_cod(bd_addr, COD_HID_MAJOR);
+    BTIF_TRACE_DEBUG2("is_hid(%d), is_hid_major(%d)", is_hid, is_hid_major);
+    //REALTEK ADD END
 
     bond_state_changed(BT_STATUS_SUCCESS, bd_addr, BT_BOND_STATE_BONDING);
 
+//REALTEK ADD START
+#if BLE_INCLUDED == TRUE
+    if(is_hid_major)
+    {
+        int device_type;
+        int addr_type;
+        int status;
+        bdstr_t bdstr;
+        bd2str(bd_addr, &bdstr);
+        if(btif_config_get_int("Remote", (char const *)&bdstr,"DevType", &device_type) &&
+           (btif_storage_get_remote_addr_type(bd_addr, &addr_type) == BT_STATUS_SUCCESS) &&
+           (device_type == BT_DEVICE_TYPE_BLE))
+        {
+           bt_uuid_t  uuid;
+           int i = 0;
+           int j = 15;
+           {
+              bt_property_t prop;
+              char temp[256];
+              bta_gatt_convert_uuid16_to_uuid128(uuid.uu,UUID_SERVCLASS_LE_HID);
+              while(i < j )
+              {
+                  unsigned char c = uuid.uu[j];
+                  uuid.uu[j] = uuid.uu[i];
+                  uuid.uu[i] = c;
+                  i++;
+                  j--;
+              }
+              uuid_to_string(&uuid, temp);
+              prop.type = BT_PROPERTY_UUIDS;
+              prop.val = uuid.uu;
+              prop.len = MAX_UUID_SIZE;
+
+              status = btif_storage_set_remote_device_property(bd_addr, &prop);
+              ASSERTC(status == BT_STATUS_SUCCESS, "failed to save remote device property", status);
+              /* Send the event to the BTIF */
+              HAL_CBACK(bt_hal_cbacks, remote_device_properties_cb,
+                               BT_STATUS_SUCCESS, bd_addr, 1, &prop);
+              is_hid = TRUE;
+           }
+        }
+	  }
+#endif
+//REALTEK ADD END
+
     if (is_hid){
 
             int status;
diff --git a/stack/btm/btm_ble.c b/stack/btm/btm_ble.c
index ad5663f..745402f 100644
--- a/stack/btm/btm_ble.c
+++ b/stack/btm/btm_ble.c
@@ -589,6 +589,8 @@ void BTM_ReadDevInfo (BD_ADDR remote_bda, tBT_DEVICE_TYPE *p_dev_type, tBLE_ADDR
     *p_dev_type = BT_DEVICE_TYPE_BREDR;
     *p_addr_type = BLE_ADDR_PUBLIC;
 
+    BTM_TRACE_DEBUG2 ("BTM_ReadDevInfo: p_dev_rec(%p), p_inq_info(%p)", p_dev_rec, p_inq_info);
+
     if (!p_dev_rec)
     {
         /* Check with the BT manager if details about remote device are known */
@@ -1544,6 +1546,9 @@ void btm_ble_connected (UINT8 *bda, UINT16 handle, UINT8 enc_mode, UINT8 role,
         p_cb->inq_var.adv_mode  = BTM_BLE_ADV_DISABLE;
     p_cb->inq_var.directed_conn = FALSE;
 
+    //REALTEK ADD START
+    p_cb->wl_state &= ~BTM_BLE_WL_INIT;
+    //REALTEK ADD END
     return;
 }
 
diff --git a/stack/btm/btm_ble_bgconn.c b/stack/btm/btm_ble_bgconn.c
index 727390c..6151fcc 100644
--- a/stack/btm/btm_ble_bgconn.c
+++ b/stack/btm/btm_ble_bgconn.c
@@ -188,6 +192,7 @@ BOOLEAN btm_update_dev_to_white_list(BOOLEAN to_add, BD_ADDR bd_addr, UINT8 attr
     BOOLEAN     started = FALSE;
     UINT8       wl_state = p_cb->wl_state;
 
+    BTM_TRACE_DEBUG3("to_add(%d), attr(%d), wl_state(%d)", to_add, attr, wl_state);
     if ((to_add && p_cb->num_empty_filter == 0) ||
         (!to_add && p_cb->num_empty_filter == p_cb->max_filter_entries))
     {
@@ -387,6 +392,9 @@ BOOLEAN btm_ble_start_auto_conn(BOOLEAN start)
             }
             else
             {
+                //REALTEK ADD START
+                p_cb->wl_state |= BTM_BLE_WL_INIT;
+                //REALTEK ADD END
                 btm_ble_set_conn_st (BLE_BG_CONN);
 
             }
diff --git a/stack/btm/btm_ble_gap.c b/stack/btm/btm_ble_gap.c
index 387f661..f3b9fbf 100644
--- a/stack/btm/btm_ble_gap.c
+++ b/stack/btm/btm_ble_gap.c
@@ -1540,6 +1540,9 @@ BOOLEAN btm_ble_update_inq_result(tINQ_DB_ENT *p_i, UINT8 addr_type, UINT8 evt_t
     if ((btm_cb.ble_ctr_cb.inq_var.scan_type == BTM_BLE_SCAN_MODE_ACTI &&
          (evt_type == BTM_BLE_CONNECT_EVT || evt_type == BTM_BLE_DISCOVER_EVT)))
     {
+
+        BTM_TRACE_WARNING2("scan_type:%d, evt_type:%d", btm_cb.ble_ctr_cb.inq_var.scan_type,
+				evt_type);
         p_i->scan_rsp = FALSE;
         to_report = FALSE;
     }
@@ -1667,6 +1670,78 @@ void btm_ble_process_adv_pkt (UINT8 *p_data)
     btm_ble_process_adv_pkt_cont(bda, addr_type, evt_type, p);
 }
 
+//REALTEK ADD START
+int btm_ble_check_cod(UINT8* data, UINT8* flag)
+{
+    UINT8 data_len = *data;
+    UINT8* p;
+    BOOLEAN isServiceExist = FALSE;
+    int class_of_device = 0;
+    int len, i;
+    int type;
+    int num_service;
+    short service;
+    data ++;
+    if(data_len == 0)
+        return class_of_device;
+
+    BTM_TRACE_ERROR1("data_len = %d", data_len);
+    for(i = 0; i<data_len; i++)
+        BTM_TRACE_ERROR2("data[%d] = %x", i, data[i]);
+
+    while( data_len != 0) {
+        len = *data;
+        if(len> data_len) {
+            BTM_TRACE_ERROR2("data_len = %d, len = %d, data length is error", data_len
+, data);
+            return class_of_device;
+        }
+
+        data_len -= (len+1);
+
+        data++;
+        type = *data;
+        data++;
+        switch(type)
+        {
+            case BTM_BLE_AD_TYPE_FLAG:
+                *flag = data[0];
+                break;
+            case BTM_BLE_AD_TYPE_DEV_CLASS:
+                class_of_device = data[0] | data[1] <<8 | data [2] <<16;
+                break;
+
+            case BTM_BLE_AD_TYPE_16SRV_PART:
+            case BTM_BLE_AD_TYPE_16SRV_CMPL:
+                num_service = (len - 1)/2;
+                service = 0;
+                p = data;
+                for(i=0; i<num_service; i++)
+                {
+                    service = p[0] | p[1] <<8;
+                    p += 2;
+                    if(service == 0x1812)
+                    {
+                        isServiceExist = TRUE;
+                        break;
+                    }
+                }
+
+            break;
+        }
+        data += len -1;
+    }
+
+    if(class_of_device != 0)
+        return class_of_device;
+
+    if(isServiceExist)
+            class_of_device = 0x0500;
+
+    return class_of_device;
+}
+//REALTEK ADD END
+
 /*******************************************************************************
 **
 ** Function         btm_ble_process_adv_pkt_cont
@@ -1686,6 +1761,9 @@ static void btm_ble_process_adv_pkt_cont(BD_ADDR bda, UINT8 addr_type, UINT8 evt
     tBTM_INQUIRY_VAR_ST  *p_inq = &btm_cb.btm_inq_vars;
     tBTM_INQ_RESULTS_CB  *p_inq_results_cb = p_inq->p_inq_results_cb;
     tBTM_BLE_INQ_CB      *p_le_inq_cb = &btm_cb.ble_ctr_cb.inq_var;
+    UINT8* pp = p;
+    UINT32 cod = 0;
+    UINT8  flag = 0;
 
     p_i = btm_inq_db_find (bda);
 
@@ -1706,26 +1784,37 @@ static void btm_ble_process_adv_pkt_cont(BD_ADDR bda, UINT8 addr_type, UINT8 evt
         else
         {
             /* if yes, skip it */
-            return; /* assumption: one result per event */
+            //REALTEK MODIFIED START
+            BTM_TRACE_DEBUG0("LE in le_bd_db already");
+            to_report = TRUE;
+            //return; /* assumption: one result per event */
+            //REALTEK MODIFIED END
         }
     }
     else /* not been processed int his round */
     {
         to_report = TRUE;
+        BTM_TRACE_DEBUG0("Report New LE device ");
     }
 
     /* If existing entry, use that, else get  a new one (possibly reusing the oldest) */
     if (p_i == NULL)
     {
+
+        BTM_TRACE_DEBUG0("p_i is NULL ");
         if (btm_ble_is_discoverable(bda, evt_type, p))
         {
             if ((p_i = btm_inq_db_new (bda)) != NULL)
             {
                 p_inq->inq_cmpl_info.num_resp++;
                 to_report = TRUE;
+                BTM_TRACE_DEBUG0("p_i is NULL 1 ");
             }
             else
+            {
+                BTM_TRACE_DEBUG0("p_i is NULL 2 ");
                 return;
+            }
         }
         else
         {
@@ -1742,6 +1831,13 @@ static void btm_ble_process_adv_pkt_cont(BD_ADDR bda, UINT8 addr_type, UINT8 evt
     if (to_report)
     {
         to_report = btm_ble_update_inq_result(p_i, addr_type, evt_type, p);
+        //REALTEK ADD START
+        cod = btm_ble_check_cod(pp , &flag);
+        BTM_TRACE_ERROR1("cod = 0x%x", cod);
+        p_i->inq_info.results.dev_class[2] = (UINT8)(cod &0xff);
+        p_i->inq_info.results.dev_class[1] = (UINT8)((cod &0xff00) >>8);
+        p_i->inq_info.results.dev_class[0] = (UINT8)((cod &0xff0000) >>16);
+        //REALTEK ADD END
     }
 
 #if BTM_USE_INQ_RESULTS_FILTER == TRUE
@@ -1771,6 +1867,7 @@ static void btm_ble_process_adv_pkt_cont(BD_ADDR bda, UINT8 addr_type, UINT8 evt
     }
 #endif
 
+    BTM_TRACE_DEBUG2("p_inq_result_cb: %p, to_report:%d", p_inq_results_cb, to_report);
     /* background connection in selective connection mode */
     if (btm_cb.ble_ctr_cb.bg_conn_type == BTM_BLE_CONN_SELECTIVE)
     {
@@ -1784,8 +1881,12 @@ static void btm_ble_process_adv_pkt_cont(BD_ADDR bda, UINT8 addr_type, UINT8 evt
     }
     else if (p_inq_results_cb && to_report)
     {
+        BTM_TRACE_DEBUG0("ip_inq_result_cb is not NULL ,call it ");
         (p_inq_results_cb)((tBTM_INQ_RESULTS *) &p_i->inq_info.results, p_le_inq_cb->adv_data_cache);
     }
 }
 
 /*******************************************************************************
diff --git a/stack/btm/btm_devctl.c b/stack/btm/btm_devctl.c
index 99288e0..9d9bfc8 100644
--- a/stack/btm/btm_devctl.c
+++ b/stack/btm/btm_devctl.c
@@ -1091,10 +1091,15 @@ static void btm_decode_ext_features_page (UINT8 page_number, const UINT8 *p_feat
             BTM_SetInquiryMode (BTM_INQ_RESULT_WITH_RSSI);
 #endif
 #if L2CAP_NON_FLUSHABLE_PB_INCLUDED == TRUE
+        //REALTEK MODIFIED START
+        /*original code
         if( HCI_NON_FLUSHABLE_PB_SUPPORTED(p_features))
             l2cu_set_non_flushable_pbf(TRUE);
         else
             l2cu_set_non_flushable_pbf(FALSE);
+        */
+        l2cu_set_non_flushable_pbf(TRUE);
+        //REALTEK MODIFIED END
 #endif
         BTM_SetPageScanType (BTM_DEFAULT_SCAN_TYPE);
         BTM_SetInquiryScanType (BTM_DEFAULT_SCAN_TYPE);
diff --git a/stack/gatt/gatt_cl.c b/stack/gatt/gatt_cl.c
index b173be9..d5bfc36 100644
--- a/stack/gatt/gatt_cl.c
+++ b/stack/gatt/gatt_cl.c
@@ -1166,6 +1166,7 @@ void gatt_client_handle_server_rsp (tGATT_TCB *p_tcb, UINT8 op_code,
     }
     else
     {
+        GATT_TRACE_DEBUG1("realtek debug: ATT RX opcode = %d", op_code);
         switch (op_code)
         {
             case GATT_RSP_ERROR:
diff --git a/stack/gatt/gatt_utils.c b/stack/gatt/gatt_utils.c
index e15918c..3ae5240 100644
--- a/stack/gatt/gatt_utils.c
+++ b/stack/gatt/gatt_utils.c
@@ -2594,7 +2594,7 @@ BOOLEAN gatt_update_auto_connect_dev (tGATT_IF gatt_if, BOOLEAN add, BD_ADDR bd_
     tGATT_REG        *p_reg;
     tGATT_TCB       *p_tcb = gatt_find_tcb_by_addr(bd_addr);
 
-    GATT_TRACE_API0 ("gatt_update_auto_connect_dev ");
+    GATT_TRACE_API2 ("gatt_update_auto_connect_dev, add(%d), s_initiator(%d)", add, is_initator);
     /* Make sure app is registered */
     if ((p_reg = gatt_get_regcb(gatt_if)) == NULL)
     {
 
diff --git a/stack/include/btm_ble_api.h b/stack/include/btm_ble_api.h
index 0dcc8d2..f126fd8 100644
--- a/stack/include/btm_ble_api.h
+++ b/stack/include/btm_ble_api.h
@@ -87,7 +87,12 @@ typedef UINT8   tBTM_BLE_SFP;
 #define BTM_BLE_SCAN_INT_MAX            0x4000
 #define BTM_BLE_SCAN_WIN_MIN            0x0004
 #define BTM_BLE_SCAN_WIN_MAX            0x4000
+//REALTEK MODIFIED START
+/*original code
 #define BTM_BLE_CONN_INT_MIN            0x0006
+*/
+#define BTM_BLE_CONN_INT_MIN            0x000C
+//REALTEK MODIFIED END
 #define BTM_BLE_CONN_INT_MAX            0x0C80
 #define BTM_BLE_CONN_LATENCY_MAX        500
 #define BTM_BLE_CONN_SUP_TOUT_MIN       0x000A
@@ -123,11 +128,21 @@ typedef UINT8   tBTM_BLE_SFP;
 
 /* default connection interval min */
 #ifndef BTM_BLE_CONN_INT_MIN_DEF
-#define BTM_BLE_CONN_INT_MIN_DEF     24      /* recommended min: 30ms  = 24 * 1.25 */
+//REALTEK MODIFIED START
+/*original code
+#define BTM_BLE_CONN_INT_MIN_DEF            24
+*/
+#define BTM_BLE_CONN_INT_MIN_DEF     0x0C      /* recommended min: 30ms  = 24 * 1.25 */
+//REALTEK MODIFIED END
 #endif
 /* default connectino interval max */
 #ifndef BTM_BLE_CONN_INT_MAX_DEF
-#define BTM_BLE_CONN_INT_MAX_DEF     40      /* recommended max: 50 ms = 56 * 1.25 */
+//REALTEK MODIFIED START
+/*original code
+#define BTM_BLE_CONN_INT_MAX_DEF            40
+*/
+#define BTM_BLE_CONN_INT_MAX_DEF     0x0C      /* recommended max: 50 ms = 56 * 1.25 */
+//REALTEK MODIFIED END
 #endif
 /* default slave latency */
 #ifndef BTM_BLE_CONN_SLAVE_LATENCY_DEF
@@ -135,7 +150,13 @@ typedef UINT8   tBTM_BLE_SFP;
 #endif
 /* default supervision timeout */
 #ifndef BTM_BLE_CONN_TIMEOUT_DEF
-#define BTM_BLE_CONN_TIMEOUT_DEF    2000
+//REALTEK MODIFIED START
+//REALTEK MODIFIED START
+/*original code
+#define BTM_BLE_CONN_TIMEOUT_DEF            2000
+*/
+#define BTM_BLE_CONN_TIMEOUT_DEF    0x64
+//REALTEK MODIFIED END
 #endif
 
 #define BTM_BLE_DIR_CONN_FALLBACK_UNDIR         1
diff --git a/stack/l2cap/l2c_api.c b/stack/l2cap/l2c_api.c
index 30249a4..ed3b6b8 100644
--- a/stack/l2cap/l2c_api.c
+++ b/stack/l2cap/l2c_api.c
@@ -1422,6 +1422,15 @@ UINT16 L2CA_SendFixedChnlData (UINT16 fixed_cid, BD_ADDR rem_bda, BT_HDR *p_buf)
     }
 
     p_buf->event = 0;
+    //REALTEK ADD START
+    if(fixed_cid == L2CAP_ATT_CID || fixed_cid == L2CAP_BLE_SIGNALLING_CID || fixed_cid == L2CAP_SMP_CID)
+    {
+        L2CAP_TRACE_WARNING0 ("L2CAP_NON_FLUSHABLE_PKT");
+        L2CAP_TRACE_WARNING0 ("irealtek debug: ATT TX packet");
+        p_buf->layer_specific = L2CAP_NON_FLUSHABLE_PKT;
+    }
+    else
+    //REALTEK ADD END
     p_buf->layer_specific = L2CAP_FLUSHABLE_CH_BASED;
 
     if (!p_lcb->p_fixed_ccbs[fixed_cid - L2CAP_FIRST_FIXED_CHNL])
diff --git a/stack/l2cap/l2c_ble.c b/stack/l2cap/l2c_ble.c
index 494c6e6..ab1ea9f 100644
--- a/stack/l2cap/l2c_ble.c
+++ b/stack/l2cap/l2c_ble.c
@@ -557,7 +557,11 @@ BOOLEAN l2cble_init_direct_conn (tL2C_LCB *p_lcb)
                                         (UINT16) ((p_dev_rec->conn_params.min_conn_int != BTM_BLE_CONN_PARAM_UNDEF) ? p_dev_rec->conn_params.min_conn_int : BTM_BLE_CONN_INT_MIN),  /* UINT16 conn_int_min  */
                                         (UINT16) ((p_dev_rec->conn_params.max_conn_int != BTM_BLE_CONN_PARAM_UNDEF) ? p_dev_rec->conn_params.max_conn_int : BTM_BLE_CONN_INT_MIN),  /* UINT16 conn_int_max  */
                                         (UINT16) ((p_dev_rec->conn_params.slave_latency != BTM_BLE_CONN_PARAM_UNDEF) ? p_dev_rec->conn_params.slave_latency : 0), /* UINT16 conn_latency  */
-                                        (UINT16) ((p_dev_rec->conn_params.supervision_tout != BTM_BLE_CONN_PARAM_UNDEF) ? p_dev_rec->conn_params.supervision_tout : BTM_BLE_CONN_SUP_TOUT_DEF), /* UINT16 conn_timeout  */
+                                        //REALTEK MODIFIED START
+                                        //original code
+                                        //(UINT16) ((p_dev_rec->conn_params.supervision_tout != BTM_BLE_CONN_PARAM_UNDEF) ? p_dev_rec->conn_params.supervision_tout : BTM_BLE_CONN_SUP_TOUT_DEF), /* UINT16 conn_timeout  */
+                                        0x64,
+                                        //REALTEK MODIFIED END
                                         0,                       /* UINT16 min_len       */
                                         0))                      /* UINT16 max_len       */
     {
diff --git a/stack/srvc/srvc_dis.c b/stack/srvc/srvc_dis.c
index 505d791..44a84c6 100644
--- a/stack/srvc/srvc_dis.c
+++ b/stack/srvc/srvc_dis.c
@@ -419,10 +419,15 @@ BOOLEAN DIS_ReadDISInfo(BD_ADDR peer_bda, tDIS_READ_CBACK *p_cback)
 
     /* For now we only handle one at a time */
     if (dis_cb.dis_read_uuid_idx != 0xff)
+	{
+		GATT_TRACE_ERROR1("uuid_idx= %x",dis_cb.dis_read_uuid_idx);
         return(FALSE);
-
+	}
     if (p_cback == NULL)
+	{
+		GATT_TRACE_ERROR0("p_cback is NULL");
         return(FALSE);
+	}
 
     dis_cb.p_read_dis_cback = p_cback;
     /* Mark currently active operation */
diff --git a/stack/srvc/srvc_eng.c b/stack/srvc/srvc_eng.c
index c4f5527..962c3e0 100644
--- a/stack/srvc/srvc_eng.c
+++ b/stack/srvc/srvc_eng.c
@@ -388,12 +388,18 @@ BOOLEAN srvc_eng_request_channel (BD_ADDR remote_bda, UINT8 srvc_id )
 void srvc_eng_release_channel (UINT16 conn_id)
 {
     tSRVC_CLCB *p_clcb =  srvc_eng_find_clcb_by_conn_id(conn_id);
-
+    //REALTEK ADD START
+    if(p_clcb)
+    {
+    //REALTEK ADD END
     p_clcb->cur_srvc_id = SRVC_ID_NONE;
 
     /* check pending request */
     //if (p_clcb->pend_req == NULL)
         GATT_Disconnect(p_clcb->conn_id);
+    //REALTEK ADD START
+    }
+    //REALTEK ADD END
 }
 /*******************************************************************************
 **
diff --git a/tools/gen-buildcfg.sh b/tools/gen-buildcfg.sh
old mode 100644
new mode 100755
-- 
1.8.5.rc2

