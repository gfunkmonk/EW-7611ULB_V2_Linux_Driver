From 8e82dc6cfe5882bbb95033da58d7d676aa663cea Mon Sep 17 00:00:00 2001
From: ranhui_xia <ranhui_xia@realsil.com.cn>
Date: Thu, 12 Dec 2013 17:31:48 +0800
Subject: [PATCH 12/13] Realtek BT: Add protection to gki module

Fix gki timer crash bug when bt is running

Signed-off-by: ranhui_xia <ranhui_xia@realsil.com.cn>
---
 bta/sys/ptim.c        |  8 ++++++++
 gki/common/gki_time.c | 50 +++++++++++++++++++++++++++++++++++++++-----------
 2 files changed, 47 insertions(+), 11 deletions(-)

diff --git a/bta/sys/ptim.c b/bta/sys/ptim.c
index 9dffc66..a9de080 100644
--- a/bta/sys/ptim.c
+++ b/bta/sys/ptim.c
@@ -27,6 +27,11 @@
 #include "ptim.h"
 #include "bta_sys.h"
 
+//REALTEK ADD START
+#include <cutils/log.h>
+static pthread_mutex_t pt_time_mutex = PTHREAD_MUTEX_INITIALIZER;
+//REALTEK ADD END
+
 /*******************************************************************************
 **
 ** Function         ptim_init
@@ -126,6 +131,8 @@ void ptim_timer_update(tPTIM_CB *p_cb)
 *******************************************************************************/
 void ptim_start_timer(tPTIM_CB *p_cb, TIMER_LIST_ENT *p_tle, UINT16 type, INT32 timeout)
 {
+    pthread_mutex_lock(&pt_time_mutex);
+
     /* if timer list is currently empty, start periodic GKI timer */
     if (p_cb->timer_queue.p_first == NULL)
     {
@@ -139,6 +146,7 @@ void ptim_start_timer(tPTIM_CB *p_cb, TIMER_LIST_ENT *p_tle, UINT16 type, INT32
     p_tle->ticks = timeout;
 
     GKI_add_to_timer_list(&p_cb->timer_queue, p_tle);
+    pthread_mutex_unlock(&pt_time_mutex);
 }
 
 /*******************************************************************************
diff --git a/gki/common/gki_time.c b/gki/common/gki_time.c
index a9af8fa..87725bb 100644
--- a/gki/common/gki_time.c
+++ b/gki/common/gki_time.c
@@ -18,7 +18,7 @@
 
 
 #include "gki_int.h"
-
+#include <cutils/log.h>
 #ifndef BT_ERROR_TRACE_0
 #define BT_ERROR_TRACE_0(l,m)
 #endif
@@ -441,7 +441,7 @@ void GKI_timer_update (INT32 ticks_since_last_update)
      */
     gki_cb.com.OSNumOrigTicks -= gki_cb.com.OSTicksTilExp;
 
-#if GKI_TIMER_LIST_NOPREEMPT == TRUE
+//#if GKI_TIMER_LIST_NOPREEMPT == TRUE
     /* Protect this section because if a GKI_timer_stop happens between:
      *   - gki_cb.com.OSTaskTmr0[task_id] -= gki_cb.com.OSNumOrigTicks;
      *   - gki_cb.com.OSTaskTmr0[task_id] = gki_cb.com.OSTaskTmr0R[task_id];
@@ -449,7 +449,7 @@ void GKI_timer_update (INT32 ticks_since_last_update)
      * Note: Not needed if this function cannot be preempted (typical).
      */
     GKI_disable();
-#endif
+//#endif
 
     /* Check for OS Task Timers */
     for (task_id = 0; task_id < GKI_MAX_TASKS; task_id++)
@@ -562,10 +562,10 @@ void GKI_timer_update (INT32 ticks_since_last_update)
 
     }
 
-#if GKI_TIMER_LIST_NOPREEMPT == TRUE
+//#if GKI_TIMER_LIST_NOPREEMPT == TRUE
     /* End the critical section */
     GKI_enable();
-#endif
+//#endif
 
     /* Set the next timer experation value if there is one to start */
     if (next_expiration < GKI_NO_NEW_TMRS_STARTED)
@@ -696,6 +696,8 @@ UINT16 GKI_update_timer_list (TIMER_LIST_Q *p_timer_listq, INT32 num_units_since
     INT32            rem_ticks;
     INT32            temp_ticks;
 
+    GKI_disable();
+
     p_tle = p_timer_listq->p_first;
 
     /* First, get the guys who have previously timed out */
@@ -739,7 +741,7 @@ UINT16 GKI_update_timer_list (TIMER_LIST_Q *p_timer_listq, INT32 num_units_since
         if (p_timer_listq->last_ticks < 0)
             p_timer_listq->last_ticks = 0;
     }
-
+    GKI_enable();
     return (num_time_out);
 }
 
@@ -762,6 +764,8 @@ UINT32 GKI_get_remaining_ticks (TIMER_LIST_Q *p_timer_listq, TIMER_LIST_ENT  *p_
     TIMER_LIST_ENT  *p_tle;
     UINT32           rem_ticks = 0;
 
+    GKI_disable();
+
     if (p_target_tle->in_use)
     {
         p_tle = p_timer_listq->p_first;
@@ -788,7 +792,7 @@ UINT32 GKI_get_remaining_ticks (TIMER_LIST_Q *p_timer_listq, TIMER_LIST_ENT  *p_
     {
         BT_ERROR_TRACE_0(TRACE_LAYER_GKI, "GKI_get_remaining_ticks: timer entry is not active");
     }
-
+	GKI_enable();
     return (rem_ticks);
 }
 
@@ -814,6 +818,14 @@ void GKI_add_to_timer_list (TIMER_LIST_Q *p_timer_listq, TIMER_LIST_ENT  *p_tle)
     UINT8 tt;
     TIMER_LIST_ENT  *p_temp;
 
+    GKI_disable();
+
+    if(p_timer_listq == NULL|| p_tle == NULL || p_tle->ticks == (INT32)GKI_UNUSED_LIST_ENTRY)
+    {
+        GKI_enable();
+        return;
+    }
+
     /* Only process valid tick values */
     if (p_tle->ticks >= 0)
     {
@@ -848,8 +860,13 @@ void GKI_add_to_timer_list (TIMER_LIST_Q *p_timer_listq, TIMER_LIST_ENT  *p_tle)
                 /* Update the tick value if looking at an unexpired entry */
                 if (p_temp->ticks > 0)
                     p_tle->ticks -= p_temp->ticks;
-
                 p_temp = p_temp->p_next;
+                if(p_temp == NULL)
+                {
+                    ALOGI("p_temp is NULL");
+                    GKI_enable();
+                    return;
+                }
             }
 
             /* The new entry is the first in the list */
@@ -875,7 +892,10 @@ void GKI_add_to_timer_list (TIMER_LIST_Q *p_timer_listq, TIMER_LIST_ENT  *p_tle)
         for (tt = 0; tt < GKI_MAX_TIMER_QUEUES; tt++)
         {
              if (gki_cb.com.timer_queues[tt] == p_timer_listq)
+             {
+                 GKI_enable();
                  return;
+             }
         }
         /* add this timer queue to the array */
         for (tt = 0; tt < GKI_MAX_TIMER_QUEUES; tt++)
@@ -889,6 +909,8 @@ void GKI_add_to_timer_list (TIMER_LIST_Q *p_timer_listq, TIMER_LIST_ENT  *p_tle)
         }
     }
 
+    GKI_enable();
+
     return;
 }
 
@@ -909,10 +931,11 @@ void GKI_add_to_timer_list (TIMER_LIST_Q *p_timer_listq, TIMER_LIST_ENT  *p_tle)
 void GKI_remove_from_timer_list (TIMER_LIST_Q *p_timer_listq, TIMER_LIST_ENT  *p_tle)
 {
     UINT8 tt;
-
+    GKI_disable();
     /* Verify that the entry is valid */
     if (p_tle == NULL || p_tle->in_use == FALSE || p_timer_listq->p_first == NULL)
     {
+        GKI_enable();
         return;
     }
 
@@ -956,6 +979,8 @@ void GKI_remove_from_timer_list (TIMER_LIST_Q *p_timer_listq, TIMER_LIST_ENT  *p
             else
             {
                 /* Error case - chain messed up ?? */
+                ALOGE("Error case - chain messed up1");
+                GKI_enable();
                 return;
             }
 
@@ -964,6 +989,8 @@ void GKI_remove_from_timer_list (TIMER_LIST_Q *p_timer_listq, TIMER_LIST_ENT  *p
             else
             {
                 /* Error case - chain messed up ?? */
+                ALOGE("Error case - chain messed up2");
+                GKI_enable();
                 return;
             }
         }
@@ -985,7 +1012,7 @@ void GKI_remove_from_timer_list (TIMER_LIST_Q *p_timer_listq, TIMER_LIST_ENT  *p
             }
         }
     }
-
+    GKI_enable();
     return;
 }
 
@@ -1009,6 +1036,7 @@ void GKI_remove_from_timer_list (TIMER_LIST_Q *p_timer_listq, TIMER_LIST_ENT  *p
 *******************************************************************************/
 void gki_adjust_timer_count (INT32 ticks)
 {
+    GKI_disable();
     if (ticks > 0)
     {
         /* See if the new timer expires before the current first expiration */
@@ -1018,6 +1046,6 @@ void gki_adjust_timer_count (INT32 ticks)
             gki_cb.com.OSTicksTilExp = ticks;
         }
     }
-
+    GKI_enable();
     return;
 }
-- 
1.8.5.rc2

