diff --git a/Android.mk b/Android.mk
old mode 100644
new mode 100755
index c5d3d16..ae7a2a6
--- a/Android.mk
+++ b/Android.mk
@@ -1,5 +1,25 @@
 LOCAL_PATH := $(call my-dir)
 
+ifeq ($(BOARD_HAVE_BLUETOOTH_RTK),true)
+# RealTek Bluetooth private configuration table
+bdroid_CFLAGS := -Wno-unused-parameter
+rtkbt_bdroid_C_INCLUDES += $(LOCAL_PATH)/bta/hh
+rtkbt_bdroid_C_INCLUDES += $(LOCAL_PATH)/bta/dm
+rtkbt_bdroid_CFLAGS += -DBLUETOOTH_RTK
+rtkbt_bdroid_CFLAGS += -DBLUETOOTH_RTK_API
+ifeq ($(BOARD_HAVE_BLUETOOTH_RTK_COEX),true)
+rtkbt_bdroid_CFLAGS += -DBLUETOOTH_RTK_COEX
+endif
+
+# Setup bdroid local make variables for handling configuration
+ifneq ($(BOARD_BLUETOOTH_BDROID_BUILDCFG_INCLUDE_DIR),)
+  bdroid_C_INCLUDES := $(BOARD_BLUETOOTH_BDROID_BUILDCFG_INCLUDE_DIR) $(rtkbt_bdroid_C_INCLUDES)
+  bdroid_CFLAGS += -DHAS_BDROID_BUILDCFG  $(rtkbt_bdroid_CFLAGS)
+else
+  bdroid_C_INCLUDES := $(rtkbt_bdroid_C_INCLUDES)
+  bdroid_CFLAGS += -DHAS_NO_BDROID_BUILDCFG  $(rtkbt_bdroid_CFLAGS)
+endif
+else
 # Setup bdroid local make variables for handling configuration
 ifneq ($(BOARD_BLUETOOTH_BDROID_BUILDCFG_INCLUDE_DIR),)
   bdroid_C_INCLUDES := $(BOARD_BLUETOOTH_BDROID_BUILDCFG_INCLUDE_DIR)
@@ -8,6 +28,7 @@ else
   bdroid_C_INCLUDES :=
   bdroid_CFLAGS += -DHAS_NO_BDROID_BUILDCFG
 endif
+endif
 
 ifneq ($(BOARD_BLUETOOTH_BDROID_HCILP_INCLUDED),)
   bdroid_CFLAGS += -DHCILP_INCLUDED=$(BOARD_BLUETOOTH_BDROID_HCILP_INCLUDED)
diff --git a/bta/hh/bta_hh_le.c b/bta/hh/bta_hh_le.c
old mode 100644
new mode 100755
index 48b0610..c63964e
--- a/bta/hh/bta_hh_le.c
+++ b/bta/hh/bta_hh_le.c
@@ -34,6 +34,9 @@
 #define LOG_TAG "bt_bta_hh"
 #include "osi/include/log.h"
 
+#ifdef BLUETOOTH_RTK_COEX
+#include "rtk_parse.h"
+#endif
 #ifndef BTA_HH_LE_RECONN
 #define BTA_HH_LE_RECONN    TRUE
 #endif
@@ -2345,6 +2348,9 @@ void bta_hh_le_input_rpt_notify(tBTA_GATTC_NOTIFY *p_data)
     UINT8           *p_buf;
     tBTA_HH_LE_RPT  *p_rpt;
 
+#ifdef BLUETOOTH_RTK_COEX
+    UINT8   data_type = 0;
+#endif
     if (p_dev_cb == NULL)
     {
         APPL_TRACE_ERROR("notification received from Unknown device");
@@ -2372,6 +2378,10 @@ void bta_hh_le_input_rpt_notify(tBTA_GATTC_NOTIFY *p_data)
     /* need to append report ID to the head of data */
     if (p_rpt->rpt_id != 0)
     {
+#ifdef BLUETOOTH_RTK_COEX
+        data_type = p_rpt->rpt_id;
+        rtk_parse_manager_get_interface()->rtk_add_le_data_count(data_type);
+#endif
         if ((p_buf = (UINT8 *)GKI_getbuf((UINT16)(p_data->len + 1))) == NULL)
         {
             APPL_TRACE_ERROR("No resources to send report data");
@@ -2382,6 +2392,10 @@ void bta_hh_le_input_rpt_notify(tBTA_GATTC_NOTIFY *p_data)
         memcpy(&p_buf[1], p_data->value, p_data->len);
         ++p_data->len;
     } else {
+#ifdef BLUETOOTH_RTK_COEX
+        data_type = 1;
+        rtk_parse_manager_get_interface()->rtk_add_le_data_count(data_type);
+#endif
         p_buf = p_data->value;
     }
 
diff --git a/btif/src/btif_core.c b/btif/src/btif_core.c
old mode 100644
new mode 100755
index d552e5c..a245124
--- a/btif/src/btif_core.c
+++ b/btif/src/btif_core.c
@@ -1051,6 +1051,10 @@ bt_status_t btif_set_adapter_property(const bt_property_t *property)
                 BTA_DmSetDeviceName((char *)bd_name);
 
                 storage_req_id = BTIF_CORE_STORAGE_ADAPTER_WRITE;
+#ifdef BLUETOOTH_RTK
+                btif_config_set_str("Adapter", "Name",(char *)bd_name);
+                btif_config_save();
+#endif
             }
             break;
 
diff --git a/btif/src/btif_hh.c b/btif/src/btif_hh.c
old mode 100644
new mode 100755
index 3b9220a..db11f33
--- a/btif/src/btif_hh.c
+++ b/btif/src/btif_hh.c
@@ -43,6 +43,9 @@
 #include "gki.h"
 #include "l2c_api.h"
 #include "osi/include/log.h"
+#ifdef BLUETOOTH_RTK_COEX
+#include "btm_int.h"
+#endif
 
 #define BTIF_HH_APP_ID_MI       0x01
 #define BTIF_HH_APP_ID_KB       0x02
@@ -794,6 +797,23 @@ static void btif_hh_upstreams_evt(UINT16 event, char* p_param)
                     btif_hh_cb.p_curr_dev = btif_hh_find_connected_dev_by_handle(p_data->conn.handle);
                     BTA_HhGetDscpInfo(p_data->conn.handle);
                     p_dev->dev_status = BTHH_CONN_STATE_CONNECTED;
+#ifdef BLUETOOTH_RTK_COEX
+                    tBTM_SEC_DEV_REC *p_dev_rec = btm_find_dev (p_data->conn.bda);
+                    if ((p_dev_rec != NULL) &&((p_dev_rec->device_type &= BT_DEVICE_TYPE_BLE) == 0x02))
+                    {
+                        bt_property_t remote_ble_property;
+                        uint8_t  profile_map =0;
+                        btif_storage_get_remote_device_property((bt_bdaddr_t*)p_data->conn.bda, &remote_ble_property);
+                        if (check_cod((bt_bdaddr_t*)p_data->conn.bda, COD_HID_COMBO))
+                            profile_map |= 0x03;
+                        if (check_cod((bt_bdaddr_t*)p_data->conn.bda, COD_HID_KEYBOARD ))
+                            profile_map |= 0x02;
+                        if (check_cod((bt_bdaddr_t*)p_data->conn.bda, COD_HID_MAJOR))
+                            profile_map |= 0x01;
+                        p_dev_rec->profile_map = profile_map;
+                        rtk_parse_manager_get_interface()->rtk_add_le_profile(p_data->conn.bda,  p_dev->dev_handle, profile_map);
+                    }
+#endif
                     HAL_CBACK(bt_hh_callbacks, connection_state_cb,&(p_dev->bd_addr), p_dev->dev_status);
                 }
             }
diff --git a/btif/src/btif_media_task.c b/btif/src/btif_media_task.c
old mode 100644
new mode 100755
index b6f3f0c..eab359e
--- a/btif/src/btif_media_task.c
+++ b/btif/src/btif_media_task.c
@@ -79,6 +79,9 @@
 #include "stdio.h"
 #include <dlfcn.h>
 
+#ifdef BLUETOOTH_RTK_COEX
+#include "rtk_parse.h"
+#endif
 #if (BTA_AV_SINK_INCLUDED == TRUE)
 OI_CODEC_SBC_DECODER_CONTEXT context;
 OI_UINT32 contextData[CODEC_DATA_WORDS(2, SBC_CODEC_FAST_FILTER_BUFFERS)];
@@ -152,7 +155,11 @@ enum {
 #endif
 
 /* Middle quality quality setting @ 44.1 khz */
+#ifdef BLUETOOTH_RTK
+#define DEFAULT_SBC_BITRATE 229
+#else
 #define DEFAULT_SBC_BITRATE 328
+#endif
 
 #ifndef BTIF_A2DP_NON_EDR_MAX_RATE
 #define BTIF_A2DP_NON_EDR_MAX_RATE 229
@@ -1626,8 +1633,11 @@ static void btif_media_task_enc_init(BT_HDR *p_msg)
             btif_media_cb.encoder.s16AllocationMethod, btif_media_cb.encoder.u16BitRate,
             btif_media_cb.encoder.s16SamplingFreq);
 
-    /* Reset entirely the SBC encoder */
     SBC_Encoder_Init(&(btif_media_cb.encoder));
+#ifdef BLUETOOTH_RTK_COEX
+    rtk_parse_manager_get_interface()->rtk_add_bitpool_to_fw(btif_media_cb.encoder.s16BitPool);
+#endif
+    /* Reset entirely the SBC encoder */
     APPL_TRACE_DEBUG("btif_media_task_enc_init bit pool %d", btif_media_cb.encoder.s16BitPool);
 }
 
diff --git a/device/src/controller.c b/device/src/controller.c
old mode 100644
new mode 100755
index 1938f09..6ac0812
--- a/device/src/controller.c
+++ b/device/src/controller.c
@@ -34,7 +34,10 @@
 #include "stack/include/btm_ble_api.h"
 #include "btcore/include/version.h"
 
-const bt_event_mask_t BLE_EVENT_MASK = { "\x00\x00\x00\x00\x00\x00\x06\x7f" };
+#ifdef BLUETOOTH_RTK
+#include "osi/include/log.h"
+#endif
+const bt_event_mask_t BLE_EVENT_MASK = { "\x00\x00\x00\x00\x00\x00\x00\x3f" };
 
 #if (BLE_INCLUDED)
 const bt_event_mask_t CLASSIC_EVENT_MASK = { HCI_DUMO_EVENT_MASK_EXT };
@@ -160,6 +163,22 @@ static future_t *start_up(void) {
 
   // Done telling the controller about what page 0 features we support
   // Request the remaining feature pages
+#ifdef BLUETOOTH_RTK
+  if(HCI_LMP_EXTENDED_SUPPORTED(features_classic[0].as_array)) {
+    while (page_number < MAX_FEATURES_CLASSIC_PAGE_COUNT) {
+      response = AWAIT_COMMAND(packet_factory->make_read_local_extended_features(page_number));
+      packet_parser->parse_read_local_extended_features_response(
+        response,
+        &page_number,
+        &last_features_classic_page_index,
+        features_classic,
+        MAX_FEATURES_CLASSIC_PAGE_COUNT);
+      if(page_number == last_features_classic_page_index) //max page number == current page number,then break;
+        break;
+      page_number++; //otherwise read next page
+    }
+  }
+#else
   while (page_number <= last_features_classic_page_index &&
          page_number < MAX_FEATURES_CLASSIC_PAGE_COUNT) {
     response = AWAIT_COMMAND(packet_factory->make_read_local_extended_features(page_number));
@@ -174,6 +193,7 @@ static future_t *start_up(void) {
     page_number++;
   }
 
+#endif
 #if (SC_MODE_INCLUDED == TRUE)
   secure_connections_supported = HCI_SC_CTRLR_SUPPORTED(features_classic[2].as_array);
   if (secure_connections_supported) {
@@ -292,14 +312,32 @@ static uint8_t get_last_features_classic_index(void) {
 
 static const bt_device_features_t *get_features_ble(void) {
   assert(readable);
-  assert(ble_supported);
-  return &features_ble;
+#ifdef BLUETOOTH_RTK
+        if(ble_supported){
+          assert(ble_supported);
+          return &features_ble;
+        } else {
+          return NULL;
+        }
+#else
+        assert(ble_supported);
+        return &features_ble;
+#endif
 }
 
 static const uint8_t *get_ble_supported_states(void) {
   assert(readable);
-  assert(ble_supported);
-  return ble_supported_states;
+#ifdef BLUETOOTH_RTK
+      if(ble_supported){
+        assert(ble_supported);
+        return ble_supported_states;
+      } else {
+        return NULL;
+      }
+#else
+      assert(ble_supported);
+      return ble_supported_states;
+#endif
 }
 
 static bool supports_simple_pairing(void) {
@@ -372,8 +410,18 @@ static uint16_t get_acl_data_size_classic(void) {
 
 static uint16_t get_acl_data_size_ble(void) {
   assert(readable);
-  assert(ble_supported);
-  return acl_data_size_ble;
+#ifdef BLUETOOTH_RTK
+    if(ble_supported){
+    assert(ble_supported);
+    return acl_data_size_ble;
+    } else {
+      return 0;
+    }
+#else
+    assert(ble_supported);
+    return acl_data_size_ble;
+#endif
+
 }
 
 static uint16_t get_acl_packet_size_classic(void) {
@@ -388,8 +436,17 @@ static uint16_t get_acl_packet_size_ble(void) {
 
 static uint16_t get_ble_suggested_default_data_length(void) {
   assert(readable);
+#ifdef BLUETOOTH_RTK
+  if(ble_supported){
+    assert(ble_supported);
+    return ble_suggested_default_data_length;
+  } else {
+    return 0;
+  }
+#else
   assert(ble_supported);
   return ble_suggested_default_data_length;
+#endif
 }
 
 static uint16_t get_acl_buffer_count_classic(void) {
@@ -405,20 +462,42 @@ static uint8_t get_acl_buffer_count_ble(void) {
 
 static uint8_t get_ble_white_list_size(void) {
   assert(readable);
+#ifdef BLUETOOTH_RTK
+  if(ble_supported){
+    assert(ble_supported);
+    return ble_white_list_size;
+  } else {
+    return 0;
+  }
+#else
   assert(ble_supported);
   return ble_white_list_size;
+#endif
 }
 
 static uint8_t get_ble_resolving_list_max_size(void) {
   assert(readable);
+#ifdef BLUETOOTH_RTK
+  if(ble_supported){
+    assert(ble_supported);
+    return ble_resolving_list_max_size;
+  } else {
+    return 0;
+  }
+#else
   assert(ble_supported);
   return ble_resolving_list_max_size;
+#endif
 }
 
 static void set_ble_resolving_list_max_size(int resolving_list_max_size) {
   assert(readable);
+#ifdef BLUETOOTH_RTK
+  ble_resolving_list_max_size = resolving_list_max_size;
+#else
   assert(ble_supported);
   ble_resolving_list_max_size = resolving_list_max_size;
+#endif
 }
 
 static const controller_t interface = {
diff --git a/hci/Android.mk b/hci/Android.mk
old mode 100644
new mode 100755
index af87285..e5d2970
--- a/hci/Android.mk
+++ b/hci/Android.mk
@@ -23,6 +23,18 @@ ifeq ($(BLUETOOTH_HCI_USE_MCT),true)
 LOCAL_CFLAGS += -DHCI_USE_MCT
 endif
 
+ifeq ($(BOARD_HAVE_BLUETOOTH_RTK),true)
+LOCAL_CFLAGS += -DBLUETOOTH_RTK
+LOCAL_SRC_FILES += \
+    src/bt_list.c \
+    src/bt_skbuff.c \
+    src/hci_h5.c
+endif
+
+ifeq ($(BOARD_HAVE_BLUETOOTH_RTK_COEX),true)
+LOCAL_SRC_FILES += \
+    src/rtk_parse.c
+endif
 LOCAL_CFLAGS += -std=c99 $(bdroid_CFLAGS)
 
 LOCAL_C_INCLUDES += \
diff --git a/hci/include/bt_list.h b/hci/include/bt_list.h
new file mode 100755
index 0000000..cf070d5
--- /dev/null
+++ b/hci/include/bt_list.h
@@ -0,0 +1,168 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Realtek Corporation.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+*
+*	Module Name:
+*	    bt_list.h
+*
+*	Abstract:
+*	    To implement list data structure
+*
+*	Major Change History:
+*	      When             Who         What
+*	    --------------------------------------------------------------
+*	    2010-06-04         W.Bi       Created
+*
+*	Notes:
+*
+******************************************************************************/
+
+#ifndef BT_LIST_H
+#define BT_LIST_H
+
+
+
+
+
+/**
+\file  bt_list.h
+\brief  Implement bluetooth list data structure. Has referred to Linux list implementation
+          You could add your new list manipulation here.
+*/
+
+
+/**
+ List entry structure, could be header or node.
+
+                  Prev<-----Header---->Next
+
+Every List has an additional header, and list tail will be list header's previous node.
+You can use list to form a queue or a stack data structure
+queue:
+    ListAddToTail----->LIST_FOR_EACH iterate--->manipulate on the list entry
+Stack:
+    ListAddToHead--- >LIST_FOR_EACH iterate--->manipulate on the list entry
+*/
+
+///RT list structure definition
+typedef struct _RT_LIST_ENTRY {
+    struct _RT_LIST_ENTRY *Next;   ///< Entry's next element
+    struct _RT_LIST_ENTRY *Prev;   ///< Entry's previous element
+} RT_LIST_ENTRY, *PRT_LIST_ENTRY;
+
+///List head would be another name of list entry, and it points to the list header
+typedef RT_LIST_ENTRY       RT_LIST_HEAD, *PRT_LIST_HEAD;
+
+/*----------------------------------------------------------------------------------
+    EXTERNAL FUNCTION
+----------------------------------------------------------------------------------*/
+
+///Initialize a list with its header
+void ListInitializeHeader(PRT_LIST_HEAD ListHead);
+
+/**
+    Add a new entry to the list.
+    Insert a new entry after the specified head. This is good for implementing stacks.
+    \param [IN]        ListNew     <RT_LIST_ENTRY>                 : new entry to be added
+    \param [IN OUT] ListHead    <RT_LIST_ENTRY>                 : List header after which to add new entry
+*/
+void ListAddToHead(PRT_LIST_ENTRY ListNew, PRT_LIST_HEAD ListHead);
+
+/**
+    Add a new entry to the list.
+    Insert a new entry before the specified head. This is good for implementing queues.
+    \param [IN]        ListNew     <RT_LIST_ENTRY>                 : new entry to be added
+    \param [IN OUT] ListHead    <RT_LIST_ENTRY>                 : List header before which to add new entry
+*/
+void ListAddToTail(PRT_LIST_ENTRY ListNew, PRT_LIST_HEAD ListHead);
+
+/**
+    Get entry in the head of the list
+     \param [IN ] ListHead    <RT_LIST_ENTRY>                 : List header
+     \return entry in the head , otherwise NULL
+*/
+RT_LIST_ENTRY* ListGetTop(PRT_LIST_HEAD ListHead);
+
+/**
+    Get entry in the tail of the list
+     \param [IN ] ListHead    <RT_LIST_ENTRY>                 : List header
+     \return entry in the tail , otherwise NULL
+*/
+RT_LIST_ENTRY*
+ListGetTail(
+    PRT_LIST_HEAD ListHead
+);
+
+/**
+    Delete entry from the list
+    Note: ListIsEmpty() on this list entry would not return true, since its state is undefined
+    \param [IN] ListToDelete     <RT_LIST_ENTRY>                 : list entry to be deleted
+*/
+void ListDeleteNode(PRT_LIST_ENTRY ListToDelete);
+
+/**
+    Tell whether the list is empty
+    \param [IN] ListHead          <RT_LIST_ENTRY>                 : List header of which to be test
+*/
+unsigned char ListIsEmpty(PRT_LIST_HEAD ListHead);
+
+//EXTERN void ListEmpty(PRT_LIST_HEAD ListHead);
+
+void
+    ListAdd(
+    PRT_LIST_ENTRY New,
+    PRT_LIST_ENTRY Prev,
+    PRT_LIST_ENTRY Next
+    );
+
+/*----------------------------------------------------------------------------------
+    MACRO
+----------------------------------------------------------------------------------*/
+
+/**
+    Macros to iterate over the list.
+    \param _Iter          : struct PRT_LIST_ENTRY type iterator to use as a loop cursor
+    \param _ListHead   : List head of which to be iterated
+*/
+#define LIST_FOR_EACH(_Iter, _ListHead) \
+        for ((_Iter) = (_ListHead)->Next; (_Iter) != (_ListHead); (_Iter) = (_Iter)->Next)
+
+/**
+    Macros to iterate over the list safely against removal of list entry.
+    If you would delete any list entry from the list while iterating the list, should use this macro
+    \param _Iter          : Struct PRT_LIST_ENTRY type iterator to use as a loop cursor
+    \param _Temp       : Another Struct PRT_LIST_ENTRY type to use as a temporary storage
+    \param _ListHead   : List head of which to be iterated
+*/
+#define LIST_FOR_EACH_SAFELY(_Iter, _Temp, _ListHead) \
+        for ((_Iter) = (_ListHead)->Next, (_Temp) = (_Iter)->Next; (_Iter) != (_ListHead);  \
+               (_Iter) = (_Temp), (_Temp) = (_Iter)->Next)
+
+/**
+    Macros to get the struct pointer of this list entry
+    You could make every RT_LIST_ENTRY at the first place of your structure to avoid the macro, which will be dangerouse.
+    Copy from winnt.h.
+    BUG:if offset of field in type larger than 32 bit interger, which is not likely to happen, it will error
+    \param _Ptr               : Struct RT_LIST_ENTRY type pointer
+    \param _Type            : The type of structure in which the RT_LIST_ENTRY embedded in
+    \param _Field            : the name of the RT_LIST_ENTRY within the struct
+*/
+#define LIST_ENTRY(_Ptr, _Type, _Field) ((_Type *)((char *)(_Ptr)-(unsigned long)(&((_Type *)0)->_Field)))
+
+
+#endif /*BT_LIST_H*/
diff --git a/hci/include/bt_skbuff.h b/hci/include/bt_skbuff.h
new file mode 100755
index 0000000..b6bf55f
--- /dev/null
+++ b/hci/include/bt_skbuff.h
@@ -0,0 +1,362 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Realtek Corporation.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+*
+*	Module Name:
+*	    bt_skbuff.h
+*
+*	Abstract:
+*	    Data buffer managerment through whole bluetooth stack.
+*
+*	Major Change History:
+*	      When             Who       What
+*	    --------------------------------------------------------------
+*	    2010-06-11       W.Bi     Created.
+*
+*	Notes:
+*	      To reduce memory copy when pass data buffer to other layers,
+*       RTK_BUFFER is designed referring to linux socket buffer.
+*       But I still wonder its effect, since RTK_BUFFER is much bigger
+*       than original data buffer.RTK_BUFFER will reduce its member if
+*       it would not reach what i had expected.
+*
+******************************************************************************/
+
+
+#ifndef BT_SKBUFF_H
+#define BT_SKBUFF_H
+#include "bt_list.h"
+
+#ifndef EXTERN
+#define EXTERN
+#endif
+
+#ifndef IN
+#define IN
+#endif
+
+#ifndef OUT
+#define OUT
+#endif
+/*----------------------------------------------------------------------------------
+    CONSTANT DEFINITION
+----------------------------------------------------------------------------------*/
+#define RTK_CONTEXT_SIZE 12
+
+#define RTB_QUEUE_ID_LENGTH          64
+
+/*----------------------------------------------------------------------------------
+    STRUCTURE DEFINITION
+----------------------------------------------------------------------------------*/
+/**
+    Rtk buffer definition
+      Head -->|<---Data--->|<-----Length------>| <---End
+                     _________________________________
+                    |_____________|___________________|
+                    |<-headroom->|<--RealDataBuffer-->|
+
+    Compared to socket buffer, there exists no tail and end pointer and tailroom as tail is rarely used in bluetooth stack
+    \param List             : List structure used to list same type rtk buffer and manipulate rtk buffer like list.
+    \param Head           : Pointer to truely allocated data buffer. It point to the headroom
+    \param Data           : Pointer to real data buffer.
+    \param Length        : currently data length
+    \param HeadRoom  : Record initialize headroom size.
+    \param RefCount    : Reference count. zero means able to be freed, otherwise somebody is handling it.
+    \param Priv            : Reserved for multi-device support. Record Hci pointer which will handles this packet
+    \param Contest      : Control buffer, put private variables here.
+*/
+typedef struct _RTK_BUFFER
+{
+    RT_LIST_ENTRY List;
+    uint8_t *Head;
+    uint8_t *Data;
+    uint8_t *Tail;
+    uint8_t *End;
+    uint32_t Length;
+    uint32_t HeadRoom;
+//    RT_U16 TailRoom;
+    signed char   RefCount;
+
+    void* Priv;
+    uint8_t Context[RTK_CONTEXT_SIZE];
+}RTK_BUFFER, *PRTK_BUFFER;
+
+/**
+    RTK_BUFFER Control Buffer Context
+    \param  PacketType      : HCI data types, Command/Acl/...
+    \param  LastFrag          : Is Current Acl buffer the last fragment.(0 for no, 1 for yes)
+    \param  TxSeq             : Current packet tx sequence
+    \param  Retries            : Current packet retransmission times
+    \param  Sar                 : L2cap control field segmentation and reassembly bits
+*/
+struct BT_RTB_CONTEXT{
+    uint8_t   PacketType;
+    uint16_t Handle;
+};
+
+///definition to get rtk_buffer's control buffer context pointer
+#define BT_CONTEXT(_Rtb) ((struct BT_RTB_CONTEXT *)((_Rtb)->Context))
+
+/**
+    Since RTBs are always used into/from list, so abstract this struct and provide APIs to easy process on RTBs
+*/
+typedef struct _RTB_QUEUE_HEAD  RTB_QUEUE_HEAD;
+/*----------------------------------------------------------------------------------
+    EXTERNAL FUNCTION
+----------------------------------------------------------------------------------*/
+/**
+    Allocate a RTK_BUFFER with specified data length and reserved headroom.
+    If caller does not know actual headroom to reserve for further usage, specify it to zero to use default value.
+    \param [IN]     Length            <uint32_t>        : current data buffer length to allcated
+    \param [IN]     HeadRoom     <uint32_t>         : if caller knows reserved head space, set it; otherwise set 0 to use default value
+    \return pointer to RTK_BUFFER if succeed, null otherwise
+*/
+RTK_BUFFER*
+RtbAllocate(
+    IN uint32_t Length,
+    IN uint32_t HeadRoom
+    );
+
+/**
+    Free specified Rtk_buffer
+    \param [IN]     RtkBuffer            <RTK_BUFFER*>        : buffer to free
+*/
+void
+RtbFree(
+    IN RTK_BUFFER* RtkBuffer
+    );
+
+/**
+    increament reference count
+*/
+void
+RtbIncreaseRefCount(
+    IN RTK_BUFFER* RtkBuffer
+);
+
+/**
+    Recycle a rtk_buffer after its usage if specified rtb could
+    if rtb total length is not smaller than specified rtbsize to be recycled for, it will succeeded recycling
+    \param [IN OUT]     RtkBuffer            <RTK_BUFFER*>        : buffer to recycle
+    \param [IN]             RtbSize              <uint32_t>                 : size of buffer to be recycled for
+*/
+/*
+BOOLEAN
+RtbCheckRecycle(
+    IN OUT RTK_BUFFER* RtkBuffer,
+    IN uint32_t   RtbSize
+    );
+*/
+/**
+    Add a specified length protocal header to the start of data buffer hold by specified rtk_buffer.
+    This function extends used data area of the buffer at the buffer start.
+    \param [IN OUT]     RtkBuffer            <RTK_BUFFER*>        : data buffer to add
+    \param [IN]            Length                <uint32_t>                 : header length
+    \return  Pointer to the first byte of the extra data is returned
+*/
+uint8_t*
+RtbAddHead(
+    IN OUT RTK_BUFFER* RtkBuffer,
+    IN uint32_t                 Length
+    );
+
+/**
+    Remove a specified length data from the start of data buffer hold by specified rtk_buffer.
+    This function returns the memory to the headroom.
+    \param [IN OUT]     RtkBuffer            <RTK_BUFFER*>        : data buffer to remove
+    \param [IN]            Length                <uint32_t>                 : header length
+    \return  Pointer to the next data in the buffer is returned, usually useless
+*/
+unsigned char
+RtbRemoveHead(
+    IN OUT RTK_BUFFER* RtkBuffer,
+    IN uint32_t                 Length
+    );
+
+/**
+    Add a specified length protocal header to the end of data buffer hold by specified rtk_buffer.
+    This function extends used data area of the buffer at the buffer end.
+    \param [IN OUT]     RtkBuffer            <RTK_BUFFER*>        : data buffer to add
+    \param [IN]            Length                <uint32_t>                 : header length
+    \return  Pointer to the first byte of the extra data is returned
+*/
+EXTERN uint8_t*
+RtbAddTail(
+    IN OUT RTK_BUFFER* RtkBuffer,
+    IN uint32_t                 Length
+    );
+
+/**
+    Remove a specified length data from the end of data buffer hold by specified rtk_buffer.
+*/
+EXTERN unsigned char
+RtbRemoveTail(
+    IN OUT RTK_BUFFER * RtkBuffer,
+    IN     uint32_t       Length
+);
+
+/**
+    Initialize a rtb queue.
+    \return  Initilized rtb queue if succeed, otherwise NULL
+*/
+EXTERN RTB_QUEUE_HEAD*
+RtbQueueInit(
+    );
+
+/**
+    Free a rtb queue.
+    \param [IN]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+*/
+EXTERN void
+RtbQueueFree(
+    RTB_QUEUE_HEAD* RtkQueueHead
+    );
+/**
+    Queue specified RtkBuffer into a RtkQueue at list tail.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \param [IN]            RtkBuffer                <RTK_BUFFER*>                 : Rtk buffer to add
+*/
+EXTERN void
+RtbQueueTail(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 RtkBuffer
+    );
+
+/**
+    Queue specified RtkBuffer into a RtkQueue at list Head.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \param [IN]            RtkBuffer                <RTK_BUFFER*>                 : Rtk buffer to add
+*/
+EXTERN void
+RtbQueueHead(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 RtkBuffer
+    );
+
+/**
+    Remove a RtkBuffer from specified rtkqueue at list tail.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \return    removed rtkbuffer if succeed, otherwise NULL
+*/
+EXTERN RTK_BUFFER*
+RtbDequeueTail(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead
+    );
+
+/**
+    Remove a RtkBuffer from specified rtkqueue at list head.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \return    removed rtkbuffer if succeed, otherwise NULL
+*/
+EXTERN RTK_BUFFER*
+RtbDequeueHead(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead
+    );
+
+/**
+    Get current rtb queue's length.
+    \param [IN]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \return    current queue's length
+*/
+EXTERN signed long
+RtbGetQueueLen(
+    IN RTB_QUEUE_HEAD* RtkQueueHead
+    );
+
+/**
+    Empty the rtkqueue.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+*/
+EXTERN void
+RtbEmptyQueue(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead
+    );
+
+/**
+    Get the RtkBuffer which is the head of a RtkQueue
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \return head of the RtkQueue , otherwise NULL
+*/
+EXTERN RTK_BUFFER*
+RtbTopQueue(
+    IN RTB_QUEUE_HEAD* RtkQueueHead
+);
+
+/**
+    Insert new Rtkbuffer in the old buffer
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \param [IN]            OldRtkBuffer                <RTK_BUFFER*>                 : old rtk buffer
+    \param [IN]            NewRtkBuffer                <RTK_BUFFER*>                 : Rtk buffer to add
+*/
+EXTERN void
+RtbInsertBefore(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER* pOldRtkBuffer,
+    IN RTK_BUFFER* pNewRtkBuffer
+);
+
+/**
+    check whether the buffer is the last node in the queue
+*/
+EXTERN unsigned char
+RtbNodeIsLast(
+    IN RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 pRtkBuffer
+);
+
+/**
+    get the next buffer node after the specified buffer in the queue
+    if the specified buffer is the last node in the queue , return NULL
+    \param [IN]     RtkBuffer        <RTK_BUFFER*>        : Rtk Queue
+    \param [IN]     RtkBuffer        <RTK_BUFFER*>        : Rtk buffer
+    \return node after the specified buffer
+*/
+EXTERN RTK_BUFFER*
+RtbQueueNextNode(
+    IN RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 pRtkBuffer
+);
+
+/**
+    check whether queue is empty
+*/
+/*EXTERN BOOLEAN
+RtbQueueIsEmpty(
+   IN RTB_QUEUE_HEAD* RtkQueueHead
+);
+*/
+
+//annie_tmp
+EXTERN unsigned char
+RtbCheckQueueLen(
+   IN RTB_QUEUE_HEAD* RtkQueueHead,
+   IN uint8_t Len
+);
+
+EXTERN void
+RtbRemoveNode(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*         RtkBuffer
+);
+
+EXTERN RTK_BUFFER*
+    RtbCloneBuffer(
+    IN RTK_BUFFER* pDataBuffer
+    );
+
+#endif /*BT_SKBUFF_H*/
diff --git a/hci/include/bt_vendor_lib.h b/hci/include/bt_vendor_lib.h
old mode 100644
new mode 100755
index 65d448b..e816f97
--- a/hci/include/bt_vendor_lib.h
+++ b/hci/include/bt_vendor_lib.h
@@ -336,8 +336,12 @@ typedef struct {
      * Caller will open the interface and pass in the callback routines
      * to the implemenation of this interface.
      */
-    int   (*init)(const bt_vendor_callbacks_t* p_cb, unsigned char *local_bdaddr);
 
+#ifdef BLUETOOTH_RTK
+    int (*init)(const bt_vendor_callbacks_t* p_cb, unsigned char *local_bdaddr, char *bt_device_node);
+#else
+    int (*init)(const bt_vendor_callbacks_t* p_cb, unsigned char *local_bdaddr);
+#endif
     /**  Vendor specific operations */
     int (*op)(bt_vendor_opcode_t opcode, void *param);
 
diff --git a/hci/include/hci_hal.h b/hci/include/hci_hal.h
old mode 100644
new mode 100755
index b0b3c67..a3bcc69
--- a/hci/include/hci_hal.h
+++ b/hci/include/hci_hal.h
@@ -28,7 +28,12 @@ typedef enum {
   DATA_TYPE_COMMAND = 1,
   DATA_TYPE_ACL     = 2,
   DATA_TYPE_SCO     = 3,
+#ifdef BLUETOOTH_RTK
+  DATA_TYPE_EVENT   = 4,
+  DATA_TYPE_H5  =  5
+#else
   DATA_TYPE_EVENT   = 4
+#endif
 } serial_data_type_t;
 
 typedef void (*data_ready_cb)(serial_data_type_t type);
diff --git a/hci/include/hci_layer.h b/hci/include/hci_layer.h
old mode 100644
new mode 100755
index bdc4681..3470229
--- a/hci/include/hci_layer.h
+++ b/hci/include/hci_layer.h
@@ -27,6 +27,9 @@
 #include "future.h"
 #include "osi.h"
 
+#ifdef BLUETOOTH_RTK
+#include "bt_hci_bdroid.h"
+#endif
 static const char HCI_MODULE[] = "hci_module";
 
 ///// LEGACY DEFINITIONS /////
@@ -60,7 +63,14 @@ typedef struct packet_fragmenter_t packet_fragmenter_t;
 typedef struct vendor_t vendor_t;
 typedef struct low_power_manager_t low_power_manager_t;
 
+#ifdef BLUETOOTH_RTK
+/* BD Address */
+typedef struct {
+    uint8_t b[6];
+} __packed bdaddr_t;
+#else
 typedef unsigned char * bdaddr_t;
+#endif
 typedef uint16_t command_opcode_t;
 
 typedef enum {
@@ -73,6 +83,60 @@ typedef enum {
 typedef void (*command_complete_cb)(BT_HDR *response, void *context);
 typedef void (*command_status_cb)(uint8_t status, BT_HDR *command, void *context);
 
+#ifdef BLUETOOTH_RTK
+typedef void (* p_callback)(void *p_mem);
+
+extern char bt_hci_device_node[BT_HCI_DEVICE_NODE_MAX_LEN];
+
+extern bool bluetooth_rtk_h5_flag ;//Default Usb H4 Interfcace ,if ture Uart H5 Interface
+
+/******************************************************************************
+**  Constants & Macros
+******************************************************************************/
+
+/******************************************************************************
+**  Type definitions
+******************************************************************************/
+
+/** Prototypes for HCI Service interface functions **/
+/* Callback function for the returned event of internally issued command */
+typedef void (*tINT_CMD_CBACK)(void *p_mem);
+
+/* Initialize transport's control block */
+typedef void (*tHCI_INIT)(tINT_CMD_CBACK p_cback, const allocator_t *bufalloc);
+
+/* Do transport's control block clean-up */
+typedef void (*tHCI_CLEANUP)(void);
+
+/* Send HCI command/data to the transport */
+typedef void (*tHCI_SEND)(HC_BT_HDR *p_msg);
+
+/* Handler for HCI upstream path */
+typedef uint16_t (*tHCI_RCV)(uint16_t *byte);
+
+/* Handler for sending HCI command from the local module */
+typedef uint8_t (*tHCI_SEND_INT)(uint16_t opcode, HC_BT_HDR *p_buf, tINT_CMD_CBACK p_cback);
+
+/* Handler for getting acl data length */
+typedef void (*tHCI_ACL_DATA_LEN_HDLR)(void);
+
+/******************************************************************************
+**  Extern variables and functions
+******************************************************************************/
+typedef struct {
+    tHCI_INIT init;
+    tHCI_CLEANUP cleanup;
+    tHCI_SEND send;
+    tHCI_SEND_INT send_int_cmd;
+    tHCI_ACL_DATA_LEN_HDLR get_acl_max_len;
+#ifdef HCI_USE_MCT
+    tHCI_RCV evt_rcv;
+    tHCI_RCV acl_rcv;
+#else
+    tHCI_RCV rcv;
+#endif
+} tHCI_IF;
+#endif
 typedef struct hci_t {
   // Send a low power command, if supported and the low power manager is enabled.
   void (*send_low_power_command)(low_power_command_t command);
@@ -85,6 +149,14 @@ typedef struct hci_t {
 
   // Set the queue to receive ACL data in
   void (*set_data_queue)(fixed_queue_t *queue);
+#ifdef BLUETOOTH_RTK
+  // Send HCI INT command through the HCI UART layer
+  void (*transmit_int_command)(
+      uint16_t opcode,
+      void *buffer,
+      p_callback callback
+  );
+#endif
 
   // Send a command through the HCI layer
   void (*transmit_command)(
diff --git a/hci/include/packet_fragmenter.h b/hci/include/packet_fragmenter.h
old mode 100644
new mode 100755
index c7f643e..8f2d742
--- a/hci/include/packet_fragmenter.h
+++ b/hci/include/packet_fragmenter.h
@@ -25,6 +25,9 @@
 typedef void (*transmit_finished_cb)(BT_HDR *packet, bool all_fragments_sent);
 typedef void (*packet_reassembled_cb)(BT_HDR *packet);
 typedef void (*packet_fragmented_cb)(BT_HDR *packet, bool send_transmit_finished);
+#ifdef BLUETOOTH_RTK
+typedef void (*filter_incoming_event_cb)(BT_HDR *packet);
+#endif
 
 typedef struct {
   // Called for every packet fragment.
@@ -36,6 +39,10 @@ typedef struct {
   // Called when the fragmenter finishes sending all requested fragments,
   // but the packet has not been entirely sent.
   transmit_finished_cb transmit_finished;
+#ifdef BLUETOOTH_RTK
+  //handle the callback of cmd comp event and cmd status event
+  filter_incoming_event_cb filter_incoming_event;
+#endif
 } packet_fragmenter_callbacks_t;
 
 typedef struct packet_fragmenter_t {
diff --git a/hci/include/rtk_parse.h b/hci/include/rtk_parse.h
new file mode 100755
index 0000000..5a03655
--- /dev/null
+++ b/hci/include/rtk_parse.h
@@ -0,0 +1,96 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Realtek Corporation.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+*
+*	Module Name:
+*	    rtk_parse.h
+*
+*	Abstract:
+*	    Contains wifi-bt coex functions implemented by bluedroid stack
+*
+*	Major Change History:
+*	      When             Who       What
+*	    ---------------------------------------------------------------
+*	    2015-12-15      lamparten   modified
+*	    2014-10-23       kyle_xu    modified
+*
+*	Notes:
+*         This is designed for wifi-bt Coex in Android 6.0.
+*
+******************************************************************************/
+
+
+#ifndef RTK_PARSE_H
+#define RTK_PARSE_H
+
+#pragma once
+
+#include <stdlib.h>
+#include "hci_layer.h"
+#include "bt_types.h"
+#include "buffer_allocator.h"
+#include <string.h>
+#include <string.h>
+#include <strings.h>
+/******************************************************************************
+**  Constants & Macros
+******************************************************************************/
+#define HOST_PROFILE_INFO
+
+/******************************************************************************
+**  Type definitions
+******************************************************************************/
+typedef unsigned char   UINT8;
+#define BD_ADDR_LEN     6                   /* Device address length */
+typedef UINT8 BD_ADDR[BD_ADDR_LEN];         /* Device address */
+typedef void* TRANSAC;
+
+
+/******************************************************************************
+**  Extern variables and functions
+******************************************************************************/
+extern uint8_t coex_log_enable;
+
+/******************************************************************************
+**  Functions
+******************************************************************************/
+typedef struct rtk_parse_manager_t {
+
+    void (*rtk_parse_internal_event_intercept)(uint8_t *p);
+
+    void (*rtk_parse_l2cap_data)(uint8_t *p, uint8_t direction);
+
+    void (*rtk_parse_init)(hci_t *hci_if);
+
+    void (*rtk_parse_cleanup)();
+
+    void (*rtk_parse_command)(uint8_t *p);
+
+    void (*rtk_add_le_profile)(BD_ADDR bdaddr, uint16_t handle, uint8_t profile_map);
+
+    void (*rtk_delete_le_profile)(BD_ADDR bdaddr, uint16_t handle, uint8_t profile_map);
+
+    void (*rtk_add_le_data_count)(uint8_t data_type);
+
+    void (*rtk_add_bitpool_to_fw)(uint8_t bitpool);
+
+}rtk_parse_manager_t;
+
+const rtk_parse_manager_t *rtk_parse_manager_get_interface();
+
+#endif /*RTK_PARSE_H*/
diff --git a/hci/src/bt_list.c b/hci/src/bt_list.c
new file mode 100755
index 0000000..77227b6
--- /dev/null
+++ b/hci/src/bt_list.c
@@ -0,0 +1,144 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Realtek Corporation.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+*
+*	Module Name:
+*	    bt_list.c
+*
+*	Abstract:
+*	    To implement list data structure
+*
+*	Major Change History:
+*	      When             Who         What
+*    	--------------------------------------------------------------
+*	    2010-06-04         W.Bi       Created
+*
+*	Notes:
+*
+******************************************************************************/
+#include "bt_list.h"
+
+//****************************************************************************
+// Structure
+//****************************************************************************
+
+
+//****************************************************************************
+// FUNCTION
+//****************************************************************************
+//Initialize a list with its header
+void ListInitializeHeader(PRT_LIST_HEAD ListHead)
+{
+    ListHead->Next = ListHead;
+    ListHead->Prev = ListHead;
+}
+
+/**
+    Tell whether the list is empty
+    \param [IN] ListHead          <RT_LIST_ENTRY>                 : List header of which to be test
+*/
+unsigned char ListIsEmpty(PRT_LIST_HEAD ListHead)
+{
+    return ListHead->Next == ListHead;
+}
+
+/*
+    Insert a new entry between two known consecutive entries.
+    This is only for internal list manipulation where we know the prev&next entries already
+    @New : New element to be added
+    @Prev: previous element in the list
+    @Next: Next element in the list
+*/
+void
+    ListAdd(
+    PRT_LIST_ENTRY New,
+    PRT_LIST_ENTRY Prev,
+    PRT_LIST_ENTRY Next
+    )
+{
+    Next->Prev = New;
+    New->Next = Next;
+    New->Prev = Prev;
+    Prev->Next = New;
+}
+/**
+    Add a new entry to the list.
+    Insert a new entry after the specified head. This is good for implementing stacks.
+    \param [IN] ListNew            <RT_LIST_ENTRY>                 : new entry to be added
+    \param [IN OUT] ListHead    <RT_LIST_ENTRY>                 : List header after which to add new entry
+*/
+void
+ListAddToHead(
+    PRT_LIST_ENTRY ListNew,
+    PRT_LIST_HEAD ListHead
+    )
+{
+    ListAdd(ListNew, ListHead, ListHead->Next);
+}
+
+/**
+    Add a new entry to the list.
+    Insert a new entry before the specified head. This is good for implementing queues.
+    \param [IN] ListNew            <RT_LIST_ENTRY>                 : new entry to be added
+    \param [IN OUT] ListHead    <RT_LIST_ENTRY>                 : List header before which to add new entry
+*/
+void
+ListAddToTail(
+    PRT_LIST_ENTRY ListNew,
+    PRT_LIST_HEAD ListHead
+    )
+{
+    ListAdd(ListNew, ListHead->Prev, ListHead);
+}
+
+RT_LIST_ENTRY*
+ListGetTop(
+    PRT_LIST_HEAD ListHead
+)
+{
+
+    if (ListIsEmpty(ListHead))
+        return 0;
+
+    return ListHead->Next;
+}
+
+RT_LIST_ENTRY*
+ListGetTail(
+    PRT_LIST_HEAD ListHead
+)
+{
+    if (ListIsEmpty(ListHead))
+        return 0;
+
+    return ListHead->Prev;
+}
+/**
+    Delete entry from the list
+    Note: ListIsEmpty() on this list entry would not return true, since its state is undefined
+    \param [IN] ListToDelete     <RT_LIST_ENTRY>                 : list entry to be deleted
+*/
+void ListDeleteNode(PRT_LIST_ENTRY ListToDelete)
+{
+//    if (ListToDelete->Next != NULL && ListToDelete->Prev != NULL)
+    {
+        ListToDelete->Next->Prev = ListToDelete->Prev;
+        ListToDelete->Prev->Next = ListToDelete->Next;
+        ListToDelete->Next = ListToDelete->Prev = ListToDelete;
+    }
+}
diff --git a/hci/src/bt_skbuff.c b/hci/src/bt_skbuff.c
new file mode 100755
index 0000000..47d4438
--- /dev/null
+++ b/hci/src/bt_skbuff.c
@@ -0,0 +1,573 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Realtek Corporation.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+*
+*	Module Name:
+*	    bt_skbuff.c
+*
+*	Abstract:
+*	    Data buffer managerment through whole bluetooth stack.
+*
+*	Major Change History:
+*	      When             Who       What
+*	    --------------------------------------------------------------
+*	    2010-06-11       W.Bi    Created.
+*
+*	Notes:
+*		  To reduce memory copy when pass data buffer to other layers,
+*      	RTK_BUFFER is designed referring to linux socket buffer.
+*       But I still wonder its effect, since RTK_BUFFER is much bigger
+*       than original data buffer.RTK_BUFFER will reduce its member if
+*       it would not reach what i had expected.
+*
+******************************************************************************/
+
+
+#define LOG_TAG "bt_h5"
+#undef NDEBUG
+#include <utils/Log.h>
+#include <stdlib.h>
+#include <fcntl.h>
+
+#include <termios.h>
+#include <errno.h>
+#include <pthread.h>
+
+
+#include "bt_list.h"
+#include "bt_skbuff.h"
+#include "bt_types.h"
+#include "string.h"
+#define IN
+#define OUT
+
+//****************************************************************************
+// CONSTANT DEFINITION
+//****************************************************************************
+///default header size
+///l2cap header(8)+hci acl(4)
+#define DEFAULT_HEADER_SIZE    (8+4)
+
+//RTK_BUFFER data buffer alignment
+#define RTB_ALIGN   4
+
+//do alignment with RTB_ALIGN
+#define RTB_DATA_ALIGN(_Length)     ((_Length + (RTB_ALIGN - 1)) & (~(RTB_ALIGN - 1)))
+
+//****************************************************************************
+// STRUCTURE DEFINITION
+//****************************************************************************
+typedef struct _RTB_QUEUE_HEAD{
+    RT_LIST_HEAD List;
+    uint32_t  QueueLen;
+    pthread_mutex_t Lock;
+    uint8_t   Id[RTB_QUEUE_ID_LENGTH];
+}RTB_QUEUE_HEAD, *PRTB_QUEUE_HEAD;
+
+//****************************************************************************
+// FUNCTION
+//****************************************************************************
+/**
+    check whether queue is empty
+    \return :   FALSE   Queue is not empty
+        TRU Queue is empty
+*/
+unsigned char
+RtbQueueIsEmpty(
+   IN RTB_QUEUE_HEAD* RtkQueueHead
+)
+{
+    //return ListIsEmpty(&RtkQueueHead->List);
+    return  RtkQueueHead->QueueLen > 0 ? FALSE : TRUE;
+}
+
+/**
+    Allocate a RTK_BUFFER with specified data length and reserved headroom.
+    If caller does not know actual headroom to reserve for further usage, specify it to zero to use default value.
+    \param [IN]     Length            <uint32_t>        : current data buffer length to allcated
+    \param [IN]     HeadRoom     <uint32_t>         : if caller knows reserved head space, set it; otherwise set 0 to use default value
+    \return pointer to RTK_BUFFER if succeed, null otherwise
+*/
+RTK_BUFFER*
+RtbAllocate(
+    uint32_t Length,
+    uint32_t HeadRoom
+    )
+{
+    RTK_BUFFER* Rtb = NULL;
+    ///Rtb buffer length:
+    ///     RTK_BUFFER   48
+    ///     HeadRoom      HeadRomm or 12
+    ///     Length
+    ///memory size: 48 + Length + 12(default) + 8*2(header for each memory) ---> a multiple of 8
+    ///example:       (48 + 8)+ (300 + 12 + 8) = 372
+    Rtb = malloc( sizeof(RTK_BUFFER) );
+    if(Rtb)
+    {
+        uint32_t BufferLen = HeadRoom ? (Length + HeadRoom) : (Length + DEFAULT_HEADER_SIZE);
+        BufferLen = RTB_DATA_ALIGN(BufferLen);
+        Rtb->Head = malloc(BufferLen);
+        if(Rtb->Head)
+        {
+            Rtb->HeadRoom = HeadRoom ? HeadRoom : DEFAULT_HEADER_SIZE;
+            Rtb->Data = Rtb->Head + Rtb->HeadRoom;
+            Rtb->End = Rtb->Data;
+            Rtb->Tail = Rtb->End + Length;
+            Rtb->Length = 0;
+            ListInitializeHeader(&Rtb->List);
+            Rtb->RefCount = 1;
+            return Rtb;
+        }
+    }
+
+    if (Rtb)
+    {
+        if (Rtb->Head)
+        {
+            free(Rtb->Head);
+        }
+
+        free(Rtb);
+    }
+    return NULL;
+}
+
+
+/**
+    Free specified Rtk_buffer
+    \param [IN]     RtkBuffer            <RTK_BUFFER*>        : buffer to free
+*/
+void
+RtbFree(
+    RTK_BUFFER* RtkBuffer
+)
+{
+    if(RtkBuffer)
+    {
+        free(RtkBuffer->Head);
+        free(RtkBuffer);
+    }
+    return;
+}
+
+/**
+    Add a specified length protocal header to the start of data buffer hold by specified rtk_buffer.
+    This function extends used data area of the buffer at the buffer start.
+    \param [IN OUT]     RtkBuffer            <RTK_BUFFER*>        : data buffer to add
+    \param [IN]            Length                <uint32_t>                 : header length
+    \return  Pointer to the first byte of the extra data is returned
+*/
+uint8_t*
+RtbAddHead(
+    RTK_BUFFER* RtkBuffer,
+    uint32_t                 Length
+    )
+{
+
+    if ((uint32_t)(RtkBuffer->Data - RtkBuffer->Head) >= Length)
+    {
+        RtkBuffer->Data -= Length;
+        RtkBuffer->Length += Length;
+        RtkBuffer->HeadRoom -= Length;
+        return RtkBuffer->Data;
+    }
+
+    return NULL;
+}
+/**
+    Remove a specified length data from the start of data buffer hold by specified rtk_buffer.
+    This function returns the memory to the headroom.
+    \param [IN OUT]     RtkBuffer            <RTK_BUFFER*>        : data buffer to remove
+    \param [IN]            Length                <uint32_t>                 : header length
+    \return  Pointer to the next data in the buffer is returned, usually useless
+*/
+unsigned char
+RtbRemoveHead(
+    RTK_BUFFER* RtkBuffer,
+    uint32_t                 Length
+    )
+{
+
+    if (RtkBuffer->Length >= Length)
+    {
+        RtkBuffer->Data += Length;
+        RtkBuffer->Length -= Length;
+        RtkBuffer->HeadRoom += Length;
+        return  TRUE;
+    }
+
+    return FALSE;
+}
+
+/**
+    Add a specified length protocal header to the end of data buffer hold by specified rtk_buffer.
+    This function extends used data area of the buffer at the buffer end.
+    \param [IN OUT]     RtkBuffer            <RTK_BUFFER*>        : data buffer to add
+    \param [IN]            Length                <uint32_t>                 : header length
+    \return  Pointer to the first byte of the extra data is returned
+*/
+uint8_t*
+RtbAddTail(
+    RTK_BUFFER* RtkBuffer,
+    uint32_t                 Length
+    )
+{
+
+    if ((uint32_t)(RtkBuffer->Tail - RtkBuffer->End) >= Length)
+    {
+        uint8_t* Tmp = RtkBuffer->End;
+        RtkBuffer->End += Length;
+        RtkBuffer->Length += Length;
+        return Tmp;
+    }
+
+    return NULL;
+}
+
+unsigned char
+RtbRemoveTail(
+    IN OUT RTK_BUFFER * RtkBuffer,
+    IN     uint32_t       Length
+)
+{
+
+    if ((uint32_t)(RtkBuffer->End - RtkBuffer->Data) >= Length)
+    {
+        RtkBuffer->End -= Length;
+        RtkBuffer->Length -= Length;
+        return TRUE;
+    }
+
+    return FALSE;
+}
+//****************************************************************************
+// RTB list manipulation
+//****************************************************************************
+/**
+    Initialize a rtb queue.
+    \return  Initilized rtb queue if succeed, otherwise NULL
+*/
+RTB_QUEUE_HEAD*
+RtbQueueInit(
+)
+{
+    RTB_QUEUE_HEAD* RtbQueue = NULL;
+
+    RtbQueue = malloc(sizeof(RTB_QUEUE_HEAD));
+    if(RtbQueue)
+    {
+        pthread_mutex_init(&RtbQueue->Lock, NULL);
+        ListInitializeHeader(&RtbQueue->List);
+        RtbQueue->QueueLen = 0;
+        return RtbQueue;
+    }
+
+    //error code comes here
+    if (RtbQueue)
+    {
+        free(RtbQueue);
+    }
+    return NULL;
+
+}
+
+/**
+    Free a rtb queue.
+    \param [IN]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+*/
+void
+RtbQueueFree(
+    RTB_QUEUE_HEAD* RtkQueueHead
+    )
+{
+    if (RtkQueueHead)
+    {
+
+
+        RtbEmptyQueue(RtkQueueHead);
+        pthread_mutex_destroy(&RtkQueueHead->Lock);
+        free(RtkQueueHead);
+    }
+}
+
+/**
+    Queue specified RtkBuffer into a RtkQueue at list tail.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \param [IN]            RtkBuffer                <RTK_BUFFER*>                 : Rtk buffer to add
+*/
+void
+RtbQueueTail(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 RtkBuffer
+    )
+{
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+    ListAddToTail(&RtkBuffer->List, &RtkQueueHead->List);
+    RtkQueueHead->QueueLen++;
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+}
+
+/**
+    Queue specified RtkBuffer into a RtkQueue at list Head.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \param [IN]            RtkBuffer                <RTK_BUFFER*>                 : Rtk buffer to add
+*/
+void
+RtbQueueHead(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 RtkBuffer
+    )
+{
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+    ListAddToHead(&RtkBuffer->List, &RtkQueueHead->List);
+    RtkQueueHead->QueueLen++;
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+}
+
+
+/**
+    Insert new Rtkbuffer in the old buffer
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \param [IN]            OldRtkBuffer                <RTK_BUFFER*>                 : old rtk buffer
+    \param [IN]            NewRtkBuffer                <RTK_BUFFER*>                 : Rtk buffer to add
+*/
+void
+RtbInsertBefore(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*  pOldRtkBuffer,
+    IN RTK_BUFFER*  pNewRtkBuffer
+)
+{
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+    ListAdd(&pNewRtkBuffer->List, pOldRtkBuffer->List.Prev, &pOldRtkBuffer->List);
+    RtkQueueHead->QueueLen++;
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+}
+
+/**
+    check whether the buffer is the last node in the queue
+*/
+unsigned char
+RtbNodeIsLast(
+    IN RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 pRtkBuffer
+)
+{
+    RTK_BUFFER* pBuf;
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+
+    pBuf = (RTK_BUFFER*)RtkQueueHead->List.Prev;
+    if(pBuf == pRtkBuffer)
+    {
+        pthread_mutex_unlock(&RtkQueueHead->Lock);
+        return TRUE;
+    }
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+    return FALSE;
+}
+
+/**
+    get the next buffer node after the specified buffer in the queue
+    if the specified buffer is the last node in the queue , return NULL
+    \param [IN]     RtkBuffer        <RTK_BUFFER*>        : Rtk Queue
+    \param [IN]     RtkBuffer        <RTK_BUFFER*>        : Rtk buffer
+    \return node after the specified buffer
+*/
+RTK_BUFFER*
+RtbQueueNextNode(
+    IN RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 pRtkBuffer
+)
+{
+    RTK_BUFFER* pBuf;
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+    pBuf = (RTK_BUFFER*)RtkQueueHead->List.Prev;
+    if(pBuf == pRtkBuffer)
+    {
+        pthread_mutex_unlock(&RtkQueueHead->Lock);
+        return NULL;    ///< if it is already the last node in the queue , return NULL
+    }
+    pBuf = (RTK_BUFFER*)pRtkBuffer->List.Next;
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+    return pBuf;    ///< return next node after this node
+}
+
+/**
+    Delete specified RtkBuffer from a RtkQueue.
+    It don't hold spinlock itself, so caller must hold it at someplace.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \param [IN]            RtkBuffer                <RTK_BUFFER*>                 : Rtk buffer to Remove
+*/
+void
+RtbRemoveNode(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 RtkBuffer
+)
+{
+    RtkQueueHead->QueueLen--;
+    ListDeleteNode(&RtkBuffer->List);
+}
+
+
+/**
+    Get the RtkBuffer which is the head of a RtkQueue
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \return head of the RtkQueue , otherwise NULL
+*/
+RTK_BUFFER*
+RtbTopQueue(
+    IN RTB_QUEUE_HEAD* RtkQueueHead
+)
+{
+    RTK_BUFFER* Rtb = NULL;
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+
+    if (RtbQueueIsEmpty(RtkQueueHead))
+    {
+        pthread_mutex_unlock(&RtkQueueHead->Lock);
+        return NULL;
+    }
+
+    Rtb = (RTK_BUFFER*)RtkQueueHead->List.Next;
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+
+    return Rtb;
+}
+
+/**
+    Remove a RtkBuffer from specified rtkqueue at list tail.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \return    removed rtkbuffer if succeed, otherwise NULL
+*/
+RTK_BUFFER*
+RtbDequeueTail(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead
+)
+{
+    RTK_BUFFER* Rtb = NULL;
+
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+    if (RtbQueueIsEmpty(RtkQueueHead))
+    {
+         pthread_mutex_unlock(&RtkQueueHead->Lock);
+         return NULL;
+    }
+    Rtb = (RTK_BUFFER*)RtkQueueHead->List.Prev;
+    RtbRemoveNode(RtkQueueHead, Rtb);
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+
+    return Rtb;
+}
+
+/**
+    Remove a RtkBuffer from specified rtkqueue at list head.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \return    removed rtkbuffer if succeed, otherwise NULL
+*/
+RTK_BUFFER*
+RtbDequeueHead(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead
+    )
+{
+    RTK_BUFFER* Rtb = NULL;
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+
+     if (RtbQueueIsEmpty(RtkQueueHead))
+     {
+         pthread_mutex_unlock(&RtkQueueHead->Lock);
+         return NULL;
+     }
+    Rtb = (RTK_BUFFER*)RtkQueueHead->List.Next;
+    RtbRemoveNode(RtkQueueHead, Rtb);
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+    return Rtb;
+}
+
+/**
+    Get current rtb queue's length.
+    \param [IN]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \return    current queue's length
+*/
+signed long RtbGetQueueLen(
+    IN RTB_QUEUE_HEAD* RtkQueueHead
+    )
+{
+    return RtkQueueHead->QueueLen;
+}
+
+/**
+    Empty the rtkqueue.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+*/
+void
+RtbEmptyQueue(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead
+    )
+{
+    RTK_BUFFER* Rtb = NULL;
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+
+    while( !RtbQueueIsEmpty(RtkQueueHead))
+    {
+        Rtb = (RTK_BUFFER*)RtkQueueHead->List.Next;
+        RtbRemoveNode(RtkQueueHead, Rtb);
+        RtbFree(Rtb);
+    }
+
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+    return;
+}
+
+
+///Annie_tmp
+unsigned char
+RtbCheckQueueLen(IN RTB_QUEUE_HEAD* RtkQueueHead, IN uint8_t Len)
+{
+    return RtkQueueHead->QueueLen < Len ? TRUE : FALSE;
+}
+
+/**
+    clone buffer for upper or lower layer, because original buffer should be stored in l2cap
+    \param <RTK_BUFFER* pDataBuffer: original buffer
+    \return cloned buffer
+*/
+RTK_BUFFER*
+RtbCloneBuffer(
+    IN RTK_BUFFER* pDataBuffer
+)
+{
+    RTK_BUFFER* pNewBuffer = NULL;
+    if(pDataBuffer)
+    {
+        pNewBuffer = RtbAllocate(pDataBuffer->Length,0);
+        if(!pNewBuffer)
+        {
+            return NULL;
+        }
+        if(pDataBuffer && pDataBuffer->Data)
+            memcpy(pNewBuffer->Data, pDataBuffer->Data, pDataBuffer->Length);
+        else
+        {
+            RtbFree(pNewBuffer);
+            return NULL;
+        }
+
+        pNewBuffer->Length = pDataBuffer->Length;
+    }
+    return pNewBuffer;
+}
diff --git a/hci/src/hci_h5.c b/hci/src/hci_h5.c
new file mode 100755
index 0000000..59befd9
--- /dev/null
+++ b/hci/src/hci_h5.c
@@ -0,0 +1,3722 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Realtek Corporation.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+*
+*	Module Name:
+*	    hci_h5.c
+*
+*	Abstract:
+*	    Contain HCI transport send/receive functions for UART H5 Interface.
+*
+*	Major Change History:
+*	      When             Who       What
+*	    ---------------------------------------------------------------
+*	    2015-12-15      lamparten   modified
+*
+*	Notes:
+*	      This is designed for UART H5 HCI Interface in Android 6.0.
+*
+******************************************************************************/
+
+
+
+
+#define LOG_TAG "bt_h5"
+#define RTKBT_RELEASE_NAME	"Test"
+#include <utils/Log.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include "bt_hci_bdroid.h"
+#include "hci_layer.h"
+#include "userial.h"
+#include "gki.h"
+#include <termios.h>
+#include <errno.h>
+#include "bt_skbuff.h"
+#include "bt_list.h"
+
+#include <signal.h>
+#include <time.h>
+#include "packet_fragmenter.h"
+#include <sys/prctl.h>
+
+/*BOARD_HAVE_BLUETOOTH_RTK_COEX begin*/
+#ifdef BLUETOOTH_RTK_COEX
+#include "rtk_parse.h"
+#endif
+
+#include "btsnoop.h"
+#include "hci_hal.h"
+#include <string.h>
+#include <sys/syscall.h>
+
+/*BOARD_HAVE
+_BLUETOOTH_RTK_COEX end*/
+/******************************************************************************
+**  Constants & Macros
+******************************************************************************/
+
+#define H5_TRACE_DATA_ENABLE 1//if you want to see data tx and rx, set H5_TRACE_DATA_ENABLE 1
+static const packet_fragmenter_callbacks_t *hci_layer_callbacks;
+
+
+static const allocator_t *buffer_allocator;
+static const btsnoop_t *btsnoop;
+static const hci_hal_t *hal;
+
+
+uint8_t h5_log_enable = 0;
+
+#ifndef H5_LOG_BUF_SIZE
+#define H5_LOG_BUF_SIZE  1024
+#endif
+#define H5_LOG_MAX_SIZE  (H5_LOG_BUF_SIZE - 12)
+
+
+#ifndef H5_LOG_BUF_SIZE
+#define H5_LOG_BUF_SIZE  1024
+#endif
+#define H5_LOG_MAX_SIZE  (H5_LOG_BUF_SIZE - 12)
+
+
+#define TIMER_H5_DATA_RETRANS (SIGRTMAX)
+#define TIMER_H5_SYNC_RETRANS (SIGRTMAX -1)
+#define TIMER_H5_CONF_RETRANS (SIGRTMAX -2)
+#define TIMER_H5_WAIT_CT_BAUDRATE_READY (SIGRTMAX -3)
+#define TIMER_H5_HW_INIT_READY        (SIGRTMAX -4)
+
+#define DATA_RETRANS_COUNT  40  //40*100 = 4000ms(4s)
+#define SYNC_RETRANS_COUNT  20  //20*250 = 5000ms(5s)
+#define CONF_RETRANS_COUNT  20
+
+
+#define DATA_RETRANS_TIMEOUT_VALUE  100 //ms
+#define SYNC_RETRANS_TIMEOUT_VALUE   250
+#define CONF_RETRANS_TIMEOUT_VALUE   250
+#define WAIT_CT_BAUDRATE_READY_TIMEOUT_VALUE   250
+#define H5_HW_INIT_READY_TIMEOUT_VALUE   4000//4
+
+#define HCI_VSC_H5_INIT                0xFCEE
+
+
+/* Preamble length for HCI Commands:
+**      2-bytes for opcode and 1 byte for length
+*/
+#define HCI_CMD_PREAMBLE_SIZE   3
+
+/* Preamble length for HCI Events:
+**      1-byte for opcode and 1 byte for length
+*/
+#define HCI_EVT_PREAMBLE_SIZE   2
+
+/* Preamble length for SCO Data:
+**      2-byte for Handle and 1 byte for length
+*/
+#define HCI_SCO_PREAMBLE_SIZE   3
+
+/* Preamble length for ACL Data:
+**      2-byte for Handle and 2 byte for length
+*/
+#define HCI_ACL_PREAMBLE_SIZE   4
+
+
+
+#define ACL_RX_PKT_START        2
+#define ACL_RX_PKT_CONTINUE     1
+#define L2CAP_HEADER_SIZE       4
+
+/* Maximum numbers of allowed internal
+** outstanding command packets at any time
+*/
+#define INT_CMD_PKT_MAX_COUNT       8
+#define INT_CMD_PKT_IDX_MASK        0x07
+
+
+//HCI Event codes
+#define HCI_CONNECTION_COMP_EVT             0x03
+#define HCI_DISCONNECTION_COMP_EVT          0x05
+#define HCI_COMMAND_COMPLETE_EVT    0x0E
+#define HCI_COMMAND_STATUS_EVT      0x0F
+#define HCI_NUM_OF_CMP_PKTS_EVT     0x13
+#define HCI_BLE_EVT     0x3E
+
+//HCI Command opcodes
+#define HCI_READ_BUFFER_SIZE        0x1005
+#define HCI_LE_READ_BUFFER_SIZE     0x2002
+
+
+
+#define PATCH_DATA_FIELD_MAX_SIZE     252
+#define READ_DATA_SIZE  16
+
+// HCI data types //
+#define H5_ACK_PKT              0x00
+#define HCI_COMMAND_PKT         0x01
+#define HCI_ACLDATA_PKT         0x02
+#define HCI_SCODATA_PKT         0x03
+#define HCI_EVENT_PKT           0x04
+#define H5_VDRSPEC_PKT          0x0E
+#define H5_LINK_CTL_PKT         0x0F
+
+#define H5_HDR_SEQ(hdr)         ((hdr)[0] & 0x07)
+#define H5_HDR_ACK(hdr)         (((hdr)[0] >> 3) & 0x07)
+#define H5_HDR_CRC(hdr)         (((hdr)[0] >> 6) & 0x01)
+#define H5_HDR_RELIABLE(hdr)    (((hdr)[0] >> 7) & 0x01)
+#define H5_HDR_PKT_TYPE(hdr)    ((hdr)[1] & 0x0f)
+#define H5_HDR_LEN(hdr)         ((((hdr)[1] >> 4) & 0xff) + ((hdr)[2] << 4))
+#define H5_HDR_SIZE             4
+
+#define H5_CFG_SLID_WIN(cfg)    ((cfg) & 0x07)
+#define H5_CFG_OOF_CNTRL(cfg)   (((cfg) >> 3) & 0x01)
+#define H5_CFG_DIC_TYPE(cfg)    (((cfg) >> 4) & 0x01)
+#define H5_CFG_VER_NUM(cfg)     (((cfg) >> 5) & 0x07)
+#define H5_CFG_SIZE             1
+
+
+
+/******************************************************************************
+**  Local type definitions
+******************************************************************************/
+
+static const uint16_t msg_evt_table[] =
+{
+    MSG_HC_TO_STACK_HCI_ERR,       /* H4_TYPE_COMMAND */
+    MSG_HC_TO_STACK_HCI_ACL,       /* H4_TYPE_ACL_DATA */
+    MSG_HC_TO_STACK_HCI_SCO,       /* H4_TYPE_SCO_DATA */
+    MSG_HC_TO_STACK_HCI_EVT        /* H4_TYPE_EVENT */
+};
+
+/* Callback function for the returned event of internal issued command */
+typedef void (*tINT_CMD_CBACK)(void *p_mem);
+
+typedef struct
+{
+    uint16_t opcode;        /* OPCODE of outstanding internal commands */
+    tINT_CMD_CBACK cback;   /* Callback function when return of internal
+                             * command is received */
+} tINT_CMD_Q;
+
+typedef RTK_BUFFER sk_buff;
+
+typedef enum H5_RX_STATE
+{
+    H5_W4_PKT_DELIMITER,
+    H5_W4_PKT_START,
+    H5_W4_HDR,
+    H5_W4_DATA,
+    H5_W4_CRC
+} tH5_RX_STATE;
+
+typedef enum H5_RX_ESC_STATE
+{
+    H5_ESCSTATE_NOESC,
+    H5_ESCSTATE_ESC
+} tH5_RX_ESC_STATE;
+
+typedef enum H5_LINK_STATE
+{
+    H5_UNINITIALIZED,
+    H5_INITIALIZED,
+    H5_ACTIVE
+} tH5_LINK_STATE;
+
+typedef struct _HCI_CONN {
+    RT_LIST_ENTRY List;
+    uint16_t handle;
+    bdaddr_t bd_addr;
+    uint8_t link_type;
+    uint8_t encrypt_enabled;
+    uint16_t NumOfNotCmpAclPkts;
+    RTB_QUEUE_HEAD *pending_pkts;    // pending pkts to send
+    sk_buff *rx_skb;
+}HCI_CONN, *PHCI_CONN;
+
+
+#define H5_EVENT_RX                    0x0001
+#define H5_EVENT_EXIT                  0x0200
+
+static volatile uint8_t h5_retransfer_running = 0;
+static volatile uint16_t h5_ready_events = 0;
+
+
+/* Control block for HCISU_H5 */
+typedef struct HCI_H5_CB
+{
+    HC_BT_HDR *p_rcv_msg;          /* Buffer to hold current rx HCI message */
+    uint16_t rcv_len;               /* Size of current incoming message */
+    uint8_t rcv_msg_type;           /* Current incoming message type */
+//    tHCI_H4_RCV_STATE rcv_state;    /* Receive state of current rx message */
+    uint16_t hc_acl_data_size;      /* Controller's max ACL data length */
+    uint8_t   hc_sco_data_size;
+    uint16_t hc_acl_total_num;      /* Controller's total ACL number packets */
+    uint16_t hc_sco_total_num;      /* Controller's total ACL number packets */
+    uint16_t hc_ble_acl_data_size;  /* Controller's max BLE ACL data length */
+    uint8_t hc_ble_acl_total_num;  /* Controller's max BLE ACL data length */
+//    BUFFER_Q acl_rx_q;      /* Queue of base buffers for fragmented ACL pkts */
+    uint8_t preload_count;          /* Count numbers of preload bytes */
+    uint8_t preload_buffer[6];      /* HCI_ACL_PREAMBLE_SIZE + 2 */
+    int int_cmd_rsp_pending;        /* Num of internal cmds pending for ack */
+    uint8_t int_cmd_rd_idx;         /* Read index of int_cmd_opcode queue */
+    uint8_t int_cmd_wrt_idx;        /* Write index of int_cmd_opcode queue */
+    tINT_CMD_Q int_cmd[INT_CMD_PKT_MAX_COUNT]; /* FIFO queue */
+
+    tINT_CMD_CBACK cback_h5sync;   /* Callback function when h5 sync*/
+
+    uint8_t sliding_window_size;
+    uint8_t oof_flow_control;
+    uint8_t dic_type;
+
+
+    RTB_QUEUE_HEAD *unack;      // Unack'ed packets queue
+    RTB_QUEUE_HEAD *rel;        // Reliable packets queue
+
+    RTB_QUEUE_HEAD *unrel;      // Unreliable packets queue
+
+
+    uint8_t rxseq_txack;        // rxseq == txack. // expected rx SeqNumber
+    uint8_t     rxack;             // Last packet sent by us that the peer ack'ed //
+
+    uint8_t     use_crc;
+    uint8_t     is_txack_req;      // txack required? Do we need to send ack's to the peer? //
+
+    // Reliable packet sequence number - used to assign seq to each rel pkt. */
+    uint8_t msgq_txseq;         //next pkt seq
+
+    uint16_t    message_crc;
+    uint32_t    rx_count;       //expected pkts to recv
+
+    tH5_RX_STATE rx_state;
+    tH5_RX_ESC_STATE rx_esc_state;
+    tH5_LINK_STATE link_estab_state;
+
+    sk_buff *rx_skb;
+    sk_buff* host_last_cmd;
+
+    timer_t  timer_data_retrans;
+    timer_t  timer_sync_retrans;
+    timer_t  timer_conf_retrans;
+    timer_t  timer_wait_ct_baudrate_ready;
+    timer_t  timer_h5_hw_init_ready;
+
+    uint32_t data_retrans_count;
+    uint32_t sync_retrans_count;
+    uint32_t conf_retrans_count;
+
+    pthread_mutex_t mutex;
+    pthread_cond_t  cond;
+    pthread_t thread_data_retrans;
+
+
+    RT_LIST_HEAD    HciConnHash;
+
+    uint16_t hc_cur_acl_total_num;
+    uint8_t   cleanuping;
+}tHCI_H5_CB;
+
+static tHCI_H5_CB rtk_h5;
+static pthread_mutex_t h5_wakeup_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+/******************************************************************************
+**  Variables
+******************************************************************************/
+
+/* Num of allowed outstanding HCI CMD packets */
+volatile int num_hci_cmd_pkts = 1;
+
+/******************************************************************************
+**  Static variables
+******************************************************************************/
+
+struct patch_struct {
+    int nTxIndex;   // current sending pkt number
+    int nTotal;     // total pkt number
+    int nRxIndex;   // ack index from board
+    int nNeedRetry; // if no response from board
+};
+static struct patch_struct rtk_patch;
+
+
+
+/******************************************************************************
+**  Externs
+******************************************************************************/
+
+extern BUFFER_Q tx_q;
+extern void rtk_parse_internal_event_intercept(uint8_t *p_msg);
+extern void rtk_parse_l2cap_data(uint8_t *pp, uint8_t direction);
+extern void rtk_parse_command(uint8_t *pp);
+void btsnoop_init(void);
+void btsnoop_close(void);
+void btsnoop_cleanup (void);
+
+uint8_t hci_h5_send_int_cmd(uint16_t opcode, HC_BT_HDR *p_buf, \
+                                  tINT_CMD_CBACK p_cback);
+void lpm_wake_assert(void);
+void lpm_tx_done(uint8_t is_tx_done);
+static void h5_wake_up();
+
+//timer API for retransfer
+int h5_alloc_data_retrans_timer();
+int h5_free_data_retrans_timer();
+int h5_stop_data_retrans_timer();
+int h5_start_data_retrans_timer();
+
+int h5_alloc_sync_retrans_timer();
+int h5_free_sync_retrans_timer();
+int h5_stop_sync_retrans_timer();
+int h5_start_sync_retrans_timer();
+
+int h5_alloc_conf_retrans_timer();
+int h5_free_conf_retrans_timer();
+int h5_stop_conf_retrans_timer();
+int h5_start_conf_retrans_timer();
+
+int h5_alloc_wait_controller_baudrate_ready_timer();
+int h5_free_wait_controller_baudrate_ready_timer();
+int h5_stop_wait_controller_baudrate_ready_timer();
+int h5_start_wait_controller_baudrate_ready_timer();
+
+int h5_alloc_hw_init_ready_timer();
+int h5_free_hw_init_ready_timer();
+int h5_stop_hw_init_ready_timer();
+int h5_start_hw_init_ready_timer();
+
+
+// bite reverse in bytes
+// 00000001 -> 10000000
+// 00000100 -> 00100000
+const uint8_t byte_rev_table[256] = {
+    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
+    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
+    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
+    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
+    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
+    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
+    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
+    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
+    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
+    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
+    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
+    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
+    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
+    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
+    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
+    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
+    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
+    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
+    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
+    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
+    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
+    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
+    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
+    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
+    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
+    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
+    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
+    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
+    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
+    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
+    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
+    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
+};
+#ifndef H5_LOG_BUF_SIZE
+#define H5_LOG_BUF_SIZE  1024
+#endif
+#define H5_LOG_MAX_SIZE  (H5_LOG_BUF_SIZE - 12)
+
+#define LOGI0(t,s) __android_log_write(ANDROID_LOG_INFO, t, s)
+
+static void
+H5LogMsg(const char *fmt_str, ...)
+{
+    static char buffer[H5_LOG_BUF_SIZE];
+    if(h5_log_enable == 1)
+    {
+        va_list ap;
+        va_start(ap, fmt_str);
+        vsnprintf(&buffer[0], H5_LOG_MAX_SIZE, fmt_str, ap);
+        va_end(ap);
+
+        LOGI0("H5: ", buffer);
+     }
+     else
+     {
+        return;
+     }
+}
+
+/* Copy, swap, convert BD Address */
+static inline int bacmp(bdaddr_t *ba1, bdaddr_t *ba2)
+{
+    return memcmp(ba1, ba2, sizeof(bdaddr_t));
+}
+static inline void bacpy(bdaddr_t *dst, bdaddr_t *src)
+{
+    memcpy(dst, src, sizeof(bdaddr_t));
+}
+
+static inline void baPrint(bdaddr_t ba)
+{
+    H5LogMsg("BT_ADDR: 0x%02X%02X%02X%02X%02X%02X",ba.b[5], ba.b[4], ba.b[3], ba.b[2], ba.b[1], ba.b[0]);
+}
+// reverse bit
+static __inline uint8_t bit_rev8(uint8_t byte)
+{
+    return byte_rev_table[byte];
+}
+
+// reverse bit
+static __inline uint16_t bit_rev16(uint16_t x)
+{
+    return (bit_rev8(x & 0xff) << 8) | bit_rev8(x >> 8);
+}
+
+static const uint16_t crc_table[] =
+{
+    0x0000, 0x1081, 0x2102, 0x3183,
+    0x4204, 0x5285, 0x6306, 0x7387,
+    0x8408, 0x9489, 0xa50a, 0xb58b,
+    0xc60c, 0xd68d, 0xe70e, 0xf78f
+};
+
+// Initialise the crc calculator
+#define H5_CRC_INIT(x) x = 0xffff
+
+
+/*******************************************************************************
+**
+** Function        ms_delay
+**
+** Description     sleep unconditionally for timeout milliseconds
+**
+** Returns         None
+**
+*******************************************************************************/
+void ms_delay (uint32_t timeout)
+{
+    struct timespec delay;
+    int err;
+
+    if (timeout == 0)
+        return;
+
+    delay.tv_sec = timeout / 1000;
+    delay.tv_nsec = 1000 * 1000 * (timeout%1000);
+
+    /* [u]sleep can't be used because it uses SIGALRM */
+    do {
+        err = nanosleep(&delay, &delay);
+    } while (err < 0 && errno ==EINTR);
+}
+/***********************************************
+//
+//skb related functions
+//
+//
+//
+***********************************************/
+uint8_t *
+skb_get_data(
+    IN sk_buff *skb
+    )
+{
+    return skb->Data;
+}
+
+uint32_t
+skb_get_data_length(
+    IN sk_buff *skb
+    )
+{
+    return skb->Length;
+}
+
+uint32_t
+skb_get_hci_data_length(
+    IN sk_buff *skb_acl
+    )
+{
+    uint8_t     *data;
+    uint16_t   data_len = 0;
+
+    uint16_t    handle, hci_len, l2cap_len;
+
+    uint8_t     frame_end=TRUE;
+
+
+    data = skb_get_data(skb_acl);
+    STREAM_TO_UINT16 (handle, data);
+    STREAM_TO_UINT16 (hci_len, data);
+
+    return hci_len;
+
+}
+
+uint32_t
+skb_get_l2cap_data_length(
+    IN sk_buff *skb_acl
+    )
+{
+    uint8_t     *data;
+    uint16_t   data_len = 0;
+
+    uint16_t    handle, hci_len, l2cap_len;
+
+    uint8_t     frame_end=TRUE;
+
+
+    data = skb_get_data(skb_acl);
+    STREAM_TO_UINT16 (handle, data);
+    STREAM_TO_UINT16 (hci_len, data);
+    STREAM_TO_UINT16 (l2cap_len, data);
+
+
+    return l2cap_len;
+
+}
+
+void
+skb_set_hci_data_length(
+    IN sk_buff *skb_acl,
+    IN uint32_t hci_len
+    )
+{
+    uint8_t     *data;
+
+    data = skb_get_data(skb_acl);
+    data = data + 2;
+    UINT16_TO_STREAM(data, hci_len);
+}
+
+sk_buff *
+skb_alloc(
+    IN unsigned int len
+    )
+{
+    sk_buff * skb = (sk_buff * )RtbAllocate(len, 0);
+    return skb;
+}
+
+void
+skb_free(
+    IN OUT sk_buff **skb
+    )
+{
+    RtbFree(*skb);
+    *skb = NULL;
+    return;
+}
+
+static  void skb_unlink(
+    sk_buff *skb,
+    struct _RTB_QUEUE_HEAD * list
+)
+{
+    RtbRemoveNode(list, skb);
+}
+
+// increase the date length in sk_buffer by len,
+// and return the increased header pointer
+uint8_t *skb_put(OUT sk_buff* skb, IN uint32_t len)
+{
+    RTK_BUFFER * rtb = (RTK_BUFFER * )skb;
+
+    return RtbAddTail(rtb, len);
+}
+
+// change skb->len to len
+// !!! len should less than skb->len
+void skb_trim( sk_buff *skb, unsigned int len)
+{
+    RTK_BUFFER * rtb = (RTK_BUFFER * )skb;
+    uint32_t skb_len = skb_get_data_length(skb);
+
+    RtbRemoveTail(rtb, (skb_len - len));
+    return;
+}
+
+uint8_t skb_get_pkt_type( sk_buff *skb)
+{
+    return BT_CONTEXT(skb)->PacketType;
+}
+
+void skb_set_pkt_type( sk_buff *skb, uint8_t pkt_type)
+{
+    BT_CONTEXT(skb)->PacketType = pkt_type;
+}
+
+uint16_t skb_get_acl_handle( sk_buff *skb)
+{
+    return BT_CONTEXT(skb)->Handle;
+}
+
+void skb_set_acl_handle( sk_buff *skb, uint16_t handle)
+{
+    BT_CONTEXT(skb)->Handle = handle;
+}
+
+
+// decrease the data length in sk_buffer by len,
+// and move the content forward to the header.
+// the data in header will be removed.
+void skb_pull(OUT  sk_buff * skb, IN uint32_t len)
+{
+    RTK_BUFFER * rtb = (RTK_BUFFER * )skb;
+    RtbRemoveHead(rtb, len);
+    return;
+}
+
+sk_buff *
+skb_alloc_and_init(
+    IN uint8_t PktType,
+    IN uint8_t * Data,
+    IN uint32_t  DataLen
+    )
+{
+    sk_buff * skb = skb_alloc(DataLen);
+    if (NULL == skb)
+    return NULL;
+    memcpy(skb_put(skb, DataLen), Data, DataLen);
+    skb_set_pkt_type(skb, PktType);
+
+    return skb;
+}
+
+static void
+skb_queue_head(
+    IN RTB_QUEUE_HEAD * skb_head,
+    IN RTK_BUFFER * skb
+)
+{
+    RtbQueueHead(skb_head, skb);
+}
+
+static void
+skb_queue_tail(
+    IN RTB_QUEUE_HEAD * skb_head,
+    IN RTK_BUFFER * skb
+)
+{
+    RtbQueueTail(skb_head, skb);
+}
+
+static RTK_BUFFER *
+skb_dequeue_head(IN RTB_QUEUE_HEAD * skb_head)
+{
+    return RtbDequeueHead(skb_head);
+}
+
+static RTK_BUFFER *
+skb_dequeue_tail(IN RTB_QUEUE_HEAD * skb_head)
+{
+    return RtbDequeueTail(skb_head);
+}
+
+static uint32_t
+skb_queue_get_length(
+    IN RTB_QUEUE_HEAD * skb_head
+)
+{
+    return RtbGetQueueLen(skb_head);
+}
+
+
+/**
+*/
+HCI_CONN*
+HciConnAllocate(
+    uint16_t handle
+  )
+{
+    HCI_CONN * phci_conn = NULL;
+    phci_conn = malloc(sizeof(HCI_CONN));
+    if(phci_conn)
+    {
+        phci_conn->handle = handle;
+        phci_conn->pending_pkts = RtbQueueInit();
+        phci_conn->rx_skb = NULL;
+    }
+    return phci_conn;
+}
+
+/**
+*/
+void
+HciConnFree(
+    HCI_CONN* phci_conn
+  )
+{
+    if(phci_conn)
+    {
+        RtbQueueFree(phci_conn->pending_pkts);
+        if(phci_conn->rx_skb)
+            skb_free(&phci_conn->rx_skb);
+
+        free(phci_conn);
+    }
+}
+
+/**
+    HCI connection related APIs.
+
+*/
+void ConnHashInit(tHCI_H5_CB* h5)
+{
+    RT_LIST_HEAD* Head = &h5->HciConnHash;
+    ListInitializeHeader(Head);
+}
+
+void ConnHashFlush(tHCI_H5_CB* h5)
+{
+    RT_LIST_HEAD* Head = &h5->HciConnHash;
+    RT_LIST_ENTRY* Iter = NULL, *Temp = NULL;
+    HCI_CONN* Desc = NULL;
+
+    LIST_FOR_EACH_SAFELY(Iter, Temp, Head)
+    {
+        Desc = LIST_ENTRY(Iter, HCI_CONN, List);
+        if (Desc)
+        {
+            ListDeleteNode(Iter);
+            HciConnFree(Desc);
+        }
+    }
+    ListInitializeHeader(Head);
+}
+
+void ConnHashAdd(tHCI_H5_CB* h5, HCI_CONN* Desc)
+{
+    RT_LIST_HEAD* Head = &h5->HciConnHash;
+    ListAddToTail(&Desc->List, Head);
+
+}
+
+void ConnHashDelete(HCI_CONN* Desc)
+{
+    if (Desc)
+        ListDeleteNode(&Desc->List);
+}
+
+HCI_CONN* ConnHashLookupByHandle(tHCI_H5_CB* h5, uint16_t Handle)
+{
+    RT_LIST_HEAD* Head = &h5->HciConnHash;
+    RT_LIST_ENTRY* Iter = NULL;
+    HCI_CONN* Desc = NULL;
+
+    LIST_FOR_EACH(Iter, Head)
+    {
+        Desc = LIST_ENTRY(Iter, HCI_CONN, List);
+        if ((Handle & 0xEFF) == Desc->handle )  //only last 12 bit are meanful for hci handle
+        {
+            return Desc;
+        }
+    }
+    return NULL;
+}
+
+
+
+
+/**
+* Add "d" into crc scope, caculate the new crc value
+*
+* @param crc crc data
+* @param d one byte data
+*/
+static void h5_crc_update(uint16_t *crc, uint8_t d)
+{
+    uint16_t reg = *crc;
+
+    reg = (reg >> 4) ^ crc_table[(reg ^ d) & 0x000f];
+    reg = (reg >> 4) ^ crc_table[(reg ^ (d >> 4)) & 0x000f];
+
+    *crc = reg;
+}
+
+struct __una_u16 { uint16_t x; };
+static __inline uint16_t __get_unaligned_cpu16(const void *p)
+{
+    const struct __una_u16 *ptr = (const struct __una_u16 *)p;
+    return ptr->x;
+}
+
+
+static __inline uint16_t get_unaligned_be16(const void *p)
+{
+    return __get_unaligned_cpu16((const uint8_t *)p);
+}
+/**
+* Get crc data.
+*
+* @param h5 realtek h5 struct
+* @return crc data
+*/
+static uint16_t h5_get_crc(tHCI_H5_CB *h5)
+{
+   uint16_t crc = 0;
+   uint8_t * data = skb_get_data(h5->rx_skb) + skb_get_data_length(h5->rx_skb) - 2;
+   crc = data[1] + (data[0] << 8);
+   return crc;
+}
+
+/**
+* Just add 0xc0 at the end of skb,
+* we can also use this to add 0xc0 at start while there is no data in skb
+*
+* @param skb socket buffer
+*/
+static void h5_slip_msgdelim(sk_buff *skb)
+{
+    const char pkt_delim = 0xc0;
+    memcpy(skb_put(skb, 1), &pkt_delim, 1);
+}
+
+/**
+* Slip ecode one byte in h5 proto, as follows:
+* 0xc0 -> 0xdb, 0xdc
+* 0xdb -> 0xdb, 0xdd
+* 0x11 -> 0xdb, 0xde
+* 0x13 -> 0xdb, 0xdf
+* others will not change
+*
+* @param skb socket buffer
+* @c pure data in the one byte
+*/
+static void h5_slip_one_byte(sk_buff *skb, uint8_t c)
+{
+    const signed char esc_c0[2] = { 0xdb, 0xdc };
+    const signed char esc_db[2] = { 0xdb, 0xdd };
+    const signed char esc_11[2] = { 0xdb, 0xde };
+    const signed char esc_13[2] = { 0xdb, 0xdf };
+
+    switch (c)
+    {
+    case 0xc0:
+        memcpy(skb_put(skb, 2), &esc_c0, 2);
+        break;
+    case 0xdb:
+        memcpy(skb_put(skb, 2), &esc_db, 2);
+        break;
+
+    case 0x11:
+    {
+        if(rtk_h5.oof_flow_control)
+        {
+            memcpy(skb_put(skb, 2), &esc_11, 2);
+        }
+        else
+        {
+            memcpy(skb_put(skb, 1), &c, 1);
+        }
+    }
+    break;
+
+    case 0x13:
+    {
+        if(rtk_h5.oof_flow_control)
+        {
+            memcpy(skb_put(skb, 2), &esc_13, 2);
+        }
+        else
+        {
+            memcpy(skb_put(skb, 1), &c, 1);
+        }
+    }
+    break;
+
+    default:
+        memcpy(skb_put(skb, 1), &c, 1);
+    }
+}
+
+/**
+* Decode one byte in h5 proto, as follows:
+* 0xdb, 0xdc -> 0xc0
+* 0xdb, 0xdd -> 0xdb
+* 0xdb, 0xde -> 0x11
+* 0xdb, 0xdf -> 0x13
+* others will not change
+*
+* @param h5 realtek h5 struct
+* @byte pure data in the one byte
+*/
+static void h5_unslip_one_byte(tHCI_H5_CB *h5, unsigned char byte)
+{
+    const uint8_t c0 = 0xc0, db = 0xdb;
+    const uint8_t oof1 = 0x11, oof2 = 0x13;
+    uint8_t *hdr = (uint8_t *)skb_get_data(h5->rx_skb);
+
+    if (H5_ESCSTATE_NOESC == h5->rx_esc_state)
+    {
+        if (0xdb == byte)
+        {
+            h5->rx_esc_state = H5_ESCSTATE_ESC;
+        }
+        else
+        {
+            memcpy(skb_put(h5->rx_skb, 1), &byte, 1);
+            //Check Pkt Header's CRC enable bit
+            if (H5_HDR_CRC(hdr) && h5->rx_state != H5_W4_CRC)
+            {
+                h5_crc_update(&h5->message_crc, byte);
+            }
+            h5->rx_count--;
+        }
+    }
+    else if(H5_ESCSTATE_ESC == h5->rx_esc_state)
+    {
+        switch (byte)
+        {
+        case 0xdc:
+            memcpy(skb_put(h5->rx_skb, 1), &c0, 1);
+            if (H5_HDR_CRC(hdr) && h5->rx_state != H5_W4_CRC)
+                h5_crc_update(&h5-> message_crc, 0xc0);
+            h5->rx_esc_state = H5_ESCSTATE_NOESC;
+            h5->rx_count--;
+            break;
+        case 0xdd:
+            memcpy(skb_put(h5->rx_skb, 1), &db, 1);
+             if (H5_HDR_CRC(hdr) && h5->rx_state != H5_W4_CRC)
+                h5_crc_update(&h5-> message_crc, 0xdb);
+            h5->rx_esc_state = H5_ESCSTATE_NOESC;
+            h5->rx_count--;
+            break;
+        case 0xde:
+            memcpy(skb_put(h5->rx_skb, 1), &oof1, 1);
+            if (H5_HDR_CRC(hdr) && h5->rx_state != H5_W4_CRC)
+                h5_crc_update(&h5-> message_crc, oof1);
+            h5->rx_esc_state = H5_ESCSTATE_NOESC;
+            h5->rx_count--;
+            break;
+        case 0xdf:
+            memcpy(skb_put(h5->rx_skb, 1), &oof2, 1);
+            if (H5_HDR_CRC(hdr) && h5->rx_state != H5_W4_CRC)
+                h5_crc_update(&h5-> message_crc, oof2);
+            h5->rx_esc_state = H5_ESCSTATE_NOESC;
+            h5->rx_count--;
+            break;
+        default:
+            ALOGE("Error: Invalid byte %02x after esc byte", byte);
+            skb_free(&h5->rx_skb);
+            h5->rx_skb = NULL;
+            h5->rx_state = H5_W4_PKT_DELIMITER;
+            h5->rx_count = 0;
+            break;
+        }
+    }
+}
+/**
+* Prepare h5 packet, packet format as follow:
+*  | LSB 4 octets  | 0 ~4095| 2 MSB
+*  |packet header | payload | data integrity check |
+*
+* pakcket header fromat is show below:
+*  | LSB 3 bits         | 3 bits             | 1 bits                       | 1 bits          |
+*  | 4 bits     | 12 bits        | 8 bits MSB
+*  |sequence number | acknowledgement number | data integrity check present | reliable packet |
+*  |packet type | payload length | header checksum
+*
+* @param h5 realtek h5 struct
+* @param data pure data
+* @param len the length of data
+* @param pkt_type packet type
+* @return socket buff after prepare in h5 proto
+*/
+static sk_buff * h5_prepare_pkt(tHCI_H5_CB *h5, uint8_t *data, signed long len, signed long pkt_type)
+{
+    sk_buff *nskb;
+    uint8_t hdr[4];
+    uint16_t H5_CRC_INIT(h5_txmsg_crc);
+    int rel, i;
+    H5LogMsg("HCI h5_prepare_pkt");
+
+    switch (pkt_type)
+    {
+    case HCI_ACLDATA_PKT:
+    case HCI_COMMAND_PKT:
+    case HCI_EVENT_PKT:
+    rel = 1;// reliable
+    break;
+    case H5_ACK_PKT:
+    case H5_VDRSPEC_PKT:
+    case H5_LINK_CTL_PKT:
+    rel = 0;// unreliable
+    break;
+    default:
+    ALOGE("Unknown packet type");
+    return NULL;
+    }
+
+    // Max len of packet: (original len +4(h5 hdr) +2(crc))*2
+    //   (because bytes 0xc0 and 0xdb are escaped, worst case is
+    //   when the packet is all made of 0xc0 and 0xdb :) )
+    //   + 2 (0xc0 delimiters at start and end).
+
+    nskb = skb_alloc((len + 6) * 2 + 2);
+    if (!nskb)
+    {
+        H5LogMsg("nskb is NULL");
+        return NULL;
+    }
+
+    //Add SLIP start byte: 0xc0
+    h5_slip_msgdelim(nskb);
+    // set AckNumber in SlipHeader
+    hdr[0] = h5->rxseq_txack << 3;
+    h5->is_txack_req = 0;
+
+    H5LogMsg("We request packet no(%u) to card", h5->rxseq_txack);
+    H5LogMsg("Sending packet with seqno %u and wait %u", h5->msgq_txseq, h5->rxseq_txack);
+    if (rel)
+    {
+        // set reliable pkt bit and SeqNumber
+        hdr[0] |= 0x80 + h5->msgq_txseq;
+        //H5LogMsg("Sending packet with seqno(%u)", h5->msgq_txseq);
+        ++(h5->msgq_txseq);
+        h5->msgq_txseq = (h5->msgq_txseq) & 0x07;
+    }
+
+    // set DicPresent bit
+    if (h5->use_crc)
+    hdr[0] |= 0x40;
+
+    // set packet type and payload length
+    hdr[1] = ((len << 4) & 0xff) | pkt_type;
+    hdr[2] = (uint8_t)(len >> 4);
+    // set checksum
+    hdr[3] = ~(hdr[0] + hdr[1] + hdr[2]);
+
+    // Put h5 header */
+    for (i = 0; i < 4; i++)
+    {
+        h5_slip_one_byte(nskb, hdr[i]);
+
+        if (h5->use_crc)
+            h5_crc_update(&h5_txmsg_crc, hdr[i]);
+    }
+
+    // Put payload */
+    for (i = 0; i < len; i++)
+    {
+        h5_slip_one_byte(nskb, data[i]);
+
+       if (h5->use_crc)
+       h5_crc_update(&h5_txmsg_crc, data[i]);
+    }
+
+    // Put CRC */
+    if (h5->use_crc)
+    {
+        h5_txmsg_crc = bit_rev16(h5_txmsg_crc);
+        h5_slip_one_byte(nskb, (uint8_t) ((h5_txmsg_crc >> 8) & 0x00ff));
+        h5_slip_one_byte(nskb, (uint8_t) (h5_txmsg_crc & 0x00ff));
+    }
+
+    // Add SLIP end byte: 0xc0
+    h5_slip_msgdelim(nskb);
+    return nskb;
+}
+/**
+* Removed controller acked packet from Host's unacked lists
+*
+* @param h5 realtek h5 struct
+*/
+static void h5_remove_acked_pkt(tHCI_H5_CB *h5)
+{
+    RT_LIST_HEAD* Head = NULL;
+    RT_LIST_ENTRY* Iter = NULL, *Temp = NULL;
+    RTK_BUFFER *skb = NULL;
+
+    int pkts_to_be_removed = 0;
+    int seqno = 0;
+    int i = 0;
+
+    pthread_mutex_lock(&h5_wakeup_mutex);
+
+    seqno = h5->msgq_txseq;
+    pkts_to_be_removed = RtbGetQueueLen(h5->unack);
+
+    while (pkts_to_be_removed)
+    {
+        if (h5->rxack == seqno)
+        break;
+
+        pkts_to_be_removed--;
+        seqno = (seqno - 1) & 0x07;
+    }
+
+    if (h5->rxack != seqno)
+    {
+        H5LogMsg("Peer acked invalid packet");
+    }
+
+
+    // remove ack'ed packet from bcsp->unack queue
+    i = 0;//  number of pkts has been removed from un_ack queue.
+    Head = (RT_LIST_HEAD *)(h5->unack);
+    LIST_FOR_EACH_SAFELY(Iter, Temp, Head)
+    {
+        skb = LIST_ENTRY(Iter, sk_buff, List);
+        if (i >= pkts_to_be_removed)
+            break;
+
+        skb_unlink(skb, h5->unack);
+        skb_free(&skb);
+        i++;
+    }
+
+    if (0 == skb_queue_get_length(h5->unack))
+    {
+        h5_stop_data_retrans_timer();
+        rtk_h5.data_retrans_count = 0;
+    }
+
+    if (i != pkts_to_be_removed)
+    {
+        H5LogMsg("Removed only (%u) out of (%u) pkts", i, pkts_to_be_removed);
+    }
+
+    pthread_mutex_unlock(&h5_wakeup_mutex);
+
+}
+
+/**
+* Realtek send pure ack, send a packet only with an ack
+*
+* @param fd uart file descriptor
+*
+*/
+
+static void hci_h5_send_pure_ack(void)
+{
+
+    //convert h4 data to h5
+    uint16_t bytes_sent = 0;
+
+    sk_buff *nskb = h5_prepare_pkt(&rtk_h5, NULL, 0, H5_ACK_PKT);
+    if(nskb == NULL)
+    {
+        ALOGE("h5_prepare_pkt allocate memory fail");
+        return;
+    }
+    H5LogMsg("H5: --->>>send pure ack");
+    uint8_t * data = skb_get_data(nskb);
+
+#if H5_TRACE_DATA_ENABLE
+    {
+        uint32_t iTemp = 0;
+        uint32_t iTempTotal = 16;
+
+        H5LogMsg("H5 TX: length(%d)", skb_get_data_length(nskb));
+        if(iTempTotal > skb_get_data_length(nskb))
+        {
+            iTempTotal = skb_get_data_length(nskb);
+        }
+
+        for(iTemp = 0; iTemp < iTempTotal; iTemp++)
+        {
+            H5LogMsg("0x%x", data[iTemp]);
+        }
+    }
+#endif
+
+    bytes_sent = hal->transmit_data(DATA_TYPE_H5, data, skb_get_data_length(nskb));
+    H5LogMsg("bytes_sent(%d)", bytes_sent);
+
+    skb_free(&nskb);
+
+    return;
+
+}
+
+static void hci_h5_send_sync_req()
+{
+    uint16_t bytes_sent = 0;
+    unsigned char    h5sync[2]     = {0x01, 0x7E};
+
+    sk_buff *nskb = h5_prepare_pkt(&rtk_h5, h5sync, sizeof(h5sync), H5_LINK_CTL_PKT);
+    if(nskb == NULL)
+    {
+        ALOGE("h5_prepare_pkt allocate memory fail");
+        return;
+    }
+    H5LogMsg("H5: --->>>send sync req");
+    uint8_t * data = skb_get_data(nskb);
+
+#if H5_TRACE_DATA_ENABLE
+    {
+        uint32_t iTemp = 0;
+        uint32_t iTempTotal = 16;
+        H5LogMsg("H5 TX: length(%d)", skb_get_data_length(nskb));
+        if(iTempTotal > skb_get_data_length(nskb))
+        {
+            iTempTotal = skb_get_data_length(nskb);
+        }
+        for(iTemp = 0; iTemp < iTempTotal; iTemp++)
+        {
+            H5LogMsg("0x%x", data[iTemp]);
+        }
+    }
+#endif
+
+    bytes_sent = hal->transmit_data(DATA_TYPE_H5, data, skb_get_data_length(nskb));
+    H5LogMsg("bytes_sent(%d)", bytes_sent);
+
+    skb_free(&nskb);
+
+    return;
+}
+
+static void hci_h5_send_sync_resp()
+{
+    uint16_t bytes_sent = 0;
+    unsigned char h5syncresp[2] = {0x02, 0x7D};
+
+    sk_buff *nskb = h5_prepare_pkt(&rtk_h5, h5syncresp, sizeof(h5syncresp), H5_LINK_CTL_PKT);
+    if(nskb == NULL)
+    {
+        ALOGE("h5_prepare_pkt allocate memory fail");
+        return;
+    }
+    H5LogMsg("H5: --->>>send sync resp");
+    uint8_t * data = skb_get_data(nskb);
+
+#if H5_TRACE_DATA_ENABLE
+    {
+        uint32_t iTemp = 0;
+        uint32_t iTempTotal = 16;
+        H5LogMsg("H5 TX: length(%d)", skb_get_data_length(nskb));
+        if(iTempTotal > skb_get_data_length(nskb))
+        {
+            iTempTotal = skb_get_data_length(nskb);
+        }
+        for(iTemp = 0; iTemp < iTempTotal; iTemp++)
+        {
+            H5LogMsg("0x%x", data[iTemp]);
+        }
+    }
+#endif
+
+    bytes_sent = hal->transmit_data(DATA_TYPE_H5, data, skb_get_data_length(nskb));
+    H5LogMsg("bytes_sent(%d)", bytes_sent);
+
+    skb_free(&nskb);
+
+    return;
+}
+
+static void hci_h5_send_conf_req()
+{
+    uint16_t bytes_sent = 0;
+    unsigned char h5conf[3] = {0x03, 0xFC, 0x14};
+
+    sk_buff *nskb = h5_prepare_pkt(&rtk_h5, h5conf, sizeof(h5conf), H5_LINK_CTL_PKT);
+    if(nskb == NULL)
+    {
+        ALOGE("h5_prepare_pkt allocate memory fail");
+        return;
+    }
+    H5LogMsg("H5: --->>>send conf req");
+    uint8_t * data = skb_get_data(nskb);
+
+#if H5_TRACE_DATA_ENABLE
+    {
+        uint32_t iTemp = 0;
+        uint32_t iTempTotal = 16;
+        H5LogMsg("H5 TX: length(%d)", skb_get_data_length(nskb));
+        if(iTempTotal > skb_get_data_length(nskb))
+        {
+            iTempTotal = skb_get_data_length(nskb);
+        }
+        for(iTemp = 0; iTemp < iTempTotal; iTemp++)
+        {
+            H5LogMsg("0x%x", data[iTemp]);
+        }
+    }
+#endif
+
+    bytes_sent = hal->transmit_data(DATA_TYPE_H5, data, skb_get_data_length(nskb));
+    H5LogMsg("bytes_sent(%d)", bytes_sent);
+
+    skb_free(&nskb);
+
+    return;
+}
+
+
+static void hci_h5_send_conf_resp()
+{
+    uint16_t bytes_sent = 0;
+    unsigned char h5confresp[2] = {0x04, 0x7B};
+
+    sk_buff *nskb = h5_prepare_pkt(&rtk_h5, h5confresp, sizeof(h5confresp), H5_LINK_CTL_PKT);
+    if(nskb == NULL)
+    {
+        ALOGE("h5_prepare_pkt allocate memory fail");
+        return;
+    }
+    H5LogMsg("H5: --->>>send conf resp");
+    uint8_t * data = skb_get_data(nskb);
+
+#if H5_TRACE_DATA_ENABLE
+    {
+        uint32_t iTemp = 0;
+        uint32_t iTempTotal = 16;
+        H5LogMsg("H5 TX: length(%d)", skb_get_data_length(nskb));
+        if(iTempTotal > skb_get_data_length(nskb))
+        {
+            iTempTotal = skb_get_data_length(nskb);
+        }
+        for(iTemp = 0; iTemp < iTempTotal; iTemp++)
+        {
+            H5LogMsg("0x%x", data[iTemp]);
+        }
+    }
+#endif
+
+    bytes_sent = hal->transmit_data(DATA_TYPE_H5, data, skb_get_data_length(nskb));
+    H5LogMsg("bytes_sent(%d)", bytes_sent);
+
+    skb_free(&nskb);
+
+    return;
+}
+
+static void rtk_notify_hw_h5_init_result(uint8_t result)
+{
+#if 0
+        uint16_t len = 0;
+        HC_BT_HDR *pH5InitResultPkt = NULL;
+        uint8_t * p = NULL;
+        unsigned char h5InitOk[6] = {0x0e, 0x04, 0x02, 0xEE, 0xFC, 0x00};
+
+        /* Allocate a buffer for message */
+        if (bt_hc_cbacks)
+        {
+            len = BT_HC_HDR_SIZE + sizeof(h5InitOk);
+            pH5InitResultPkt = (HC_BT_HDR *) bt_hc_cbacks->alloc(len);
+        }
+
+        if (pH5InitResultPkt)
+        {
+            /* Initialize buffer with received h5 data */
+            pH5InitResultPkt->offset = 0;
+            pH5InitResultPkt->layer_specific = 0;
+            pH5InitResultPkt->event = MSG_STACK_TO_HC_HCI_CMD;
+            pH5InitResultPkt->len = sizeof(h5InitOk);
+
+            memcpy((uint8_t *)(pH5InitResultPkt + 1), h5InitOk, sizeof(h5InitOk));
+
+#endif
+            ALOGE("rtk no alloc in init result");
+            if(rtk_h5.cback_h5sync)
+                rtk_h5.cback_h5sync(NULL);
+
+     //   }
+
+}
+
+
+static sk_buff *
+h5_dequeue(
+    )
+{
+    sk_buff *skb = NULL;
+    //   First of all, check for unreliable messages in the queue,
+    //   since they have higher priority
+    H5LogMsg("h5_dequeue++");
+    if ((skb = (sk_buff*)skb_dequeue_head(rtk_h5.unrel)) != NULL)
+    {
+        H5LogMsg("h5_dequeue11");
+        sk_buff *nskb = h5_prepare_pkt(&rtk_h5,
+                                         skb_get_data(skb),
+                                         skb_get_data_length(skb),
+                                         skb_get_pkt_type(skb));
+        if (nskb)
+        {
+            H5LogMsg("h5_dequeue12");
+            skb_free(&skb);
+            return nskb;
+        }
+        else
+        {
+            H5LogMsg("h5_dequeue13");
+            skb_queue_head(rtk_h5.unrel, skb);
+        }
+    }
+    //   Now, try to send a reliable pkt. We can only send a
+    //   reliable packet if the number of packets sent but not yet ack'ed
+    //   is < than the winsize
+
+//    H5LogMsg("RtbGetQueueLen(rtk_h5.unack) = (%d), sliding_window_size = (%d)", RtbGetQueueLen(rtk_h5.unack), rtk_h5.sliding_window_size);
+
+    if (RtbGetQueueLen(rtk_h5.unack)< rtk_h5.sliding_window_size &&
+        (skb = (sk_buff *)skb_dequeue_head(rtk_h5.rel)) != NULL)
+    {
+        H5LogMsg("h5_dequeue21");
+        sk_buff *nskb = h5_prepare_pkt(&rtk_h5,
+                                         skb_get_data(skb),
+                                         skb_get_data_length(skb),
+                                         skb_get_pkt_type(skb));
+        if (nskb)
+        {
+            H5LogMsg("h5_dequeue22");
+            skb_queue_tail(rtk_h5.unack, skb);
+            h5_start_data_retrans_timer();
+            H5LogMsg("h5_dequeue23");
+            return nskb;
+        }
+        else
+        {
+            H5LogMsg("h5_dequeue24");
+            skb_queue_head(rtk_h5.rel, skb);
+        }
+    }
+    //   We could not send a reliable packet, either because there are
+    //   none or because there are too many unack'ed packets. Did we receive
+    //   any packets we have not acknowledged yet
+    H5LogMsg("h5_dequeue3");
+    if (rtk_h5.is_txack_req)
+    {
+        // if so, craft an empty ACK pkt and send it on BCSP unreliable
+        // channel
+        sk_buff *nskb = h5_prepare_pkt(&rtk_h5, NULL, 0, H5_ACK_PKT);
+        return nskb;
+    }
+    // We have nothing to send
+    H5LogMsg("h5_dequeue4");
+    return NULL;
+}
+
+int
+h5_enqueue(
+    IN sk_buff *skb
+    )
+{
+    //Pkt length must be less than 4095 bytes
+    if (skb_get_data_length(skb) > 0xFFF)
+    {
+        ALOGE("skb len > 0xFFF");
+        skb_free(&skb);
+        return 0;
+    }
+
+    switch (skb_get_pkt_type(skb))
+    {
+    case HCI_ACLDATA_PKT:
+    case HCI_COMMAND_PKT:
+        skb_queue_tail(rtk_h5.rel, skb);
+        break;
+
+
+    case H5_LINK_CTL_PKT:
+    case H5_ACK_PKT:
+    case H5_VDRSPEC_PKT:
+        skb_queue_tail(rtk_h5.unrel, skb);/* 3-wire LinkEstablishment*/
+        break;
+    default:
+        skb_free(&skb);
+        break;
+    }
+    return 0;
+}
+
+
+static void h5_wake_up()
+{
+    uint16_t bytes_sent = 0;
+    sk_buff *skb = NULL;
+    uint8_t * data = NULL;
+    uint32_t data_len = 0;
+
+    pthread_mutex_lock(&h5_wakeup_mutex);
+    H5LogMsg("h5_wake_up++");
+    while (NULL != (skb = h5_dequeue()))
+    {
+        data = skb_get_data(skb);
+        data_len = skb_get_data_length(skb);
+        //we adopt the hci_h5 interface to send data
+        bytes_sent = hal->transmit_data(DATA_TYPE_H5, data, data_len);
+//      bytes_sent = userial_write(0, data, data_len);
+
+        H5LogMsg("bytes_sent(%d)", bytes_sent);
+
+#if H5_TRACE_DATA_ENABLE
+        {
+            uint32_t iTemp = 0;
+            uint32_t iTempTotal = 16;
+            H5LogMsg("H5 TX: length(%d)", data_len);
+            if(iTempTotal > data_len)
+            {
+                iTempTotal = data_len;
+            }
+            for(iTemp = 0; iTemp < iTempTotal; iTemp++)
+            {
+                H5LogMsg("0x%x", data[iTemp]);
+            }
+        }
+#endif
+        skb_free(&skb);
+    }
+    H5LogMsg("h5_wake_up--");
+
+    pthread_mutex_unlock(&h5_wakeup_mutex);
+}
+
+
+/*******************************************************************************
+**
+** Function         acl_rx_frame_end_chk
+**
+** Description      This function is called from the HCI transport when the last
+**                  byte of an HCI ACL packet has been received. It checks if
+**                  the L2CAP message is complete, i.e. no more continuation
+**                  packets are expected.
+**
+** Returns          TRUE if message complete, FALSE if continuation expected
+**
+*******************************************************************************/
+static uint8_t acl_rx_frame_end_chk (sk_buff * skb_acl)
+{
+    uint8_t     *data;
+    uint16_t   data_len = 0;
+
+    uint16_t    handle, hci_len, l2cap_len;
+
+    uint8_t     frame_end=TRUE;
+
+
+    data = skb_get_data(skb_acl);
+    data_len = skb_get_data_length(skb_acl);
+    if(data_len < 6)
+    {
+        frame_end = FALSE;
+        return frame_end;
+    }
+
+    STREAM_TO_UINT16 (handle, data);
+    STREAM_TO_UINT16 (hci_len, data);
+    STREAM_TO_UINT16 (l2cap_len, data);
+    H5LogMsg("handle(0x%x), hci_len(%d), l2cap_len(%d)", handle, hci_len, l2cap_len);
+
+    if (hci_len > 0)
+    {
+        if (l2cap_len > (data_len - (HCI_ACL_PREAMBLE_SIZE+L2CAP_HEADER_SIZE)) )
+        {
+            /* If the L2CAP length has not been reached, tell H5 not to send
+             * this buffer to stack */
+            frame_end = FALSE;
+            H5LogMsg("H5: L2CAP fragment PKT, data_len(%d)", data_len);
+        }
+        else
+        {
+            H5LogMsg("H5: L2CAP Complete PKT, data_len(%d)", data_len);
+        }
+    }
+
+    return frame_end;
+}
+
+void h5_process_ctl_pkts(void)
+{
+    //process h5 link establish
+    int len;
+    uint8_t cfg;
+
+    tHCI_H5_CB *p_cb = &rtk_h5;
+    sk_buff * skb = rtk_h5.rx_skb;
+
+    unsigned char    h5sync[2]     = {0x01, 0x7E},
+                            h5syncresp[2] = {0x02, 0x7D},
+                            h5conf[3]     = {0x03, 0xFC, 0x14},
+                            h5confresp[2] = {0x04, 0x7B},
+                            h5InitOk[2] = {0xF1, 0xF1};
+
+    uint8_t *ph5_payload = NULL;
+    ph5_payload = (uint8_t *)(p_cb->p_rcv_msg + 1);
+
+
+    if(rtk_h5.link_estab_state == H5_UNINITIALIZED) {  //sync
+        if (!memcmp(skb_get_data(skb), h5sync, 2))
+        {
+            H5LogMsg("H5: <<<---recv sync req");
+            hci_h5_send_sync_resp();
+        }
+        else if (!memcmp(skb_get_data(skb), h5syncresp, 2))
+        {
+            H5LogMsg("H5: <<<---recv sync resp");
+            h5_stop_sync_retrans_timer();
+            rtk_h5.sync_retrans_count  = 0;
+            rtk_h5.link_estab_state = H5_INITIALIZED;
+
+              //send config req
+              hci_h5_send_conf_req();
+              h5_start_conf_retrans_timer();
+        }
+
+    }
+    else if(rtk_h5.link_estab_state == H5_INITIALIZED) {  //config
+        if (!memcmp(skb_get_data(skb), h5sync, 0x2)) {
+
+            H5LogMsg("H5: <<<---recv sync req in H5_INITIALIZED");
+            hci_h5_send_sync_resp();
+        }
+        else if (!memcmp(skb_get_data(skb), h5conf, 0x2)) {
+             H5LogMsg("H5: <<<---recv conf req");
+             hci_h5_send_conf_resp();
+        }
+        else if (!memcmp(skb_get_data(skb), h5confresp,  0x2)) {
+            H5LogMsg("H5: <<<---recv conf resp");
+            h5_stop_conf_retrans_timer();
+            rtk_h5.conf_retrans_count  = 0;
+
+            rtk_h5.link_estab_state = H5_ACTIVE;
+            //notify hw to download patch
+            memcpy(&cfg, skb_get_data(skb)+2, H5_CFG_SIZE);
+            rtk_h5.sliding_window_size = H5_CFG_SLID_WIN(cfg);
+            rtk_h5.oof_flow_control = H5_CFG_OOF_CNTRL(cfg);
+            rtk_h5.dic_type = H5_CFG_DIC_TYPE(cfg);
+            H5LogMsg("rtk_h5.sliding_window_size(%d), oof_flow_control(%d), dic_type(%d)",
+            rtk_h5.sliding_window_size, rtk_h5.oof_flow_control, rtk_h5.dic_type);
+         if(rtk_h5.dic_type)
+            rtk_h5.use_crc = 1;
+
+            rtk_notify_hw_h5_init_result(1);
+        }
+        else {
+            H5LogMsg("H5_INITIALIZED receive event, ingnore");
+        }
+    }
+    else if(rtk_h5.link_estab_state == H5_ACTIVE) {
+        if (!memcmp(skb_get_data(skb), h5sync, 0x2)) {
+
+            H5LogMsg("H5: <<<---recv sync req in H5_ACTIVE");
+            kill(getpid(), SIGKILL);
+            hci_h5_send_sync_resp();
+            H5LogMsg("H5 : H5_ACTIVE transit to H5_UNINITIALIZED");
+            rtk_h5.link_estab_state = H5_UNINITIALIZED;
+            hci_h5_send_sync_req();
+            h5_start_sync_retrans_timer();
+        }
+        else if (!memcmp(skb_get_data(skb), h5conf, 0x2)) {
+             H5LogMsg("H5: <<<---recv conf req in H5_ACTIVE");
+             hci_h5_send_conf_resp();
+        }
+        else if (!memcmp(skb_get_data(skb), h5confresp,  0x2)) {
+            H5LogMsg("H5: <<<---recv conf resp in H5_ACTIVE, discard");
+        }
+        else {
+            H5LogMsg("H5_ACTIVE receive unknown link control msg, ingnore");
+        }
+
+    }
+}
+
+uint8_t isRtkInternalCommand(uint16_t opcode)
+{
+    if(opcode == 0xFC17
+        || opcode == 0xFC6D
+        || opcode == 0xFC61
+        || opcode == 0xFC20)
+    {
+        return 1;
+    }
+    else
+    {
+        return 0;
+    }
+
+}
+
+/*******************************************************************************
+**
+** Function         internal_event_intercept_h5
+**
+** Description      This function is called to parse received HCI event and
+**                  - update the Num_HCI_Command_Packets
+**                  - intercept the event if it is the result of an early
+**                    issued internal command.
+**
+** Returns          TRUE : if the event had been intercepted for internal process
+**                  FALSE : send this event to core stack
+**
+*******************************************************************************/
+uint8_t internal_event_intercept_h5(void)
+{
+    uint8_t internal_command = 0;//if it is internal event, you need to set internal_command = 1;
+    bool h5_int_command = 0;//if it the H5 int command like H5 vendor cmd or Coex cmd h5_int_command=1;
+    tHCI_H5_CB *p_cb = &rtk_h5;
+    sk_buff * skb = rtk_h5.rx_skb;
+    uint8_t *ph5_payload = NULL;
+    ph5_payload = (uint8_t *)(p_cb->p_rcv_msg + 1);
+
+    //process fw change baudrate and patch download
+    uint8_t     *p;
+    uint8_t     event_code;
+    uint16_t    opcode, len;
+    p = (uint8_t *)(p_cb->p_rcv_msg + 1);
+/*BOARD_HAVE_BLUETOOTH_RTK_COEX begin*/
+#ifdef BLUETOOTH_RTK_COEX
+    rtk_parse_internal_event_intercept(p);
+#endif
+/*BOARD_HAVE_BLUETOOTH_RTK_COEX end*/
+
+    event_code = *p++;
+    len = *p++;
+    H5LogMsg("event_code(0x%x)", event_code);
+#if 1
+    if (event_code == HCI_COMMAND_COMPLETE_EVT)
+    {
+        internal_command = 1;
+        num_hci_cmd_pkts = *p++;
+        STREAM_TO_UINT16(opcode, p);
+        H5LogMsg("event_code(0x%x)  opcode (0x%x) p_cb->int_cmd_rsp_pending %d", event_code,opcode,p_cb->int_cmd_rsp_pending);
+    if (opcode == HCI_READ_BUFFER_SIZE)
+    {
+        uint8_t status = 0;
+        status = *p++;
+        if (status == 0)
+        {
+            uint16_t   hc_acl_data_size = 0;
+            uint8_t   hc_sco_data_size = 0;
+            uint16_t hc_acl_total_num = 0;
+            uint16_t hc_sco_total_num = 0;
+
+            STREAM_TO_UINT16(hc_acl_data_size, p)
+            hc_sco_data_size = *p++;
+            STREAM_TO_UINT16(hc_acl_total_num, p);
+            STREAM_TO_UINT16(hc_sco_total_num, p);
+
+            rtk_h5.hc_acl_data_size = hc_acl_data_size;
+            rtk_h5.hc_sco_data_size = hc_sco_data_size;
+            rtk_h5.hc_acl_total_num = hc_acl_total_num;
+            rtk_h5.hc_sco_total_num = hc_sco_total_num;
+
+            H5LogMsg("hc_acl_data_size:(%d), hc_sco_data_size:(%d), hc_acl_total_num:(%d), hc_sco_total_num(%d)", \
+            hc_acl_data_size, hc_sco_data_size, hc_acl_total_num, hc_sco_total_num);
+
+            rtk_h5.hc_cur_acl_total_num = hc_acl_total_num;
+        }
+    }
+    else
+    if (opcode == HCI_LE_READ_BUFFER_SIZE)
+    {
+        uint8_t status = 0;
+        status = *p++;
+        if (status == 0)
+        {
+            uint16_t   hc_ble_acl_data_size = 0;
+            uint8_t hc_ble_acl_total_num = 0;
+
+            STREAM_TO_UINT16(hc_ble_acl_data_size, p)
+            hc_ble_acl_total_num = *p++;
+            rtk_h5.hc_ble_acl_data_size = (hc_ble_acl_data_size) ? hc_ble_acl_data_size : rtk_h5.hc_acl_data_size;
+            rtk_h5.hc_ble_acl_total_num = hc_ble_acl_total_num;
+            H5LogMsg("hc_ble_acl_data_size:(%d), hc_ble_acl_total_num:(%d)",  \
+            hc_ble_acl_data_size, hc_ble_acl_total_num);
+        }
+    }
+
+        if (p_cb->int_cmd_rsp_pending > 0)
+        {
+            H5LogMsg("CommandCompleteEvent for command (0x%04X)", opcode);
+            if (opcode == p_cb->int_cmd[p_cb->int_cmd_rd_idx].opcode)
+            {
+                //ONLY HANDLE H5 INIT CMD COMMAND COMPLETE EVT
+                h5_int_command = 1;
+                H5LogMsg("CommandCompleteEvent for command 1 (0x%04X)", opcode);
+                if(opcode == 0xFC17)
+                {
+                    //need to set a timer, add wait for retransfer packet from controller.
+                    //if there is no packet rx from controller, we can assure baudrate change success.
+                    H5LogMsg("CommandCompleteEvent for command 2 h5_start_wait_controller_baudrate_ready_timer (0x%04X)", opcode);
+                    h5_start_wait_controller_baudrate_ready_timer();
+                }
+                else
+                {
+
+                    if (p_cb->int_cmd[p_cb->int_cmd_rd_idx].cback != NULL)
+                    {
+                        H5LogMsg("CommandCompleteEvent for command (0x%04X) p_cb->int_cmd[p_cb->int_cmd_rd_idx].cback(p_cb->p_rcv_msg)", opcode);
+                        p_cb->int_cmd[p_cb->int_cmd_rd_idx].cback(p_cb->p_rcv_msg);
+                    }
+                    else
+                    {
+                        H5LogMsg("CommandCompleteEvent for command Missing cback function buffer_allocator->free(p_cb->p_rcv_msg) (0x%04X)", opcode);
+                        buffer_allocator->free(p_cb->p_rcv_msg);
+                    }
+                }
+
+                p_cb->int_cmd_rd_idx = ((p_cb->int_cmd_rd_idx+1) & INT_CMD_PKT_IDX_MASK);
+                p_cb->int_cmd_rsp_pending--;
+            }
+        }
+        if(!h5_int_command)
+            hci_layer_callbacks->filter_incoming_event(p_cb->p_rcv_msg);
+    }
+#endif
+#if 0
+    if (event_code == HCI_COMMAND_COMPLETE_EVT)
+    {
+        internal_command = 1;
+        num_hci_cmd_pkts = *p++;
+        STREAM_TO_UINT16(opcode, p);
+        H5LogMsg("event_code(0x%x)  opcode (0x%x) p_cb->int_cmd_rsp_pending %d", event_code,opcode,p_cb->int_cmd_rsp_pending);
+        //1. Hanle  H5 INIT CMD COMMAND COMPLETE EVT 2 . Others
+        if (p_cb->int_cmd_rsp_pending > 0) {
+            H5LogMsg("CommandCompleteEvent for command (0x%04X) p_cb->int_cmd[p_cb->int_cmd_rd_idx].opcode (0x%04X)", opcode ,p_cb->int_cmd[p_cb->int_cmd_rd_idx].opcode);
+            if (opcode == p_cb->int_cmd[p_cb->int_cmd_rd_idx].opcode) {
+                //ONLY HANDLE H5 INIT CMD COMMAND COMPLETE EVT
+                h5_int_command = 1;
+                if(opcode == 0xFC17)
+                {
+                    //need to set a timer, add wait for retransfer packet from controller.
+                    //if there is no packet rx from controller, we can assure baudrate change success.
+                    h5_start_wait_controller_baudrate_ready_timer();
+                    internal_command = 1;
+                }
+                else
+                {
+                    if(opcode == 0xFC6D)
+                        internal_command = 1;
+
+                    if (p_cb->int_cmd[p_cb->int_cmd_rd_idx].cback != NULL)
+                    {
+                        H5LogMsg("CommandCompleteEvent for command (0x%04X) p_cb->int_cmd[p_cb->int_cmd_rd_idx].cback(p_cb->p_rcv_msg)", opcode);
+                        p_cb->int_cmd[p_cb->int_cmd_rd_idx].cback(p_cb->p_rcv_msg);
+                    }
+                    else
+                    {
+                        // Missing cback function!
+                        // Release the p_rcv_msg buffer.
+                        H5LogMsg("CommandCompleteEvent for command Missing cback function buffer_allocator->free(p_cb->p_rcv_msg) (0x%04X)", opcode);
+                        buffer_allocator->free(p_cb->p_rcv_msg);
+                    }
+                }
+
+                p_cb->int_cmd_rd_idx = ((p_cb->int_cmd_rd_idx+1) & INT_CMD_PKT_IDX_MASK);
+                p_cb->int_cmd_rsp_pending--;
+            }
+        }else {
+            if (opcode == HCI_READ_BUFFER_SIZE) {
+            uint8_t status = 0;
+            status = *p++;
+            if (status == 0){
+                uint16_t   hc_acl_data_size = 0;
+                uint8_t   hc_sco_data_size = 0;
+                uint16_t hc_acl_total_num = 0;
+                uint16_t hc_sco_total_num = 0;
+
+                STREAM_TO_UINT16(hc_acl_data_size, p)
+                hc_sco_data_size = *p++;
+                STREAM_TO_UINT16(hc_acl_total_num, p);
+                STREAM_TO_UINT16(hc_sco_total_num, p);
+
+                rtk_h5.hc_acl_data_size = hc_acl_data_size;
+                rtk_h5.hc_sco_data_size = hc_sco_data_size;
+                rtk_h5.hc_acl_total_num = hc_acl_total_num;
+                rtk_h5.hc_sco_total_num = hc_sco_total_num;
+
+                H5LogMsg("hc_acl_data_size:(%d), hc_sco_data_size:(%d), hc_acl_total_num:(%d), hc_sco_total_num(%d)", \
+                hc_acl_data_size, hc_sco_data_size, hc_acl_total_num, hc_sco_total_num);
+
+                rtk_h5.hc_cur_acl_total_num = hc_acl_total_num;
+            }
+        }else if (opcode == HCI_LE_READ_BUFFER_SIZE){
+            uint8_t status = 0;
+            status = *p++;
+            if (status == 0){
+                uint16_t   hc_ble_acl_data_size = 0;
+                uint8_t hc_ble_acl_total_num = 0;
+
+                STREAM_TO_UINT16(hc_ble_acl_data_size, p)
+                hc_ble_acl_total_num = *p++;
+                rtk_h5.hc_ble_acl_data_size = (hc_ble_acl_data_size) ? hc_ble_acl_data_size : rtk_h5.hc_acl_data_size;
+                rtk_h5.hc_ble_acl_total_num = hc_ble_acl_total_num;
+                H5LogMsg("hc_ble_acl_data_size:(%d), hc_ble_acl_total_num:(%d)",  \
+                hc_ble_acl_data_size, hc_ble_acl_total_num);
+            }
+        }
+        }
+        //Cmd comp event and status event callback
+        if(h5_int_command == 0)
+            hci_layer_callbacks->filter_incoming_event(p_cb->p_rcv_msg);
+    }
+#endif
+    else if (event_code == HCI_COMMAND_STATUS_EVT)
+    {
+        internal_command = 1;
+        num_hci_cmd_pkts = *(++p);
+        STREAM_TO_UINT16(opcode, p);
+
+        hci_layer_callbacks->filter_incoming_event(p_cb->p_rcv_msg);
+    }
+    else if(event_code == HCI_NUM_OF_CMP_PKTS_EVT)
+    {
+        uint8_t i = 0;
+        uint8_t num_of_handle =  *p++;
+        uint16_t handle = 0;
+        uint16_t NumOcp = 0;
+        uint8_t *phandle_list  = NULL;
+        uint8_t *pNocp_list = NULL;
+        HCI_CONN *phci_conn = NULL;
+
+        phandle_list = p;
+        pNocp_list = p + num_of_handle*sizeof(handle);
+
+        if (len < num_of_handle*4+sizeof(num_of_handle))
+        {
+            ALOGE("len is error");
+            internal_command = 0;
+            return internal_command;
+        }
+
+        for (i = 0; i< num_of_handle; i++)
+        {
+            STREAM_TO_UINT16(handle, phandle_list)
+            phci_conn = ConnHashLookupByHandle(&rtk_h5, handle);
+            if (phci_conn)
+            {
+                STREAM_TO_UINT16(NumOcp, pNocp_list)
+                H5LogMsg("NumOcp(%d), hc_cur_acl_total_num(%d)", NumOcp, rtk_h5.hc_cur_acl_total_num);
+                rtk_h5.hc_cur_acl_total_num += NumOcp;
+                phci_conn->NumOfNotCmpAclPkts -= NumOcp;
+
+                //queue data to h5 to send
+                while(rtk_h5.hc_cur_acl_total_num>0
+                &&(NULL != (skb = skb_dequeue_head(phci_conn->pending_pkts))) )
+                {
+                    h5_enqueue(skb);
+                    rtk_h5.hc_cur_acl_total_num--;
+                    phci_conn->NumOfNotCmpAclPkts++;
+                    h5_wake_up();
+                }
+
+            }
+        }
+
+    }
+    else if(event_code == HCI_CONNECTION_COMP_EVT)
+    {
+        uint8_t status = 0;
+        uint16_t handle = 0;
+        bdaddr_t bd_addr ;
+        uint8_t link_type = 0;
+        uint8_t encrypt_enabled = 0;
+
+        HCI_CONN * hci_conn = NULL;
+
+        status = *p++;
+        STREAM_TO_UINT16 (handle, p);
+        memcpy(&bd_addr, p, 6);
+        p +=6;
+        link_type = *p++;
+        encrypt_enabled = *p;
+
+        H5LogMsg("CCP EVT: status(%d), handle(0x%x), link_type(0x%x), encrypt_enabled(%d)", status, handle, link_type, encrypt_enabled);
+        baPrint(bd_addr);
+
+        if(status == 0)
+        {
+            hci_conn = ConnHashLookupByHandle(&rtk_h5, handle);
+            if(hci_conn == NULL)
+            {
+                hci_conn = HciConnAllocate(handle);
+                if(hci_conn)
+                {
+                    ConnHashAdd(&rtk_h5, hci_conn);
+                    bacpy(&hci_conn->bd_addr, &bd_addr);
+                    hci_conn->link_type = link_type;
+                    hci_conn->encrypt_enabled = encrypt_enabled;
+                    hci_conn->NumOfNotCmpAclPkts = 0;
+
+                }
+                else
+                {
+                    ALOGE("HciConnAllocate fail");
+                }
+            }
+            else
+            {
+                ALOGE("HCI Connection handle(0x%x) has already exist!", handle);
+                bacpy(&hci_conn->bd_addr, &bd_addr);
+                hci_conn->link_type = link_type;
+                hci_conn->encrypt_enabled = encrypt_enabled;
+                hci_conn->NumOfNotCmpAclPkts = 0;
+
+            }
+            H5LogMsg("hc_cur_acl_total_num(%d)", rtk_h5.hc_cur_acl_total_num);
+        }
+
+    }
+    //add for le connection start
+    else if(event_code == HCI_BLE_EVT)
+    {
+        uint8_t status = 0;
+        uint16_t handle = 0;
+        bdaddr_t bd_addr ;
+        uint8_t link_type = 0;
+        uint8_t encrypt_enabled = 0;
+        uint8_t role;
+        uint8_t addr_type;
+        uint8_t ble_sub_code;
+
+        HCI_CONN * hci_conn = NULL;
+        ble_sub_code = *p++;
+        H5LogMsg("HCI_BLE_EVT with sub event code 0x%x", ble_sub_code);
+        if(ble_sub_code != 0x01)
+            return 0;
+        status = *p++;
+        STREAM_TO_UINT16 (handle, p);
+        p += 2;
+        memcpy(&bd_addr, p, 6);
+        p +=6;
+        baPrint(bd_addr);
+
+        if(status == 0)
+        {
+            hci_conn = ConnHashLookupByHandle(&rtk_h5, handle);
+            if(hci_conn == NULL)
+            {
+                hci_conn = HciConnAllocate(handle);
+                if(hci_conn)
+                {
+                    ConnHashAdd(&rtk_h5, hci_conn);
+                    bacpy(&hci_conn->bd_addr, &bd_addr);
+                    hci_conn->link_type = link_type;
+                    hci_conn->encrypt_enabled = encrypt_enabled;
+                    hci_conn->NumOfNotCmpAclPkts = 0;
+
+                }
+                else
+                {
+                    ALOGE("HciConnAllocate fail");
+                }
+            }
+            else
+            {
+                ALOGE("HCI Connection handle(0x%x) has already exist!", handle);
+                bacpy(&hci_conn->bd_addr, &bd_addr);
+                hci_conn->link_type = link_type;
+                hci_conn->encrypt_enabled = encrypt_enabled;
+                hci_conn->NumOfNotCmpAclPkts = 0;
+
+            }
+            ALOGI("hc_cur_acl_total_num(%d)", rtk_h5.hc_cur_acl_total_num);
+        }
+
+    }
+    //add for le connection end
+    else if(event_code == HCI_DISCONNECTION_COMP_EVT)
+    {
+        uint8_t status = 0;
+        uint16_t handle = 0;
+        uint8_t reason = 0;
+        HCI_CONN * hci_conn = NULL;
+        status = *p++;
+        STREAM_TO_UINT16(handle, p);
+        reason = *p;
+        H5LogMsg("DCP EVT: status(%d), handle(0x%x), reason(0x%x)", status, handle, reason);
+        H5LogMsg("hc_cur_acl_total_num(%d)", rtk_h5.hc_cur_acl_total_num);
+        {
+            hci_conn = ConnHashLookupByHandle(&rtk_h5, handle);
+            if(hci_conn)
+            {
+                rtk_h5.hc_cur_acl_total_num += hci_conn->NumOfNotCmpAclPkts;
+                H5LogMsg("hc_cur_acl_total_num(%d)", rtk_h5.hc_cur_acl_total_num);
+                ConnHashDelete(hci_conn);
+            }
+            else
+            {
+                ALOGE("HCI Connection handle(0x%x) not found", handle);
+            }
+        }
+    }
+
+    return internal_command;
+
+}
+
+
+/**
+* Check if it's a hci frame, if it is, complete it with response or parse the cmd complete event
+*
+* @param skb socket buffer
+*
+*/
+static void hci_recv_frame(sk_buff *skb, uint8_t pkt_type)
+{
+    uint8_t intercepted = FALSE;
+    uint32_t i = 0 ;
+    uint8_t *data = skb_get_data(skb);
+    uint32_t data_len = skb_get_data_length(skb);
+
+    H5LogMsg("UART H5 RX: length = %d", data_len);
+
+#if H5_TRACE_DATA_ENABLE
+    {
+        uint32_t iTemp = 0;
+        uint32_t iTempTotal = 16;
+        H5LogMsg("H5 RX: length(%d)", data_len);
+        if(iTempTotal > data_len)
+        {
+            iTempTotal = data_len;
+        }
+        for(iTemp = 0; iTemp < iTempTotal; iTemp++)
+        {
+            H5LogMsg("0x%x", data[iTemp]);
+        }
+    }
+#endif
+    //we only intercept evt packet here
+    if(pkt_type == HCI_EVENT_PKT)
+    {
+        intercepted = internal_event_intercept_h5();
+    }
+
+    //if you want to intercept more pakcets such as acl data, you can add code here
+/*BOARD_HAVE_BLUETOOTH_RTK_COEX begin*/
+#ifdef BLUETOOTH_RTK_COEX
+    if(pkt_type == HCI_ACLDATA_PKT)
+    {
+        uint8_t *pp = (uint8_t *)(skb->Data);
+        rtk_parse_l2cap_data(pp, 0);
+    }
+#endif
+/*BOARD_HAVE_BLUETOOTH_RTK_COEX end*/
+
+    H5LogMsg("intercepted = %d", intercepted);
+    if ( hci_layer_callbacks && (intercepted == FALSE))
+    {
+
+        hci_layer_callbacks->reassembled( rtk_h5.p_rcv_msg);
+    }
+
+
+}
+
+/**
+
+
+    @return 1- complete_pkt, 0 not a complete pkt.
+*/
+
+
+uint8_t hci_rx_dispatch_by_handle(sk_buff* rx_skb)
+{
+    uint8_t complete_pkt = FALSE;
+    uint16_t handle = 0;
+    HCI_CONN *hci_conn = NULL;
+
+    uint8_t     *rx_skb_data = NULL;
+    uint16_t   rx_skb_data_len = 0;
+
+    //get acl handle from acl data
+    rx_skb_data = skb_get_data(rx_skb);
+    rx_skb_data_len = skb_get_data_length(rx_skb);
+
+    //print snoop log
+    HC_BT_HDR *p_rcv_msg = NULL;          /* Buffer to hold current rx HCI message */
+    p_rcv_msg = (HC_BT_HDR *) buffer_allocator->alloc(BT_HC_HDR_SIZE + rx_skb_data_len);
+    if (p_rcv_msg != NULL)
+    {
+        /* Initialize buffer with received h5 data */
+        p_rcv_msg->offset = 0;
+        p_rcv_msg->layer_specific = 0;
+        p_rcv_msg->event = MSG_HC_TO_STACK_HCI_ACL;
+        p_rcv_msg->len = rx_skb_data_len;
+        memcpy((uint8_t *)(p_rcv_msg + 1), rx_skb_data, rx_skb_data_len);
+        //use the hci_layer interface
+        btsnoop->capture(p_rcv_msg, TRUE);
+        buffer_allocator->free(p_rcv_msg);
+    }
+
+    STREAM_TO_UINT16 (handle, rx_skb_data);
+    //get acl handle, 12bit only.
+    handle = handle & 0x0FFF ;
+    H5LogMsg("hci_rx_dispatch_by_handle: (0x%x)",handle);
+    //look up hci connection by handle
+    hci_conn = ConnHashLookupByHandle(&rtk_h5, handle);
+    if(hci_conn == NULL)
+    {
+        hci_conn = HciConnAllocate(handle);
+        if(hci_conn)
+        {
+            ConnHashAdd(&rtk_h5, hci_conn);
+        }
+        else
+        {
+            ALOGE("HciConnAllocate fail");
+            return 0;
+        }
+    }
+
+    //if it is first packet
+    if(hci_conn->rx_skb == NULL)
+    {
+        uint8_t* data = NULL;
+        hci_conn->rx_skb = skb_alloc(skb_get_data_length(rx_skb));
+        data = skb_get_data(hci_conn->rx_skb);
+        memcpy(data, skb_get_data(rx_skb), skb_get_data_length(rx_skb));
+        hci_conn->rx_skb->Length = skb_get_data_length(rx_skb);
+    }
+    else
+    {
+        sk_buff* skb_total = NULL;
+
+        uint16_t len_total = 0;
+        uint8_t * data_total = NULL;
+
+        uint32_t hci_len_rx_skb_cur = skb_get_hci_data_length(rx_skb);
+        uint32_t hci_len_rx_skb_last = skb_get_hci_data_length(hci_conn->rx_skb);
+
+        //pull hci header here, now rx_skb only contains L2CAP packets
+        skb_pull(rx_skb, HCI_ACL_PREAMBLE_SIZE);
+
+        //add rx_skb to hci_conn->rx_skb
+        len_total = skb_get_data_length(rx_skb) + skb_get_data_length(hci_conn->rx_skb);
+        skb_total = skb_alloc(len_total);
+        if(skb_total)
+        {
+
+            data_total = skb_get_data(skb_total);
+            skb_total->Length = len_total;
+            memcpy(data_total, skb_get_data(hci_conn->rx_skb), skb_get_data_length(hci_conn->rx_skb));
+            memcpy(data_total + skb_get_data_length(hci_conn->rx_skb), skb_get_data(rx_skb), skb_get_data_length(rx_skb));
+
+            //free unused buffer
+            skb_free(&hci_conn->rx_skb);
+
+            //
+            hci_conn->rx_skb = skb_total;
+            //update hci total length
+            skb_set_hci_data_length(hci_conn->rx_skb, hci_len_rx_skb_cur + hci_len_rx_skb_last);
+
+        }
+        else
+        {
+            ALOGE("skb_alloc fail");
+            return 0;
+        }
+    }
+
+    //check if it is a complete acl packet, if it is, then replace hci_conn->rx_skb with orignal rx_skb
+    if(TRUE == acl_rx_frame_end_chk(hci_conn->rx_skb))
+    {
+        skb_free(&rx_skb);
+        rtk_h5.rx_skb = hci_conn->rx_skb;
+        complete_pkt = TRUE;
+
+        //reset hci_conn->rx_skb to NULL
+        hci_conn->rx_skb = NULL;
+    }
+    else
+    {
+        complete_pkt = FALSE;
+    }
+    return complete_pkt;
+ }
+
+/**
+* after rx data is parsed, and we got a rx frame saved in h5->rx_skb,
+* this routinue is called.
+* things todo in this function:
+* 1. check if it's a hci frame, if it is, complete it with response or ack
+* 2. see the ack number, free acked frame in queue
+* 3. reset h5->rx_state, set rx_skb to null.
+*
+* @param h5 realtek h5 struct
+*
+*/
+static void h5_complete_rx_pkt(tHCI_H5_CB *h5)
+{
+    int pass_up = 1;
+    uint16_t eventtype = 0;
+    uint8_t *h5_hdr = NULL;
+    uint8_t complete_pkt = TRUE;
+    uint8_t pkt_type = 0;
+    tHCI_H5_CB *p_cb=&rtk_h5;
+
+    //H5LogMsg("HCI 3wire h5_complete_rx_pkt");
+    h5_hdr = (uint8_t *)skb_get_data(h5->rx_skb);
+    H5LogMsg("SeqNumber(%d), AckNumber(%d)", H5_HDR_SEQ(h5_hdr), H5_HDR_ACK(h5_hdr));
+
+    if (H5_HDR_RELIABLE(h5_hdr))
+    {
+        H5LogMsg("Received reliable seqno %u from card", h5->rxseq_txack);
+        h5->rxseq_txack = H5_HDR_SEQ(h5_hdr) + 1;
+        h5->rxseq_txack %= 8;
+        h5->is_txack_req = 1;
+    // send down an empty ack if needed.
+        h5_wake_up();
+    }
+
+    h5->rxack = H5_HDR_ACK(h5_hdr);
+    pkt_type = H5_HDR_PKT_TYPE(h5_hdr);
+    switch (pkt_type)
+    {
+        case HCI_ACLDATA_PKT:
+            pass_up = 1;
+            eventtype = MSG_HC_TO_STACK_HCI_ACL;
+        break;
+
+        case HCI_EVENT_PKT:
+            pass_up = 1;
+            eventtype = MSG_HC_TO_STACK_HCI_EVT;
+            break;
+
+        case HCI_SCODATA_PKT:
+            pass_up = 1;
+            eventtype = MSG_HC_TO_STACK_HCI_SCO;
+            break;
+        case HCI_COMMAND_PKT:
+            pass_up = 1;
+            eventtype = MSG_HC_TO_STACK_HCI_ERR;
+            break;
+
+        case H5_LINK_CTL_PKT:
+            pass_up = 0;
+        break;
+
+        case H5_ACK_PKT:
+            pass_up = 0;
+            break;
+
+        default:
+          ALOGE("Unknown pkt type(%d)", H5_HDR_PKT_TYPE(h5_hdr));
+          eventtype = MSG_HC_TO_STACK_HCI_ERR;
+          pass_up = 0;
+          break;
+    }
+
+    // remove h5 header and send packet to hci
+    h5_remove_acked_pkt(h5);
+
+    if(H5_HDR_PKT_TYPE(h5_hdr) == H5_LINK_CTL_PKT)
+    {
+
+        skb_pull(h5->rx_skb, H5_HDR_SIZE);
+        h5_process_ctl_pkts();
+    }
+
+    // decide if we need to pass up.
+    if (pass_up)
+    {
+
+        skb_pull(h5->rx_skb, H5_HDR_SIZE);
+
+        if(eventtype == MSG_HC_TO_STACK_HCI_ACL)
+        {
+
+            complete_pkt = hci_rx_dispatch_by_handle(h5->rx_skb);
+        }
+
+        //send command or complete acl data it to bluedroid stack
+        if(complete_pkt)
+        {
+            uint16_t len = 0;
+            sk_buff * skb_complete_pkt = h5->rx_skb;
+
+            /* Allocate a buffer for message */
+
+            len = BT_HC_HDR_SIZE + skb_get_data_length(skb_complete_pkt);
+            h5->p_rcv_msg = (HC_BT_HDR *) buffer_allocator->alloc(len);
+
+            if (h5->p_rcv_msg)
+            {
+                /* Initialize buffer with received h5 data */
+                h5->p_rcv_msg->offset = 0;
+                h5->p_rcv_msg->layer_specific = 0;
+                h5->p_rcv_msg->event = eventtype;
+                h5->p_rcv_msg->len = skb_get_data_length(skb_complete_pkt);
+                memcpy((uint8_t *)(h5->p_rcv_msg + 1), skb_get_data(skb_complete_pkt), skb_get_data_length(skb_complete_pkt));
+            }
+
+            /* generate snoop trace message */
+            /* ACL packet tracing had done in acl_rx_frame_end_chk() */
+            if (p_cb->p_rcv_msg->event != MSG_HC_TO_STACK_HCI_ACL)
+                btsnoop->capture(p_cb->p_rcv_msg, TRUE);
+
+            hci_recv_frame(skb_complete_pkt, pkt_type);
+        }
+
+    }
+
+
+    skb_free(&h5->rx_skb);
+
+    h5->rx_state = H5_W4_PKT_DELIMITER;
+    h5->rx_skb = NULL;
+}
+
+/**
+* Parse the receive data in h5 proto.
+*
+* @param h5 realtek h5 struct
+* @param data point to data received before parse
+* @param count num of data
+* @return reserved count
+*/
+static int h5_recv(tHCI_H5_CB *h5, uint8_t *data, int count)
+{
+//   unsigned char *ptr;
+    uint8_t *ptr;
+    uint8_t * skb_data = NULL;
+    uint8_t *hdr = NULL;
+
+    ptr = (uint8_t *)data;
+    H5LogMsg("count %d rx_state %d rx_count %ld data:0x%x", count, h5->rx_state, h5->rx_count,*ptr);
+    while (count)
+    {
+        if (h5->rx_count)
+        {
+            H5LogMsg("h5_recv lamparten 0");
+            if (*ptr == 0xc0)
+            {
+                ALOGE("short h5 packet");
+                skb_free(&h5->rx_skb);
+                h5->rx_state = H5_W4_PKT_START;
+                h5->rx_count = 0;
+            } else
+                h5_unslip_one_byte(h5, *ptr);
+
+            ptr++; count--;
+            continue;
+        }
+
+        switch (h5->rx_state)
+        {
+        case H5_W4_HDR:
+            // check header checksum. see Core Spec V4 "3-wire uart" page 67
+            H5LogMsg("h5_recv lamparten H5_W4_HDR 0");
+            skb_data = skb_get_data(h5->rx_skb);
+            hdr = (uint8_t *)skb_data;
+
+            if ((0xff & (uint8_t) ~ (skb_data[0] + skb_data[1] +
+                                   skb_data[2])) != skb_data[3])
+            {
+                ALOGE("h5 hdr checksum error!!!");
+                skb_free(&h5->rx_skb);
+                h5->rx_state = H5_W4_PKT_DELIMITER;
+                h5->rx_count = 0;
+                continue;
+            }
+
+            if (H5_HDR_RELIABLE(hdr)
+                && (H5_HDR_SEQ(hdr) != h5->rxseq_txack))
+            {
+                ALOGE("Out-of-order packet arrived, got(%u)expected(%u)",
+                   H5_HDR_SEQ(hdr), h5->rxseq_txack);
+                h5->is_txack_req = 1;
+                h5_wake_up();
+
+                skb_free(&h5->rx_skb);
+                h5->rx_state = H5_W4_PKT_DELIMITER;
+                h5->rx_count = 0;
+
+                continue;
+            }
+            h5->rx_state = H5_W4_DATA;
+            //payload length: May be 0
+            h5->rx_count = H5_HDR_LEN(hdr);
+            continue;
+        case H5_W4_DATA:
+            H5LogMsg("h5_recv lamparten H5_W4_DATA 0");
+            hdr = (uint8_t *)skb_get_data(h5->rx_skb);
+            if (H5_HDR_CRC(hdr))
+            {   // pkt with crc /
+                h5->rx_state = H5_W4_CRC;
+                h5->rx_count = 2;
+            }
+            else
+            {
+                h5_complete_rx_pkt(h5); //Send ACK
+                H5LogMsg("--------> H5_W4_DATA ACK\n");
+            }
+            continue;
+
+        case H5_W4_CRC:
+            H5LogMsg("h5_recv lamparten H5_W4_CRC 0");
+            if (bit_rev16(h5->message_crc) != h5_get_crc(h5))
+            {
+                ALOGE("Checksum failed, computed(%04x)received(%04x)",
+                    bit_rev16(h5->message_crc), h5_get_crc(h5));
+                skb_free(&h5->rx_skb);
+                h5->rx_state = H5_W4_PKT_DELIMITER;
+                h5->rx_count = 0;
+                continue;
+            }
+            skb_trim(h5->rx_skb, skb_get_data_length(h5->rx_skb) - 2);
+            h5_complete_rx_pkt(h5);
+            continue;
+
+        case H5_W4_PKT_DELIMITER:
+            H5LogMsg("h5_recv lamparten H5_W4_PKT_DELIMITER 0 *ptr:0x%x",*ptr);
+            switch (*ptr)
+            {
+            case 0xc0:
+                H5LogMsg("h5_recv lamparten H5_W4_PKT_DELIMITER 1");
+                h5->rx_state = H5_W4_PKT_START;
+                break;
+            default:
+                H5LogMsg("h5_recv lamparten H5_W4_PKT_DELIMITER 2");
+                break;
+            }
+            ptr++; count--;
+            break;
+
+        case H5_W4_PKT_START:
+            H5LogMsg("h5_recv lamparten H5_W4_PKT_START 0");
+            switch (*ptr)
+            {
+            case 0xc0:
+                H5LogMsg("h5_recv lamparten H5_W4_PKT_START 1");
+                ptr++; count--;
+                break;
+            default:
+                H5LogMsg("h5_recv lamparten H5_W4_PKT_START 2");
+                h5->rx_state = H5_W4_HDR;
+                h5->rx_count = 4;
+                h5->rx_esc_state = H5_ESCSTATE_NOESC;
+                H5_CRC_INIT(h5->message_crc);
+
+                // Do not increment ptr or decrement count
+                // Allocate packet. Max len of a H5 pkt=
+                // 0xFFF (payload) +4 (header) +2 (crc)
+                h5->rx_skb = skb_alloc(0x1005);
+                if (!h5->rx_skb)
+                {
+                    h5->rx_state = H5_W4_PKT_DELIMITER;
+                    h5->rx_count = 0;
+                    return 0;
+                }
+                break;
+            }
+            break;
+        }
+    }
+    return count;
+}
+
+/******************************************************************************
+**  Static functions
+******************************************************************************/
+
+/*******************************************************************************
+**
+** Function         get_acl_data_length_cback_h5
+**
+** Description      Callback function for HCI_READ_BUFFER_SIZE and
+**                  HCI_LE_READ_BUFFER_SIZE commands if they were sent because
+**                  of internal request.
+**
+Parameters:HCI_READ_BUFFER_SIZE
+Status,                                                 1byte
+HC_ACL_Data_Packet_Length,              2byte
+HC_Synchronous_Data_Packet_Length, 1byte
+HC_Total_Num_ACL_Data_Packets,       2byte
+HC_Total_Num_Synchronous_Data_Packets 2byte
+
+Parameters:HCI_LE_READ_BUFFER_SIZE
+Status,                                                     1byte
+HC_LE_ACL_Data_Packet_Length,               2byte
+HC_Total_Num_LE_ACL_Data_Packets        1byte
+
+** Returns          None
+**
+*******************************************************************************/
+
+    uint16_t hc_acl_data_size;      /* Controller's max ACL data length */
+    uint8_t   hc_sco_data_size;
+    uint16_t hc_acl_total_num;      /* Controller's total ACL number packets */
+    uint16_t hc_sco_total_num;      /* Controller's total ACL number packets */
+    uint16_t hc_ble_acl_data_size;  /* Controller's max BLE ACL data length */
+    uint16_t hc_ble_acl_total_num;  /* Controller's max BLE ACL data length */
+
+void get_acl_data_length_cback_h5(void *p_mem)
+{
+    uint8_t     *p, status;
+    uint16_t    opcode, len=0;
+    HC_BT_HDR   *p_buf = (HC_BT_HDR *) p_mem;
+
+    p = (uint8_t *)(p_buf + 1) + 3;
+    STREAM_TO_UINT16(opcode, p)
+    status = *p++;
+    if (status == 0) /* Success */
+    {
+        STREAM_TO_UINT16(len, p);
+    }
+
+
+    H5LogMsg("get_acl_data_length_cback_h5: opcode(0x%x)", opcode);
+    if (opcode == HCI_READ_BUFFER_SIZE)
+    {
+        if (status == 0)
+        {
+            uint8_t   hc_sco_data_size = 0;
+            uint16_t hc_acl_total_num = 0;
+            uint16_t hc_sco_total_num = 0;
+            hc_sco_data_size = *p++;
+            STREAM_TO_UINT16(hc_acl_total_num, p);
+            STREAM_TO_UINT16(hc_sco_total_num, p);
+
+            rtk_h5.hc_acl_data_size = len;
+            rtk_h5.hc_sco_data_size = hc_sco_data_size;
+            rtk_h5.hc_acl_total_num = hc_acl_total_num;
+            rtk_h5.hc_sco_total_num = hc_sco_total_num;
+
+            H5LogMsg("hc_acl_data_size:(%d), hc_sco_data_size:(%d), hc_acl_total_num:(%d), hc_sco_total_num(%d)", \
+               len, hc_sco_data_size, hc_acl_total_num, hc_sco_total_num);
+
+            rtk_h5.hc_cur_acl_total_num = hc_acl_total_num;
+        }
+
+        /* reuse the rx buffer for sending HCI_LE_READ_BUFFER_SIZE command */
+        p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
+        p_buf->offset = 0;
+        p_buf->layer_specific = 0;
+        p_buf->len = 3;
+
+        p = (uint8_t *) (p_buf + 1);
+        UINT16_TO_STREAM(p, HCI_LE_READ_BUFFER_SIZE);
+        *p = 0;
+
+        if ((status = hci_h5_send_int_cmd(HCI_LE_READ_BUFFER_SIZE, p_buf, \
+                                           get_acl_data_length_cback_h5)) == FALSE)
+        {
+            buffer_allocator->free(p_buf);
+        }
+    }
+    else if (opcode == HCI_LE_READ_BUFFER_SIZE)
+    {
+        if (status == 0)
+        {
+            uint8_t hc_ble_acl_total_num = 0;
+            hc_ble_acl_total_num = *p++;
+            rtk_h5.hc_ble_acl_data_size = (len) ? len : rtk_h5.hc_acl_data_size;
+            rtk_h5.hc_ble_acl_total_num = hc_ble_acl_total_num;
+            H5LogMsg("hc_ble_acl_data_size:(%d), hc_ble_acl_total_num:(%d)",  \
+               len, hc_ble_acl_total_num);
+        }
+        buffer_allocator->free(p_buf);
+        ALOGE("vendor lib postload completed");
+    }
+}
+
+static void data_retransfer_thread(void *arg)
+{
+    uint16_t events;
+    uint32_t data_len = 0;
+    uint8_t* pdata = NULL;
+    uint32_t i = 0;
+
+    H5LogMsg("data_retransfer_thread started");
+
+    prctl(PR_SET_NAME, (unsigned long)"data_retransfer_thread", 0, 0, 0);
+
+    while (h5_retransfer_running)
+    {
+        pthread_mutex_lock(&rtk_h5.mutex);
+        while (h5_ready_events == 0)
+        {
+            pthread_cond_wait(&rtk_h5.cond, &rtk_h5.mutex);
+        }
+        events = h5_ready_events;
+        h5_ready_events = 0;
+        pthread_mutex_unlock(&rtk_h5.mutex);
+
+        if (events & H5_EVENT_RX)
+        {
+            sk_buff *skb;
+            ALOGE("retransmitting (%u) pkts, retransfer count(%d)", skb_queue_get_length(rtk_h5.unack), rtk_h5.data_retrans_count);
+            if(rtk_h5.data_retrans_count < DATA_RETRANS_COUNT)
+            {
+                while ((skb = skb_dequeue_tail(rtk_h5.unack)) != NULL)
+                {
+                    data_len = skb_get_data_length(skb);
+                    pdata = skb_get_data(skb);
+                    if(data_len>16)
+                     data_len=16;
+
+                    for(i = 0 ; i < data_len; i++)
+                        ALOGE("0x%02X", pdata[i]);
+
+                    rtk_h5.msgq_txseq = (rtk_h5.msgq_txseq - 1) & 0x07;
+                    skb_queue_head(rtk_h5.rel, skb);
+
+                }
+                rtk_h5.data_retrans_count++;
+                h5_wake_up();
+
+            }
+            else
+            {
+            //do not put packet to rel queue, and do not send
+            //Kill bluetooth
+            kill(getpid(), SIGKILL);
+            }
+
+        }
+        else
+        if (events & H5_EVENT_EXIT)
+        {
+            break;
+        }
+
+}
+
+    H5LogMsg("data_retransfer_thread exiting");
+    pthread_exit(NULL);
+
+}
+
+void h5_retransfer_signal_event(uint16_t event)
+{
+    pthread_mutex_lock(&rtk_h5.mutex);
+    h5_ready_events |= event;
+    pthread_cond_signal(&rtk_h5.cond);
+    pthread_mutex_unlock(&rtk_h5.mutex);
+}
+
+
+
+static int create_data_retransfer_thread()
+{
+    struct sched_param param;
+    int policy;
+
+    pthread_attr_t thread_attr;
+
+
+    if (h5_retransfer_running)
+    {
+        ALOGW("create_data_retransfer_thread has been called repeatedly without calling cleanup ?");
+    }
+
+    h5_retransfer_running = 1;
+    h5_ready_events = 0;
+
+    pthread_attr_init(&thread_attr);
+    pthread_mutex_init(&rtk_h5.mutex, NULL);
+    pthread_cond_init(&rtk_h5.cond, NULL);
+
+    if (pthread_create(&rtk_h5.thread_data_retrans, &thread_attr, \
+               (void*)data_retransfer_thread, NULL) != 0)
+    {
+        ALOGE("pthread_create failed!");
+        h5_retransfer_running = 0;
+        return -1 ;
+    }
+/*
+    if(pthread_getschedparam(hc_cb.worker_thread, &policy, &param)==0)
+    {
+        policy = BTHC_LINUX_BASE_POLICY;
+
+#if (BTHC_LINUX_BASE_POLICY!=SCHED_NORMAL)
+        param.sched_priority = BTHC_MAIN_THREAD_PRIORITY;
+#endif
+        result = pthread_setschedparam(hc_cb.worker_thread, policy, &param);
+        if (result != 0)
+        {
+            ALOGW("create_data_retransfer_thread pthread_setschedparam failed (%s)", \
+            strerror(result));
+        }
+    }
+*/
+    return 0;
+
+}
+
+/*****************************************************************************
+**   HCI H5 INTERFACE FUNCTIONS
+*****************************************************************************/
+
+/*******************************************************************************
+**
+** Function        hci_h5_init
+**
+** Description     Initialize H5 module
+**
+** Returns         None
+**
+*******************************************************************************/
+void hci_h5_init(const packet_fragmenter_callbacks_t *result_callbacks,const allocator_t *bufalloc)
+{
+    ALOGI("RTKBT_RELEASE_NAME: %s",RTKBT_RELEASE_NAME);
+    H5LogMsg("hci_h5_init");
+
+    memset(&rtk_h5, 0, sizeof(tHCI_H5_CB));
+
+
+    /* Per HCI spec., always starts with 1 */
+    num_hci_cmd_pkts = 1;
+    h5_log_enable = 0;
+    /* Give an initial values of Host Controller's ACL data packet length
+     * Will update with an internal HCI(_LE)_Read_Buffer_Size request
+     */
+    rtk_h5.hc_acl_data_size = 820;//default value for 8723
+    rtk_h5.hc_ble_acl_data_size = 27;
+    rtk_h5.hc_cur_acl_total_num = 8;
+
+
+    h5_alloc_data_retrans_timer();
+    h5_alloc_sync_retrans_timer();
+    h5_alloc_conf_retrans_timer();
+    h5_alloc_wait_controller_baudrate_ready_timer();
+    h5_alloc_hw_init_ready_timer();
+
+    rtk_h5.thread_data_retrans = -1;
+
+    if(create_data_retransfer_thread() != 0)
+        ALOGE("H5 create_data_retransfer_thread failed");
+
+
+    rtk_h5.unack = RtbQueueInit();
+    rtk_h5.rel = RtbQueueInit();
+    rtk_h5.unrel = RtbQueueInit();
+    ConnHashInit(&rtk_h5);
+#if 0
+/*BOARD_HAVE_BLUETOOTH_RTK_COEX begin*/
+#ifdef BLUETOOTH_RTK_COEX
+    rtk_parse_init();
+#endif
+/*BOARD_HAVE_BLUETOOTH_RTK_COEX end*/
+#endif
+    rtk_h5.rx_state = H5_W4_PKT_DELIMITER;
+    rtk_h5.rx_esc_state = H5_ESCSTATE_NOESC;
+    hci_layer_callbacks = result_callbacks;
+    buffer_allocator = bufalloc;
+
+    hal = hci_hal_get_interface();
+    btsnoop = btsnoop_get_interface();
+}
+
+/*******************************************************************************
+**
+** Function        hci_h5_cleanup
+**
+** Description     Clean H5 module
+**
+** Returns         None
+**
+*******************************************************************************/
+void hci_h5_cleanup(void)
+{
+    H5LogMsg("hci_h5_cleanup++");
+    uint8_t try_cnt=10;
+    int result;
+
+    rtk_h5.cleanuping = 1;
+
+
+    //btsnoop_cleanup();
+
+    h5_free_data_retrans_timer();
+    h5_free_sync_retrans_timer();
+    h5_free_conf_retrans_timer();
+    h5_free_wait_controller_baudrate_ready_timer();
+    h5_free_hw_init_ready_timer();
+
+
+    if (h5_retransfer_running)
+    {
+        h5_retransfer_running = 0;
+        h5_retransfer_signal_event(H5_EVENT_EXIT);
+        if ((result=pthread_join(rtk_h5.thread_data_retrans, NULL)) < 0)
+        ALOGE( "H5 pthread_join() FAILED result:%d", result);
+    }
+
+    ms_delay(200);
+
+    pthread_mutex_destroy(&rtk_h5.mutex);
+    pthread_cond_destroy(&rtk_h5.cond);
+
+    RtbQueueFree(rtk_h5.unack);
+    RtbQueueFree(rtk_h5.rel);
+    RtbQueueFree(rtk_h5.unrel);
+    ConnHashFlush(&rtk_h5);
+#if 0
+/*BOARD_HAVE_BLUETOOTH_RTK_COEX begin*/
+#ifdef BLUETOOTH_RTK_COEX
+    rtk_parse_cleanup();
+#endif
+#endif
+/*BOARD_HAVE_BLUETOOTH_RTK_COEX end*/
+    hci_layer_callbacks = NULL;
+
+    H5LogMsg("hci_h5_cleanup--");
+
+}
+
+
+
+
+
+/*******************************************************************************
+**
+** Function        hci_h5_send_msg
+**
+** Description     Determine message type, set HCI H5 packet indicator, and
+**                 send message through USERIAL driver
+**
+** Returns         None
+**
+*******************************************************************************/
+void hci_h5_send_msg(HC_BT_HDR *p_msg)
+{
+    uint8_t type = 0;
+    uint16_t handle;
+    uint16_t bytes_to_send, lay_spec;
+    uint8_t *p = ((uint8_t *)(p_msg + 1)) + p_msg->offset;
+    uint16_t event = p_msg->event & MSG_EVT_MASK;
+    uint16_t sub_event = p_msg->event & MSG_SUB_EVT_MASK;
+    uint16_t acl_pkt_size = 0, acl_data_size = 0;
+    uint16_t bytes_sent;
+
+    uint8_t *pdata_h5 = NULL;
+    uint16_t len_h5_data = 0;
+
+    uint8_t *p_h5 = NULL;
+    uint32_t iTemp = 0;
+    uint32_t iTempTotal = 16;
+
+    sk_buff * skb = NULL;
+    HCI_CONN * hci_conn = NULL;
+
+    H5LogMsg("hci_h5_send_msg, 1 len =%d", p_msg->len);
+    H5LogMsg("p_msg->layer_specific 0x%04X, lay_spec:0x%04X",p_msg->layer_specific,lay_spec);
+
+    if (event == MSG_STACK_TO_HC_HCI_ACL)
+       type = HCI_ACLDATA_PKT;
+    else if (event == MSG_STACK_TO_HC_HCI_SCO)
+        type = HCI_SCODATA_PKT;
+    else if (event == MSG_STACK_TO_HC_HCI_CMD)
+            type = HCI_COMMAND_PKT;
+
+   if (sub_event == LOCAL_BR_EDR_CONTROLLER_ID)
+    {
+        acl_data_size = rtk_h5.hc_acl_data_size;
+        acl_pkt_size = rtk_h5.hc_acl_data_size + HCI_ACL_PREAMBLE_SIZE;
+    }
+    else
+    {
+        acl_data_size = rtk_h5.hc_ble_acl_data_size;
+        acl_pkt_size = rtk_h5.hc_ble_acl_data_size + HCI_ACL_PREAMBLE_SIZE;
+    }
+    H5LogMsg("acl_data_size = %d, acl_pkt_size = (%d), p_msg->offset=(%d)", acl_data_size, acl_pkt_size, p_msg->offset);
+
+    //
+    if (event == MSG_STACK_TO_HC_HCI_ACL)
+    {
+        uint8_t *pTemp = p;
+        STREAM_TO_UINT16 (handle, pTemp);
+        //get acl handle, 12bit only.
+        handle = handle & 0x0FFF ;
+        hci_conn = ConnHashLookupByHandle(&rtk_h5, handle);
+        if(hci_conn == NULL)
+        {
+            ALOGE("HCI connection handle (0x%x) has been disconnected or not connected", handle);
+            ALOGE("Return NOT Send this packet!!");
+            return;
+        }
+/*BOARD_HAVE_BLUETOOTH_RTK_COEX begin*/
+#ifdef BLUETOOTH_RTK_COEX
+        else
+        {
+            uint8_t *pp = ((uint8_t *)(p_msg + 1)) + p_msg->offset;
+            rtk_parse_l2cap_data(pp, 1);
+        }
+#endif
+/*BOARD_HAVE_BLUETOOTH_RTK_COEX end*/
+    }
+
+    /* Check if sending ACL data that needs fragmenting */
+    if ((event == MSG_STACK_TO_HC_HCI_ACL) && (p_msg->len > acl_pkt_size))
+    {
+        /* Get the handle from the packet */
+        STREAM_TO_UINT16 (handle, p);
+
+        /* Set packet boundary flags to "continuation packet" */
+        handle = (handle & 0xCFFF) | 0x1000;
+
+        /* Do all the first chunks */
+        while (p_msg->len > acl_pkt_size)
+        {
+            /* remember layer_specific because uart borrow
+               one byte from layer_specific for packet type */
+            lay_spec = p_msg->layer_specific;
+
+            p = ((uint8_t *)(p_msg + 1)) + p_msg->offset;
+
+            //
+            skb = skb_alloc_and_init(type, p, acl_pkt_size);
+
+
+            //check whether this ACL conn has ability to send
+            H5LogMsg("hc_cur_acl_total_num(%d), hc_acl_total_num(%d)", rtk_h5.hc_cur_acl_total_num, rtk_h5.hc_acl_total_num);
+            if(rtk_h5.hc_cur_acl_total_num>0)
+            {
+                h5_enqueue(skb);
+                rtk_h5.hc_cur_acl_total_num--;
+                hci_conn->NumOfNotCmpAclPkts++;
+            }
+            else
+            {
+                //store skb in pending pkts queue
+                ALOGE("******************(%d)", rtk_h5.hc_cur_acl_total_num);
+
+                skb_queue_tail(hci_conn->pending_pkts, skb);
+            }
+
+
+            /* generate snoop trace message */
+            btsnoop->capture(p_msg, FALSE);
+
+            p_msg->layer_specific = lay_spec;
+            /* Adjust offset and length for what we just sent */
+            p_msg->offset += acl_data_size;
+            p_msg->len    -= acl_data_size;
+
+            p = ((uint8_t *)(p_msg + 1)) + p_msg->offset;
+
+            UINT16_TO_STREAM (p, handle);
+
+            if (p_msg->len > acl_pkt_size)
+            {
+                UINT16_TO_STREAM (p, acl_data_size);
+            }
+            else
+            {
+                UINT16_TO_STREAM (p, p_msg->len - HCI_ACL_PREAMBLE_SIZE);
+            }
+
+            /* If we were only to send partial buffer, stop when done.    */
+            /* Send the buffer back to L2CAP to send the rest of it later */
+            if (p_msg->layer_specific)
+            {
+                if (--p_msg->layer_specific == 0)
+                {
+                    p_msg->event = MSG_HC_TO_STACK_L2C_SEG_XMIT;
+
+                    if (hci_layer_callbacks)
+                    {
+                          //For Acl sent partially , enqueue the  first acl_pkt_size to h5_enqueue, callback the rest of the Acl data to upstack to resend it
+                          hci_layer_callbacks->transmit_finished(p_msg, false);
+//                        bt_hc_cbacks->tx_result((TRANSAC) p_msg, \
+//                                                    (char *) (p_msg + 1), \
+//                                                    BT_HC_TX_FRAGMENT);
+                    }
+
+                    return;
+                }
+            }
+        }
+    }
+
+    /* remember layer_specific because uart borrow
+       one byte from layer_specific for packet type */
+    lay_spec = p_msg->layer_specific;
+
+    /* Put the HCI Transport packet type 1 byte before the message */
+    p = ((uint8_t *)(p_msg + 1)) + p_msg->offset -1;
+
+
+    //
+    skb = skb_alloc_and_init(type, p+1, p_msg->len);
+    if (event == MSG_STACK_TO_HC_HCI_ACL)
+    {
+            //check whether this ACL conn has ability to send
+            H5LogMsg("hc_cur_acl_total_num(%d), hc_acl_total_num(%d)", rtk_h5.hc_cur_acl_total_num, rtk_h5.hc_acl_total_num);
+
+            if(rtk_h5.hc_cur_acl_total_num>0)
+            {
+                h5_enqueue(skb);
+                rtk_h5.hc_cur_acl_total_num--;
+                hci_conn->NumOfNotCmpAclPkts++;
+            }
+            else
+            {
+                //store skb in pending pkts queue
+                skb_queue_tail(hci_conn->pending_pkts, skb);
+            }
+    }
+    else
+    {
+        h5_enqueue(skb);
+    }
+
+    //
+
+    p_msg->layer_specific = lay_spec;
+
+    if (event == MSG_STACK_TO_HC_HCI_CMD)
+    {
+        num_hci_cmd_pkts--;
+
+        /* If this is an internal Cmd packet, the layer_specific field would
+         * have stored with the opcode of HCI command.
+         * Retrieve the opcode from the Cmd packet.
+         */
+         p++;
+        STREAM_TO_UINT16(lay_spec, p);
+        H5LogMsg("HCI Command opcode(0x%04X)", lay_spec);
+        if(lay_spec == 0x0c03)
+        {
+            H5LogMsg("RX HCI RESET Command, stop hw init timer");
+            h5_stop_hw_init_ready_timer();
+        }
+/*BOARD_HAVE_BLUETOOTH_RTK_COEX begin*/
+#ifdef BLUETOOTH_RTK_COEX
+        rtk_parse_command((uint8_t *)&lay_spec);
+#endif
+/*BOARD_HAVE_BLUETOOTH_RTK_COEX end*/
+    }
+
+    /* generate snoop trace message */
+    btsnoop->capture(p_msg, FALSE);
+    H5LogMsg("p_msg->layer_specific 0x%04X, lay_spec:0x%04X",p_msg->layer_specific,lay_spec);
+    if ((event == MSG_STACK_TO_HC_HCI_CMD)) {
+       //For int_cm as H5 INIT cmd and Coex cmd ... just free it, while hold the other CMD
+       if((rtk_h5.int_cmd_rsp_pending > 0) && (p_msg->layer_specific == lay_spec)){
+         H5LogMsg("For int_cm as H5 INIT cmd and Coex cmd ... just free it lay_spec:0x%04X");
+         /* dealloc buffer of internal command */
+        buffer_allocator->free(p_msg);
+       }
+    } else {
+        //For Acl sent complete, just free it
+        buffer_allocator->free(p_msg);
+    }
+
+    h5_wake_up();
+    return;
+}
+
+
+/*******************************************************************************
+**
+** Function        hci_h5_receive_msg
+**
+** Description     Construct HCI EVENT/ACL packets and send them to stack once
+**                 complete packet has been received.
+**
+** Returns         Number of read bytes
+**
+*******************************************************************************/
+//change to  hal_says_data_ready
+void  hci_h5_receive_msg(uint8_t *byte)
+{
+        uint8_t     h5_byte;
+        h5_byte  = *byte;
+        H5LogMsg("hci_h5_receive_msg byte:%d",h5_byte);
+        h5_recv(&rtk_h5, &h5_byte, 1);
+}
+
+
+/*******************************************************************************
+**
+** Function        hci_h5_send_int_cmd
+**
+** Description     Place the internal commands (issued internally by vendor lib)
+**                 in the tx_q.
+**
+** Returns         TRUE/FALSE
+**
+*******************************************************************************/
+uint8_t hci_h5_send_int_cmd(uint16_t opcode, HC_BT_HDR *p_buf, \
+                                  tINT_CMD_CBACK p_cback)
+{
+   // uint8_t * p =  (uint8_t *) (p_buf + 1);
+
+    if(rtk_h5.link_estab_state == H5_UNINITIALIZED)
+    {
+        if(opcode == HCI_VSC_H5_INIT)
+        {
+            h5_start_hw_init_ready_timer();
+            rtk_h5.cback_h5sync = p_cback;
+            hci_h5_send_sync_req();
+            h5_start_sync_retrans_timer();
+        }
+    }
+    else if(rtk_h5.link_estab_state == H5_ACTIVE)
+    {
+        if(opcode == 0xFC17)
+            rtk_h5.cback_h5sync = p_cback;
+
+        H5LogMsg("hci_h5_send_int_cmd(0x%x)", opcode);
+        if (rtk_h5.int_cmd_rsp_pending > INT_CMD_PKT_MAX_COUNT)
+        {
+            ALOGE( \
+            "Allow only %d outstanding internal commands at a time [Reject 0x%04X]"\
+            , INT_CMD_PKT_MAX_COUNT, opcode);
+            return FALSE;
+        }
+
+        rtk_h5.int_cmd_rsp_pending++;
+        rtk_h5.int_cmd[rtk_h5.int_cmd_wrt_idx].opcode = opcode;
+        rtk_h5.int_cmd[rtk_h5.int_cmd_wrt_idx].cback = p_cback;
+        rtk_h5.int_cmd_wrt_idx = ((rtk_h5.int_cmd_wrt_idx+1) & INT_CMD_PKT_IDX_MASK);
+
+        p_buf->layer_specific = opcode;
+#if 0
+/*BOARD_HAVE_BLUETOOTH_RTK_COEX begin*/
+
+        if(opcode == 0xFC17
+            ||opcode == 0xFC20
+            ||opcode == 0xFC6D
+            ||opcode == 0xFC61
+            ||opcode == 0x1001
+            ||opcode == HCI_READ_BUFFER_SIZE
+            ||opcode ==HCI_LE_READ_BUFFER_SIZE )
+        {
+            /* stamp signature to indicate an internal command */
+        if(p_buf != NULL)
+             hci_h5_send_msg(p_buf);
+        }
+
+/*BOARD_HAVE_BLUETOOTH_RTK_COEX end*/
+#endif
+    ALOGE("hci_h5_send_int_cmd :0x%x", opcode);
+    if(p_buf != NULL)
+         hci_h5_send_msg(p_buf);
+    }
+
+
+    return TRUE;
+}
+
+
+/*******************************************************************************
+**
+** Function        hci_h5_get_acl_data_length
+**
+** Description     Issue HCI_READ_BUFFER_SIZE command to retrieve Controller's
+**                 ACL data length setting
+**
+** Returns         None
+**
+*******************************************************************************/
+void hci_h5_get_acl_data_length(void)
+{
+#if 0
+    HC_BT_HDR  *p_buf = NULL;
+    uint8_t     *p, ret;
+
+    if (bt_hc_cbacks)
+    {
+        p_buf = (HC_BT_HDR *) bt_hc_cbacks->alloc(BT_HC_HDR_SIZE + \
+                                                       HCI_CMD_PREAMBLE_SIZE);
+
+
+    if (p_buf)
+    {
+        p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
+        p_buf->offset = 0;
+        p_buf->layer_specific = 0;
+        p_buf->len = HCI_CMD_PREAMBLE_SIZE;
+
+        p = (uint8_t *) (p_buf + 1);
+        UINT16_TO_STREAM(p, HCI_READ_BUFFER_SIZE);
+        *p = 0;
+
+        if ((ret = hci_h5_send_int_cmd(HCI_READ_BUFFER_SIZE, p_buf, \
+                                       get_acl_data_length_cback_h5)) == FALSE)
+        {
+            bt_hc_cbacks->dealloc((TRANSAC) p_buf, (char *) (p_buf + 1));
+        }
+        else
+            return;
+    }
+
+    if (bt_hc_cbacks)
+    {
+        ALOGE("vendor lib postload aborted");
+        bt_hc_cbacks->postload_cb(NULL, BT_HC_POSTLOAD_FAIL);
+    }
+#endif
+}
+
+
+/***
+    Timer related functions
+*/
+static timer_t OsAllocateTimer(int signo)
+{
+    struct sigevent sigev;
+    timer_t timerid = -1;
+
+    // Create the POSIX timer to generate signo
+    sigev.sigev_notify = SIGEV_THREAD_ID;
+    sigev.sigev_notify_thread_id = syscall(__NR_gettid);
+    sigev.sigev_signo = signo;
+    sigev.sigev_value.sival_ptr = &timerid;
+
+    ALOGE("OsAllocateTimer rtk_parse sigev.sigev_notify_thread_id = syscall(__NR_gettid)!");
+    //Create the Timer using timer_create signal
+
+    if (timer_create(CLOCK_REALTIME, &sigev, &timerid) == 0)
+    {
+            return timerid;
+    }
+    else
+    {
+        ALOGE("timer_create error!");
+        return -1;
+    }
+}
+
+ int OsFreeTimer(timer_t timerid)
+{
+    int ret = 0;
+    ret = timer_delete(timerid);
+    if(ret != 0)
+        ALOGE("timer_delete fail with errno(%d)", errno);
+
+    return ret;
+}
+
+
+ static int OsStartTimer(timer_t timerid, int msec, int mode)
+ {
+    struct itimerspec itval;
+
+    itval.it_value.tv_sec = msec / 1000;
+    itval.it_value.tv_nsec = (long)(msec % 1000) * (1000000L);
+
+    if (mode == 1)
+
+    {
+        itval.it_interval.tv_sec    = itval.it_value.tv_sec;
+        itval.it_interval.tv_nsec = itval.it_value.tv_nsec;
+    }
+    else
+    {
+        itval.it_interval.tv_sec = 0;
+        itval.it_interval.tv_nsec = 0;
+    }
+
+    //Set the Timer when to expire through timer_settime
+
+    if (timer_settime(timerid, 0, &itval, NULL) != 0)
+    {
+        ALOGE("time_settime error!");
+        return -1;
+    }
+
+    return 0;
+
+}
+
+ static int OsStopTimer(timer_t timerid)
+ {
+    return OsStartTimer(timerid, 0, 0);
+ }
+
+static void h5_timeout_handler(int signo, siginfo_t * info, void *context)
+ {
+
+    ALOGE("h5_timeout_handler");
+    if(rtk_h5.cleanuping)
+    {
+        ALOGE("H5 is cleanuping, EXIT here!");
+        return;
+    }
+    if (signo == TIMER_H5_DATA_RETRANS)
+    {
+        h5_retransfer_signal_event(H5_EVENT_RX);
+    }
+    else
+    if (signo == TIMER_H5_SYNC_RETRANS)
+    {
+        ALOGE("Wait H5 Sync Resp timeout, %d times", rtk_h5.sync_retrans_count);
+        if(rtk_h5.sync_retrans_count < SYNC_RETRANS_COUNT)
+        {
+            hci_h5_send_sync_req();
+            rtk_h5.sync_retrans_count ++;
+        }
+        else
+        {
+            h5_stop_sync_retrans_timer();
+        }
+    }
+    else
+    if (signo == TIMER_H5_CONF_RETRANS)
+    {
+        ALOGE("Wait H5 Conf Resp timeout, %d times", rtk_h5.conf_retrans_count);
+        if(rtk_h5.conf_retrans_count < CONF_RETRANS_COUNT)
+        {
+            hci_h5_send_conf_req();
+            rtk_h5.conf_retrans_count++;
+        }
+        else
+        {
+            h5_stop_conf_retrans_timer();
+        }
+    }
+    else
+    if (signo == TIMER_H5_WAIT_CT_BAUDRATE_READY)
+    {
+        H5LogMsg("No Controller retransfer, baudrate of controller ready");
+        if (rtk_h5.cback_h5sync!= NULL)
+        {
+            rtk_h5.cback_h5sync(rtk_h5.p_rcv_msg);
+        }
+        else
+        {
+            // Missing cback function!
+            // Release the p_rcv_msg buffer.
+            buffer_allocator->free(rtk_h5.p_rcv_msg);
+        }
+    }
+    else
+    if (signo == TIMER_H5_HW_INIT_READY)
+    {
+        H5LogMsg("TIMER_H5_HW_INIT_READY timeout, kill restart BT");
+        //kill(getpid(), SIGKILL);
+
+    }
+    else
+    {
+        ALOGE("H5 timer rx unspported signo(%d)", signo);
+    }
+}
+
+int h5_alloc_data_retrans_timer()
+ {
+    struct sigaction sigact;
+
+    sigemptyset(&sigact.sa_mask);
+    sigact.sa_flags = SA_SIGINFO;
+
+    //register the Signal Handler
+    sigact.sa_sigaction = h5_timeout_handler;
+
+    // Set up sigaction to catch signal first timer
+    if (sigaction(TIMER_H5_DATA_RETRANS, &sigact, NULL) == -1)
+    {
+        H5LogMsg("sigaction failed");
+        return -1;
+    }
+
+    // Create and set the timer when to expire
+    rtk_h5.timer_data_retrans = OsAllocateTimer(TIMER_H5_DATA_RETRANS);
+
+    return 0;
+
+ }
+
+
+int h5_free_data_retrans_timer()
+{
+    return OsFreeTimer(rtk_h5.timer_data_retrans);
+}
+
+
+int h5_start_data_retrans_timer()
+{
+    return OsStartTimer(rtk_h5.timer_data_retrans, DATA_RETRANS_TIMEOUT_VALUE, 0);
+}
+
+int h5_stop_data_retrans_timer()
+{
+    return OsStopTimer(rtk_h5.timer_data_retrans);
+}
+
+int h5_alloc_sync_retrans_timer()
+ {
+    struct sigaction sigact;
+
+    sigemptyset(&sigact.sa_mask);
+    sigact.sa_flags = SA_SIGINFO;
+
+    //register the Signal Handler
+    sigact.sa_sigaction = h5_timeout_handler;
+
+    // Set up sigaction to catch signal first timer
+    if (sigaction(TIMER_H5_SYNC_RETRANS, &sigact, NULL) == -1)
+    {
+        H5LogMsg("sigaction failed");
+        return -1;
+    }
+
+    // Create and set the timer when to expire
+    rtk_h5.timer_sync_retrans = OsAllocateTimer(TIMER_H5_SYNC_RETRANS);
+
+    return 0;
+
+ }
+
+int h5_free_sync_retrans_timer()
+{
+    return OsFreeTimer(rtk_h5.timer_sync_retrans);
+}
+
+
+int h5_start_sync_retrans_timer()
+{
+    return OsStartTimer(rtk_h5.timer_sync_retrans, SYNC_RETRANS_TIMEOUT_VALUE, 1);
+}
+
+int h5_stop_sync_retrans_timer()
+{
+    return OsStopTimer(rtk_h5.timer_sync_retrans);
+}
+
+
+int h5_alloc_conf_retrans_timer()
+ {
+    struct sigaction sigact;
+
+    sigemptyset(&sigact.sa_mask);
+    sigact.sa_flags = SA_SIGINFO;
+
+    //register the Signal Handler
+    sigact.sa_sigaction = h5_timeout_handler;
+
+    // Set up sigaction to catch signal first timer
+    if (sigaction(TIMER_H5_CONF_RETRANS, &sigact, NULL) == -1)
+    {
+        H5LogMsg("sigaction failed");
+        return -1;
+    }
+
+    // Create and set the timer when to expire
+    rtk_h5.timer_conf_retrans = OsAllocateTimer(TIMER_H5_CONF_RETRANS);
+
+    return 0;
+
+ }
+
+int h5_free_conf_retrans_timer()
+{
+    return OsFreeTimer(rtk_h5.timer_conf_retrans);
+}
+
+
+int h5_start_conf_retrans_timer()
+{
+    return OsStartTimer(rtk_h5.timer_conf_retrans, CONF_RETRANS_TIMEOUT_VALUE, 1);
+}
+
+int h5_stop_conf_retrans_timer()
+{
+    return OsStopTimer(rtk_h5.timer_conf_retrans);
+}
+
+
+
+int h5_alloc_wait_controller_baudrate_ready_timer()
+ {
+    struct sigaction sigact;
+
+    sigemptyset(&sigact.sa_mask);
+    sigact.sa_flags = SA_SIGINFO;
+
+    //register the Signal Handler
+    sigact.sa_sigaction = h5_timeout_handler;
+
+    // Set up sigaction to catch signal first timer
+    if (sigaction(TIMER_H5_WAIT_CT_BAUDRATE_READY, &sigact, NULL) == -1)
+    {
+        H5LogMsg("sigaction failed");
+        return -1;
+    }
+
+    // Create and set the timer when to expire
+    rtk_h5.timer_wait_ct_baudrate_ready = OsAllocateTimer(TIMER_H5_WAIT_CT_BAUDRATE_READY);
+
+    return 0;
+
+ }
+
+int h5_free_wait_controller_baudrate_ready_timer()
+{
+    return OsFreeTimer(rtk_h5.timer_wait_ct_baudrate_ready);
+}
+
+
+int h5_start_wait_controller_baudrate_ready_timer()
+{
+    return OsStartTimer(rtk_h5.timer_wait_ct_baudrate_ready, WAIT_CT_BAUDRATE_READY_TIMEOUT_VALUE, 0);
+}
+
+int h5_stop_wait_controller_baudrate_ready_timer()
+{
+    return OsStopTimer(rtk_h5.timer_wait_ct_baudrate_ready);
+}
+
+
+int h5_alloc_hw_init_ready_timer()
+ {
+    struct sigaction sigact;
+
+    sigemptyset(&sigact.sa_mask);
+    sigact.sa_flags = SA_SIGINFO;
+
+    //register the Signal Handler
+    sigact.sa_sigaction = h5_timeout_handler;
+
+    // Set up sigaction to catch signal first timer
+    if (sigaction(TIMER_H5_HW_INIT_READY, &sigact, NULL) == -1)
+    {
+        H5LogMsg("sigaction failed");
+        return -1;
+    }
+
+    // Create and set the timer when to expire
+    rtk_h5.timer_h5_hw_init_ready = OsAllocateTimer(TIMER_H5_HW_INIT_READY);
+
+    return 0;
+
+ }
+
+int h5_free_hw_init_ready_timer()
+{
+    return OsFreeTimer(rtk_h5.timer_h5_hw_init_ready);
+}
+
+
+int h5_start_hw_init_ready_timer()
+{
+    return OsStartTimer(rtk_h5.timer_h5_hw_init_ready, H5_HW_INIT_READY_TIMEOUT_VALUE, 0);
+}
+
+int h5_stop_hw_init_ready_timer()
+{
+    return OsStopTimer(rtk_h5.timer_h5_hw_init_ready);
+}
+
+
+/******************************************************************************
+**  HCI H5 Services interface table
+******************************************************************************/
+
+const tHCI_IF hci_h5_func_table =
+{
+    hci_h5_init,
+    hci_h5_cleanup,
+    hci_h5_send_msg,
+    hci_h5_send_int_cmd,
+    hci_h5_get_acl_data_length,
+    hci_h5_receive_msg
+};
+
+const hci_hal_t *hci_get_h5_interface() {
+  return &hci_h5_func_table;
+}
+
+
diff --git a/hci/src/hci_hal_h4.c b/hci/src/hci_hal_h4.c
old mode 100644
new mode 100755
index 4fc4274..5efaa87
--- a/hci/src/hci_hal_h4.c
+++ b/hci/src/hci_hal_h4.c
@@ -29,6 +29,9 @@
 #include "osi/include/reactor.h"
 #include "vendor.h"
 
+#ifdef BLUETOOTH_RTK
+#include "hci_layer.h"
+#endif
 #define HCI_HAL_SERIAL_BUFFER_SIZE 1026
 
 // Our interface and modules we import
@@ -99,6 +102,9 @@ static void hal_close() {
 }
 
 static size_t read_data(serial_data_type_t type, uint8_t *buffer, size_t max_size, bool block) {
+#ifdef BLUETOOTH_RTK
+  if(!bluetooth_rtk_h5_flag) {
+#endif
   if (type < DATA_TYPE_ACL || type > DATA_TYPE_EVENT) {
     LOG_ERROR("%s invalid data type: %d", __func__, type);
     return 0;
@@ -110,6 +116,9 @@ static size_t read_data(serial_data_type_t type, uint8_t *buffer, size_t max_siz
     return 0;
   }
 
+#ifdef BLUETOOTH_RTK
+  }
+#endif
   return eager_reader_read(uart_stream, buffer, max_size, block);
 }
 
@@ -126,16 +135,33 @@ static uint16_t transmit_data(serial_data_type_t type, uint8_t *data, uint16_t l
   assert(data != NULL);
   assert(length > 0);
 
+#ifdef BLUETOOTH_RTK
+  if(!bluetooth_rtk_h5_flag) {
+#endif
   if (type < DATA_TYPE_COMMAND || type > DATA_TYPE_SCO) {
     LOG_ERROR("%s invalid data type: %d", __func__, type);
     return 0;
   }
+#ifdef BLUETOOTH_RTK
+  }
+#endif
 
+#ifdef BLUETOOTH_RTK
+  uint8_t previous_byte = *data;
+
+  if(!bluetooth_rtk_h5_flag) {
+  // Write the signal byte right before the data
+  --data;
+  *(data) = type;
+  ++length;
+  }
+#else
   // Write the signal byte right before the data
   --data;
   uint8_t previous_byte = *data;
   *(data) = type;
   ++length;
+#endif
 
   uint16_t transmitted_length = 0;
   while (length > 0) {
@@ -156,12 +182,23 @@ static uint16_t transmit_data(serial_data_type_t type, uint8_t *data, uint16_t l
   }
 
 done:;
+#ifdef BLUETOOTH_RTK
+  if(!bluetooth_rtk_h5_flag) {
+  // Be nice and restore the old value of that byte
+  *(data) = previous_byte;
+
+  // Remove the signal byte from our transmitted length, if it was actually written
+  if (transmitted_length > 0)
+    --transmitted_length;
+  }
+#else
   // Be nice and restore the old value of that byte
   *(data) = previous_byte;
 
   // Remove the signal byte from our transmitted length, if it was actually written
   if (transmitted_length > 0)
     --transmitted_length;
+#endif
 
   return transmitted_length;
 }
@@ -170,6 +207,9 @@ done:;
 
 // See what data is waiting, and notify the upper layer
 static void event_uart_has_bytes(eager_reader_t *reader, UNUSED_ATTR void *context) {
+#ifdef BLUETOOTH_RTK
+  if(!bluetooth_rtk_h5_flag) {
+#endif
   if (stream_has_interpretation) {
     callbacks->data_ready(current_data_type);
   } else {
@@ -186,6 +226,13 @@ static void event_uart_has_bytes(eager_reader_t *reader, UNUSED_ATTR void *conte
     stream_has_interpretation = true;
     current_data_type = type_byte;
   }
+#ifdef BLUETOOTH_RTK
+  } else {
+    stream_has_interpretation = true;
+    current_data_type = DATA_TYPE_H5;
+    callbacks->data_ready(current_data_type);
+  }
+#endif
 }
 
 static const hci_hal_t interface = {
diff --git a/hci/src/hci_layer.c b/hci/src/hci_layer.c
old mode 100644
new mode 100755
index 5138ce6..25bef60
--- a/hci/src/hci_layer.c
+++ b/hci/src/hci_layer.c
@@ -44,6 +44,9 @@
 #include "packet_fragmenter.h"
 #include "osi/include/reactor.h"
 #include "vendor.h"
+#ifdef BLUETOOTH_RTK_COEX
+#include "rtk_parse.h"
+#endif
 
 // TODO(zachoverflow): remove this hack extern
 #include <hardware/bluetooth.h>
@@ -111,12 +114,21 @@ static hci_t interface;
 static const allocator_t *buffer_allocator;
 static const btsnoop_t *btsnoop;
 static const hci_hal_t *hal;
+#ifdef BLUETOOTH_RTK
+static const tHCI_IF *hci_h5;
+char bt_hci_device_node[BT_HCI_DEVICE_NODE_MAX_LEN] = {0};
+bool bluetooth_rtk_h5_flag = FALSE;//Default Usb H4 Interfcace ,if ture Uart H5 Interface
+extern const hci_hal_t *hci_get_h5_interface();
+#endif
 static const hci_hal_callbacks_t hal_callbacks;
 static const hci_inject_t *hci_inject;
 static const low_power_manager_t *low_power_manager;
 static const packet_fragmenter_t *packet_fragmenter;
 static const packet_fragmenter_callbacks_t packet_fragmenter_callbacks;
 static const vendor_t *vendor;
+#ifdef BLUETOOTH_RTK_COEX
+static const rtk_parse_manager_t *rtk_parse_manager;
+#endif
 
 static future_t *startup_future;
 static thread_t *thread; // We own this
@@ -234,9 +246,24 @@ static future_t *start_up(void) {
   fixed_queue_register_dequeue(command_queue, thread_get_reactor(thread), event_command_ready, NULL);
   fixed_queue_register_dequeue(packet_queue, thread_get_reactor(thread), event_packet_ready, NULL);
 
+#ifdef BLUETOOTH_RTK
+/*we add BLUETOOTH_RTK_H5 Flag Here*/
+  if(!strcmp(bt_hci_device_node,"/dev/rtk_btusb")){
+    bluetooth_rtk_h5_flag = FALSE;
+    LOG_INFO("%s bluetooth_rtk_h5_flag :%d", __func__,bluetooth_rtk_h5_flag);
+  }else {
+    bluetooth_rtk_h5_flag = TRUE;
+  }
+  LOG_INFO("%s bluetooth_rtk_h5_flag :%d bt_hci_device_node:%s", __func__,bluetooth_rtk_h5_flag,bt_hci_device_node);
+  if(bluetooth_rtk_h5_flag)
+    hci_h5->init(&packet_fragmenter_callbacks,buffer_allocator);
+#endif
   vendor->open(btif_local_bd_addr.address, &interface);
   hal->init(&hal_callbacks, thread);
   low_power_manager->init(thread);
+#ifdef BLUETOOTH_RTK_COEX
+  rtk_parse_manager->rtk_parse_init(&interface);
+#endif
 
   vendor->set_callback(VENDOR_CONFIGURE_FIRMWARE, firmware_config_callback);
   vendor->set_callback(VENDOR_CONFIGURE_SCO, sco_config_callback);
@@ -302,8 +329,15 @@ static future_t *shut_down() {
   epilog_timer = NULL;
   command_response_timer = NULL;
 
+#ifdef BLUETOOTH_RTK
+  if(bluetooth_rtk_h5_flag)
+    hci_h5->cleanup();
+#endif
   low_power_manager->cleanup();
   hal->close();
+#ifdef BLUETOOTH_RTK_COEX
+  rtk_parse_manager->rtk_parse_cleanup();
+#endif
 
   // Turn off the chip
   int power_state = BT_VND_PWR_OFF;
@@ -339,6 +373,12 @@ static void do_postload() {
 static void set_data_queue(fixed_queue_t *queue) {
   upwards_data_queue = queue;
 }
+#ifdef BLUETOOTH_RTK
+static void transmit_int_command(uint16_t opcode, void *buffer,tINT_CMD_CBACK callback) {
+    LOG_ERROR("%s hci_h5->send_int_cmd.", __func__);
+    hci_h5->send_int_cmd(opcode, buffer, callback);
+}
+#endif
 
 static void transmit_command(
     BT_HDR *command,
@@ -398,7 +438,8 @@ static void transmit_downward(data_dispatcher_type_t type, void *data) {
 
 static void event_finish_startup(UNUSED_ATTR void *context) {
   LOG_INFO("%s", __func__);
-  hal->open();
+  if(!hal->open())
+      return;
   vendor->send_async_command(VENDOR_CONFIGURE_FIRMWARE, NULL);
 }
 
@@ -463,11 +504,24 @@ static void event_command_ready(fixed_queue_t *queue, UNUSED_ATTR void *context)
 
     // Send it off
     low_power_manager->wake_assert();
+#ifdef BLUETOOTH_RTK
+  if(bluetooth_rtk_h5_flag)
+    hci_h5->send(wait_entry->command);
+  else
     packet_fragmenter->fragment_and_dispatch(wait_entry->command);
-    low_power_manager->transmit_done();
+#else
+  packet_fragmenter->fragment_and_dispatch(wait_entry->command);
+#endif
+  low_power_manager->transmit_done();
 
+#ifdef BLUETOOTH_RTK
+  if(!bluetooth_rtk_h5_flag){
     non_repeating_timer_restart_if(command_response_timer, !list_is_empty(commands_pending_response));
   }
+#else
+  non_repeating_timer_restart_if(command_response_timer, !list_is_empty(commands_pending_response));
+#endif
+  }
 }
 
 static void event_packet_ready(fixed_queue_t *queue, UNUSED_ATTR void *context) {
@@ -475,7 +529,14 @@ static void event_packet_ready(fixed_queue_t *queue, UNUSED_ATTR void *context)
   BT_HDR *packet = (BT_HDR *)fixed_queue_dequeue(queue);
 
   low_power_manager->wake_assert();
+#ifdef BLUETOOTH_RTK
+  if(bluetooth_rtk_h5_flag)
+    hci_h5->send(packet);
+  else
+    packet_fragmenter->fragment_and_dispatch(packet);
+#else
   packet_fragmenter->fragment_and_dispatch(packet);
+#endif
   low_power_manager->transmit_done();
 }
 
@@ -483,6 +544,14 @@ static void event_packet_ready(fixed_queue_t *queue, UNUSED_ATTR void *context)
 static void transmit_fragment(BT_HDR *packet, bool send_transmit_finished) {
   uint16_t event = packet->event & MSG_EVT_MASK;
   serial_data_type_t type = event_to_data_type(event);
+#ifdef BLUETOOTH_RTK_COEX
+  uint8_t *pp = ((uint8_t *)(packet + 1)) + packet->offset;
+  if (event == MSG_STACK_TO_HC_HCI_ACL)
+    rtk_parse_manager->rtk_parse_l2cap_data(pp,1);
+  if (event == MSG_STACK_TO_HC_HCI_CMD)
+    rtk_parse_manager->rtk_parse_command(pp);
+#endif
+
 
   btsnoop->capture(packet, false);
   hal->transmit_data(type, packet->data + packet->offset, packet->len);
@@ -529,6 +598,13 @@ static void hal_says_data_ready(serial_data_type_t type) {
   packet_receive_data_t *incoming = &incoming_packets[PACKET_TYPE_TO_INBOUND_INDEX(type)];
 
   uint8_t byte;
+#ifdef BLUETOOTH_RTK
+  if(bluetooth_rtk_h5_flag){
+    while(hal->read_data(type, &byte, 1, false) != 0) {
+      hci_h5->rcv(&byte);
+    }
+  } else {
+#endif
   while (hal->read_data(type, &byte, 1, false) != 0) {
     switch (incoming->state) {
       case BRAND_NEW:
@@ -625,6 +701,9 @@ static void hal_says_data_ready(serial_data_type_t type) {
       return;
     }
   }
+#ifdef BLUETOOTH_RTK
+  }
+#endif
 }
 
 // Returns true if the event was intercepted and should not proceed to
@@ -635,12 +714,20 @@ static bool filter_incoming_event(BT_HDR *packet) {
   uint8_t *stream = packet->data;
   uint8_t event_code;
   command_opcode_t opcode;
+#ifdef BLUETOOTH_RTK_COEX
+  if(!bluetooth_rtk_h5_flag)
+    rtk_parse_manager->rtk_parse_internal_event_intercept(stream);
+#endif
 
   STREAM_TO_UINT8(event_code, stream);
   STREAM_SKIP_UINT8(stream); // Skip the parameter total length field
 
   if (event_code == HCI_COMMAND_COMPLETE_EVT) {
     STREAM_TO_UINT8(command_credits, stream);
+#ifdef BLUETOOTH_RTK
+    if(command_credits > 0)
+        command_credits = 1;
+#endif
     STREAM_TO_UINT16(opcode, stream);
 
     wait_entry = get_waiting_command(opcode);
@@ -656,6 +743,10 @@ static bool filter_incoming_event(BT_HDR *packet) {
     uint8_t status;
     STREAM_TO_UINT8(status, stream);
     STREAM_TO_UINT8(command_credits, stream);
+#ifdef BLUETOOTH_RTK
+    if(command_credits > 0)
+        command_credits = 1;
+#endif
     STREAM_TO_UINT16(opcode, stream);
 
     // If a command generates a command status event, it won't be getting a command complete event
@@ -671,8 +762,13 @@ static bool filter_incoming_event(BT_HDR *packet) {
 
   return false;
 intercepted:;
-  non_repeating_timer_restart_if(command_response_timer, !list_is_empty(commands_pending_response));
 
+#ifdef BLUETOOTH_RTK
+  if(!bluetooth_rtk_h5_flag)
+    non_repeating_timer_restart_if(command_response_timer, !list_is_empty(commands_pending_response));
+#else
+    non_repeating_timer_restart_if(command_response_timer, !list_is_empty(commands_pending_response));
+#endif
   if (wait_entry) {
     // If it has a callback, it's responsible for freeing the packet
     if (event_code == HCI_COMMAND_STATUS_EVT || (!wait_entry->complete_callback && !wait_entry->complete_future))
@@ -693,8 +789,21 @@ intercepted:;
 // Callback for the fragmenter to dispatch up a completely reassembled packet
 static void dispatch_reassembled(BT_HDR *packet) {
   // Events should already have been dispatched before this point
+#ifdef BLUETOOTH_RTK
+  if(!bluetooth_rtk_h5_flag)
+    assert((packet->event & MSG_EVT_MASK) != MSG_HC_TO_STACK_HCI_EVT);
+#else
   assert((packet->event & MSG_EVT_MASK) != MSG_HC_TO_STACK_HCI_EVT);
+#endif
   assert(upwards_data_queue != NULL);
+#ifdef BLUETOOTH_RTK_COEX
+  if(!bluetooth_rtk_h5_flag) {
+    if ((packet->event& MSG_EVT_MASK) == MSG_HC_TO_STACK_HCI_ACL) {
+      uint8_t *pp = ((uint8_t *)(packet + 1)) + packet->offset;
+      rtk_parse_manager->rtk_parse_l2cap_data(pp,0);
+    }
+  }
+#endif
 
   if (upwards_data_queue) {
     fixed_queue_enqueue(upwards_data_queue, packet);
@@ -755,6 +864,9 @@ static void init_layer_interface() {
     }
 
     interface.set_data_queue = set_data_queue;
+#ifdef BLUETOOTH_RTK
+    interface.transmit_int_command = transmit_int_command;
+#endif
     interface.transmit_command = transmit_command;
     interface.transmit_command_futured = transmit_command_futured;
     interface.transmit_downward = transmit_downward;
@@ -769,7 +881,12 @@ static const hci_hal_callbacks_t hal_callbacks = {
 static const packet_fragmenter_callbacks_t packet_fragmenter_callbacks = {
   transmit_fragment,
   dispatch_reassembled,
+#ifdef BLUETOOTH_RTK
+  fragmenter_transmit_finished,
+  filter_incoming_event
+#else
   fragmenter_transmit_finished
+#endif
 };
 
 const hci_t *hci_layer_get_interface() {
@@ -781,6 +898,12 @@ const hci_t *hci_layer_get_interface() {
   vendor = vendor_get_interface();
   low_power_manager = low_power_manager_get_interface();
 
+#ifdef BLUETOOTH_RTK
+  hci_h5 =  hci_get_h5_interface();
+#endif
+#ifdef BLUETOOTH_RTK_COEX
+  rtk_parse_manager = rtk_parse_manager_get_interface();
+#endif
   init_layer_interface();
   return &interface;
 }
diff --git a/hci/src/rtk_parse.c b/hci/src/rtk_parse.c
new file mode 100755
index 0000000..0fa9af3
--- /dev/null
+++ b/hci/src/rtk_parse.c
@@ -0,0 +1,2670 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Realtek Corporation.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+*
+*	Module Name:
+*		rtk_parse.c
+*
+*	Abstract:
+*		Contains wifi-bt coex functions implemented by bluedroid stack
+*
+*	Major Change History:
+*	      When             Who       What
+*	 	---------------------------------------------------------------
+*	    2015-12-15      lamparten   modified
+*	    2014-10-23       kyle_xu    modified
+*	Notes:
+*		  This is designed for wifi-bt Coex in Android 6.0.
+*
+******************************************************************************/
+#define LOG_TAG "rtk_parse"
+#define RTKBT_RELEASE_NAME	"Test"
+
+#include <utils/Log.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <termios.h>
+#include <errno.h>
+#include <signal.h>
+#include <time.h>
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <sys/un.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/prctl.h>
+#include <linux/types.h>
+#include <linux/netlink.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <dirent.h>
+#include <signal.h>
+#include <poll.h>
+
+#include "bt_list.h"
+#include "bt_hci_bdroid.h"
+
+
+
+#include "rtk_parse.h"
+#include "hcidefs.h"
+#include <sys/syscall.h>
+
+#define RTK_VERSION "2.1"
+
+char invite_req[] = "INVITE_REQ";
+char invite_rsp[] = "INVITE_RSP";
+char attend_req[] = "ATTEND_REQ";
+char attend_ack[] = "ATTEND_ACK";
+char wifi_leave[] = "WIFI_LEAVE";
+char leave_ack[] =  "LEAVE_ACK";
+char bt_leave[] =   "BT_LEAVE";
+
+#define CONNECT_PORT        30001
+#define CONNECT_PORT_WIFI   30000
+//#define NETLINK_USER        31
+#define MAX_PAYLOAD         255 /* maximum payload size*/
+
+//L2CAP TYPE
+#define L2CAP_CONNECTION_REQ        0x02
+#define L2CAP_CONNECTION_RSP        0x03
+#define L2CAP_DISCONNECTION_REQ     0x06
+#define L2CAP_DISCONNECTION_RSP     0x07
+
+#define TIMER_A2DP_PACKET_COUNT     (SIGRTMAX -5)
+#define TIMER_PAN_PACKET_COUNT      (SIGRTMAX -6)
+#define TIMER_HOGP_PACKET_COUNT     (SIGRTMAX -7)
+#define TIMER_POLLING               (SIGRTMAX -8)
+
+#define PAN_PACKET_COUNT                5
+#define PACKET_COUNT_TIOMEOUT_VALUE     1000//ms
+
+//vendor cmd to fw
+#define HCI_VENDOR_ENABLE_PROFILE_REPORT_COMMAND        (0x0018 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_VENDOR_SET_PROFILE_REPORT_COMMAND           (0x0019 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_VENDOR_MAILBOX_CMD                          (0x008F | HCI_GRP_VENDOR_SPECIFIC)
+
+#define HCI_VENDOR_ADD_BITPOOL_FW                       (0x0051 | HCI_GRP_VENDOR_SPECIFIC)
+
+//subcmd to fw for HCI_VENDOR_MAILBOX_CMD
+#define HCI_VENDOR_SUB_CMD_WIFI_CHANNEL_AND_BANDWIDTH_CMD   0x11
+#define HCI_VENDOR_SUB_CMD_WIFI_FORCE_TX_POWER_CMD          0x17
+#define HCI_VENDOR_SUB_CMD_BT_ENABLE_IGNORE_WLAN_ACT_CMD    0x1B
+#define HCI_VENDOR_SUB_CMD_BT_REPORT_CONN_SCO_INQ_INFO      0x23
+#define HCI_VENDOR_SUB_CMD_BT_AUTO_REPORT_STATUS_INFO       0x27
+#define HCI_VENDOR_SUB_CMD_BT_AUTO_REPORT_ENABLE            0x28
+#define HCI_VENDOR_SUB_CMD_BT_SET_TXRETRY_REPORT_PARAM      0x29
+#define HCI_VENDOR_SUB_CMD_BT_SET_PTATABLE                  0x2A
+#define HCI_VENDOR_SUB_CMD_SET_BT_PSD_MODE                  0x31
+#define HCI_VENDOR_SUB_CMD_SET_BT_LNA_CONSTRAINT            0x32
+#define HCI_VENDOR_SUB_CMD_GET_AFH_MAP_L                    0x40
+#define HCI_VENDOR_SUB_CMD_GET_AFH_MAP_M                    0x41
+#define HCI_VENDOR_SUB_CMD_GET_AFH_MAP_H                    0x42
+#define HCI_VENDOR_SUB_CMD_RD_REG_REQ                       0x43
+#define HCI_VENDOR_SUB_CMD_WR_REG_REQ                       0x44
+
+//sub event from fw
+#define HCI_VENDOR_PTA_REPORT_EVENT         0x24
+#define    HCI_VENDOR_PTA_AUTO_REPORT_EVENT    0x25
+
+//vendor cmd to wifi driver
+#define HCI_OP_HCI_EXTENSION_VERSION_NOTIFY (0x0100 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_OP_BT_OPERATION_NOTIFY          (0x0102 | HCI_GRP_VENDOR_SPECIFIC)
+#define    HCI_OP_HCI_BT_INFO_NOTIFY           (0x0106 | HCI_GRP_VENDOR_SPECIFIC)
+#define    HCI_OP_HCI_BT_COEX_NOTIFY           (0x0107 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_OP_HCI_BT_PATCH_VER_NOTIFY      (0x0108 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_OP_HCI_BT_AFH_MAP_NOTIFY        (0x0109 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_OP_HCI_BT_REGISTER_VALUE_NOTIFY (0x010a | HCI_GRP_VENDOR_SPECIFIC)
+
+//bt operation to notify for HCI_OP_BT_OPERATION_NOTIFY
+#define BT_OPCODE_NONE                  0
+#define BT_OPCODE_INQUIRY_START         1
+#define BT_OPCODE_INQUIRY_END           2
+#define BT_OPCODE_PAGE_START            3
+#define BT_OPCODE_PAGE_SUCCESS_END      4
+#define BT_OPCODE_PAGE_UNSUCCESS_END    5
+#define BT_OPCODE_PAIR_START            6
+#define BT_OPCODE_PAIR_END              7
+#define BT_OPCODE_ENABLE_BT             8
+#define BT_OPCODE_DISABLE_BT            9
+
+//bt info reason to wifi for HCI_OP_HCI_BT_INFO_NOTIFY
+#define HOST_RESPONSE                   0 //Host response when receive the BT Info Control Event
+#define POLLING_RESPONSE                1 //The BT Info response for polling by BT firmware.
+#define AUTO_REPORT                     2 //BT auto report by BT firmware.
+#define STACK_REPORT_WHILE_DEVICE_D2    3 //Stack report when BT firmware is under power save state(ex:D2)
+
+// vendor event from wifi
+#define RTK_HS_EXTENSION_EVENT_WIFI_SCAN            0x01
+#define RTK_HS_EXTENSION_EVENT_RADIO_STATUS_NOTIFY  0x02
+#define RTK_HS_EXTENSION_EVENT_HCI_BT_INFO_CONTROL  0x03
+#define RTK_HS_EXTENSION_EVENT_HCI_BT_COEX_CONTROL  0x04
+
+//op code from wifi for RTK_HS_EXTENSION_EVENT_HCI_BT_COEX_CONTROL
+#define BT_PATCH_VERSION_QUERY      0x00
+#define IGNORE_WLAN_ACTIVE_CONTROL  0x01
+#define LNA_CONSTRAIN_CONTROL       0x02
+#define BT_POWER_DECREASE_CONTROL   0x03
+#define BT_PSD_MODE_CONTROL         0x04
+#define WIFI_BW_CHNL_NOTIFY         0x05
+#define QUERY_BT_AFH_MAP            0x06
+#define BT_REGISTER_ACCESS          0x07
+
+#define HCI_EXTENSION_VERSION   0x0004
+
+#define HCI_CMD_PREAMBLE_SIZE   3
+
+#define PSM_SDP     0x0001
+#define PSM_RFCOMM  0x0003
+#define PSM_PAN     0x000F
+#define PSM_HID     0x0011
+#define PSM_HID_INT 0x0013
+#define PSM_AVCTP   0x0017
+#define PSM_AVDTP   0x0019
+#define PSM_FTP     0x1001
+#define PSM_BIP     0x1003
+#define PSM_OPP     0x1015
+//--Add more if needed--//
+
+enum {
+    profile_sco = 0,
+    profile_hid = 1,
+    profile_a2dp = 2,
+    profile_pan = 3,
+    profile_hid_interval = 4,
+    profile_hogp = 5,
+    profile_voice = 6,
+    profile_max = 7
+};
+
+//profile info data
+typedef struct RTK_PROF_INFO {
+    RT_LIST_ENTRY   list;
+    uint16_t        handle;
+    uint16_t        psm;
+    uint16_t        dcid;
+    uint16_t        scid;
+    uint8_t         profile_index;
+}tRTK_PROF_INFO;
+
+//profile info for each connection
+typedef struct RTK_CONN_PROF {
+    RT_LIST_ENTRY list;
+    uint16_t handle;
+    uint8_t type;                   //0:l2cap, 1:sco/esco, 2:le
+    uint8_t profile_bitmap;         //0:SCO, 1:HID, 2:A2DP, 3:FTP/PAN/OPP, 4: HID_interval, 5:HOGP, 6:VOICE
+    int8_t  profile_refcount[8];    //0:SCO, 1:HID, 2:A2DP, 3:FTP/PAN/OPP, 4:TBD, 5:HOGP, 6:VOICE
+}tRTK_CONN_PROF;
+
+//profile info for all
+typedef struct RTK_PROF {
+    RT_LIST_HEAD    conn_hash;      //hash for connections
+    RT_LIST_HEAD    profile_list;   //hash for profile info
+    pthread_mutex_t profile_mutex;
+    pthread_mutex_t udpsocket_mutex;
+    pthread_t thread_monitor;
+    pthread_t thread_data;
+    timer_t  timer_a2dp_packet_count;
+    timer_t  timer_pan_packet_count;
+    timer_t  timer_hogp_packet_count;
+    timer_t  timer_polling;
+    //struct sockaddr_nl src_addr;    //for netlink
+    struct sockaddr_in server_addr; //server addr for kernel socket
+    struct sockaddr_in client_addr; //client addr  for kernel socket
+    uint32_t a2dp_packet_count;
+    uint32_t pan_packet_count;
+    uint32_t hogp_packet_count;
+    uint32_t voice_packet_count;
+    uint8_t  profile_bitmap;
+    uint8_t  profile_status;
+    int8_t   profile_refcount[8];
+    uint8_t  ispairing;
+    uint8_t  isinquirying;
+    uint8_t  ispaging;
+    uint8_t  wifi_state;
+    uint8_t  autoreport;
+    uint8_t  polling_enable;
+    uint8_t  polling_interval;
+    volatile uint8_t udpsocket_recv_thread_running;
+    //int32_t   nlsocket;
+    int32_t   udpsocket;
+    uint8_t  piconet_id;
+    uint8_t  mode;
+    uint8_t  afh_map[10];
+    uint16_t hci_reversion;
+    uint16_t lmp_subversion;
+    uint8_t  wifi_on;
+    //uint8_t  le_profile_index;
+}tRTK_PROF;
+
+typedef struct HCI_RETURN_PARAMETER_MAILBOX_REGISTER {
+    uint8_t  type;
+    uint32_t offset;
+    uint32_t value;
+}tHCI_RETURN_PARAMETER_MAILBOX_REGISTER;
+
+typedef struct HCI_EVENT_BT_INFO_CONTROL {
+    uint8_t     polling_enable;
+    uint8_t     polling_time;
+    uint8_t     autoreport_enable;
+}tHCI_EVENT_BT_INFO_CONTROL;
+
+tRTK_PROF rtk_prof;
+volatile int poweroff_allowed = 0;
+uint8_t coex_log_enable = 0;
+static const hci_t *hci_interface;
+
+static const allocator_t *buffer_allocator;
+
+
+#define BIT(_I)                         (uint16_t)(1<<(_I))
+#define is_profile_connected(profile)   ((rtk_prof.profile_bitmap & BIT(profile)) >0)
+#define is_profile_busy(profile)        ((rtk_prof.profile_status & BIT(profile)) >0)
+
+static void timeout_handler(int signo, siginfo_t * info, void *context);
+
+#ifndef RTK_PARSE_LOG_BUF_SIZE
+#define RTK_PARSE_LOG_BUF_SIZE  1024
+#endif
+#define RTK_PARSE_LOG_MAX_SIZE  (RTK_PARSE_LOG_BUF_SIZE - 12)
+
+#define LOGI0(t,s) __android_log_write(ANDROID_LOG_INFO, t, s)
+static void LogMsg(const char *fmt_str, ...)
+{
+    static char buffer[RTK_PARSE_LOG_BUF_SIZE];
+    if(coex_log_enable)
+    {
+        va_list ap;
+        va_start(ap, fmt_str);
+        vsnprintf(&buffer[0], RTK_PARSE_LOG_MAX_SIZE, fmt_str, ap);
+        va_end(ap);
+
+        LOGI0("rtk_parse: ", buffer);
+    }
+    else
+    {
+        return;
+    }
+}
+
+static timer_t OsAllocateTimer(int signo)
+{
+    struct sigevent sigev;
+    timer_t timerid = (timer_t)-1;
+
+    // Create the POSIX timer to generate signo
+    sigev.sigev_notify = SIGEV_THREAD_ID;
+    sigev.sigev_notify_thread_id = syscall(__NR_gettid);
+    sigev.sigev_signo = signo;
+    sigev.sigev_value.sival_ptr = &timerid;
+
+    ALOGE("OsAllocateTimer rtk_parse sigev.sigev_notify_thread_id = syscall(__NR_gettid)!");
+
+    //Create the Timer using timer_create signal
+    if (timer_create(CLOCK_REALTIME, &sigev, &timerid) == 0)
+    {
+        return timerid;
+    }
+    else
+    {
+        ALOGE("timer_create error!");
+        return (timer_t)-1;
+    }
+}
+
+static int OsFreeTimer(timer_t timerid)
+{
+    int ret = 0;
+    ret = timer_delete(timerid);
+    if(ret != 0)
+        ALOGE("timer_delete fail with errno(%d)", errno);
+
+    return ret;
+}
+
+static int OsStartTimer(timer_t timerid, int msec, int mode)
+{
+    struct itimerspec itval;
+
+    itval.it_value.tv_sec = msec / 1000;
+    itval.it_value.tv_nsec = (long)(msec % 1000) * (1000000L);
+
+    if (mode == 1)
+    {
+        itval.it_interval.tv_sec  = itval.it_value.tv_sec;
+        itval.it_interval.tv_nsec = itval.it_value.tv_nsec;
+    }
+    else
+    {
+        itval.it_interval.tv_sec = 0;
+        itval.it_interval.tv_nsec = 0;
+    }
+
+    //Set the Timer when to expire through timer_settime
+    if (timer_settime(timerid, 0, &itval, NULL) != 0)
+    {
+        ALOGE("time_settime error!");
+        return -1;
+    }
+
+    return 0;
+}
+
+static int OsStopTimer(timer_t timerid)
+{
+    return OsStartTimer(timerid, 0, 0);
+}
+
+int alloc_polling_timer()
+{
+    struct sigaction sigact;
+
+    sigemptyset(&sigact.sa_mask);
+    sigact.sa_flags = SA_SIGINFO;
+
+    //register the Signal Handler
+    sigact.sa_sigaction = timeout_handler;
+
+    // Set up sigaction to catch signal first timer
+    if (sigaction(TIMER_POLLING, &sigact, NULL) == -1)
+    {
+        ALOGE("alloc_polling_timer, sigaction failed");
+        return -1;
+    }
+
+    // Create and set the timer when to expire
+    rtk_prof.timer_polling= OsAllocateTimer(TIMER_POLLING);
+    LogMsg("alloc polling timer");
+
+    return 0;
+}
+
+int free_polling_timer()
+{
+    return OsFreeTimer(rtk_prof.timer_polling);
+}
+
+int stop_polling_timer()
+{
+    LogMsg("stop polling timer");
+    return OsStopTimer(rtk_prof.timer_polling);
+}
+
+int start_polling_timer(int value)
+{
+    LogMsg("start polling timer");
+    return OsStartTimer(rtk_prof.timer_polling, value, 1);
+}
+
+int alloc_hogp_packet_count_timer()
+{
+    struct sigaction sigact;
+
+    sigemptyset(&sigact.sa_mask);
+    sigact.sa_flags = SA_SIGINFO;
+
+    //register the Signal Handler
+    sigact.sa_sigaction = timeout_handler;
+
+    // Set up sigaction to catch signal first timer
+    if (sigaction(TIMER_HOGP_PACKET_COUNT, &sigact, NULL) == -1)
+    {
+        ALOGE("alloc_hogp_packet_count_timer, sigaction failed");
+        return -1;
+    }
+
+    // Create and set the timer when to expire
+    rtk_prof.timer_hogp_packet_count= OsAllocateTimer(TIMER_HOGP_PACKET_COUNT);
+    LogMsg("alloc hogp packet");
+
+    return 0;
+}
+
+int free_hogp_packet_count_timer()
+{
+    return OsFreeTimer(rtk_prof.timer_hogp_packet_count);
+}
+
+int stop_hogp_packet_count_timer()
+{
+    LogMsg("stop hogp packet");
+    return OsStopTimer(rtk_prof.timer_hogp_packet_count);
+}
+
+int start_hogp_packet_count_timer()
+{
+    LogMsg("start hogp packet");
+    return OsStartTimer(rtk_prof.timer_hogp_packet_count, PACKET_COUNT_TIOMEOUT_VALUE, 1);
+}
+
+int alloc_a2dp_packet_count_timer()
+{
+    struct sigaction sigact;
+
+    sigemptyset(&sigact.sa_mask);
+    sigact.sa_flags = SA_SIGINFO;
+
+    //register the Signal Handler
+    sigact.sa_sigaction = timeout_handler;
+
+    // Set up sigaction to catch signal first timer
+    if (sigaction(TIMER_A2DP_PACKET_COUNT, &sigact, NULL) == -1)
+    {
+        ALOGE("alloc_a2dp_packet_count_timer, sigaction failed");
+        return -1;
+    }
+
+    // Create and set the timer when to expire
+    rtk_prof.timer_a2dp_packet_count= OsAllocateTimer(TIMER_A2DP_PACKET_COUNT);
+    LogMsg("alloc a2dp packet");
+
+    return 0;
+}
+
+int free_a2dp_packet_count_timer()
+{
+    return OsFreeTimer(rtk_prof.timer_a2dp_packet_count);
+}
+
+int stop_a2dp_packet_count_timer()
+{
+    LogMsg("stop a2dp packet");
+    return OsStopTimer(rtk_prof.timer_a2dp_packet_count);
+}
+
+int start_a2dp_packet_count_timer()
+{
+    LogMsg("start a2dp packet");
+    return OsStartTimer(rtk_prof.timer_a2dp_packet_count, PACKET_COUNT_TIOMEOUT_VALUE, 1);
+}
+
+int alloc_pan_packet_count_timer()
+{
+    struct sigaction sigact;
+
+    sigemptyset(&sigact.sa_mask);
+    sigact.sa_flags = SA_SIGINFO;
+
+    //register the Signal Handler
+    sigact.sa_sigaction = timeout_handler;
+
+    // Set up sigaction to catch signal first timer
+    if (sigaction(TIMER_PAN_PACKET_COUNT, &sigact, NULL) == -1)
+    {
+        ALOGE("alloc_pan_packet_count_timer, sigaction failed");
+        return -1;
+    }
+
+    // Create and set the timer when to expire
+    rtk_prof.timer_pan_packet_count= OsAllocateTimer(TIMER_PAN_PACKET_COUNT);
+
+    LogMsg("alloc pan packet");
+    return 0;
+}
+
+int free_pan_packet_count_timer()
+{
+    return OsFreeTimer(rtk_prof.timer_pan_packet_count);
+}
+
+int stop_pan_packet_count_timer()
+{
+    LogMsg("stop pan packet");
+    return OsStopTimer(rtk_prof.timer_pan_packet_count);
+}
+
+int start_pan_packet_count_timer()
+{
+    LogMsg("start pan packet");
+    return OsStartTimer(rtk_prof.timer_pan_packet_count, PACKET_COUNT_TIOMEOUT_VALUE, 1);
+}
+
+static int8_t psm_to_profile_index(uint16_t psm)
+{
+    switch (psm) {
+        case PSM_AVCTP:
+        case PSM_SDP:
+            return -1;   //ignore
+
+        case PSM_HID:
+        case PSM_HID_INT:
+            return profile_hid;
+
+        case PSM_AVDTP:
+            return profile_a2dp;
+
+        case PSM_PAN:
+        case PSM_OPP:
+        case PSM_FTP:
+        case PSM_BIP:
+        case PSM_RFCOMM:
+            return profile_pan;
+
+        default:
+            return profile_pan;
+    }
+}
+
+tRTK_CONN_PROF* find_connection_by_handle(tRTK_PROF* h5, uint16_t handle)
+{
+    RT_LIST_HEAD* head = &h5->conn_hash;
+    RT_LIST_ENTRY* iter = NULL, *temp = NULL;
+    tRTK_CONN_PROF* desc = NULL;
+
+    LIST_FOR_EACH_SAFELY(iter, temp, head)
+    {
+        desc = LIST_ENTRY(iter, tRTK_CONN_PROF, list);
+        if ((handle & 0xEFF) == desc->handle )  //only last 12 bit are meanful for hci handle
+        {
+            return desc;
+        }
+    }
+    return NULL;
+}
+
+tRTK_CONN_PROF* allocate_connection_by_handle(uint16_t handle)
+{
+    tRTK_CONN_PROF * phci_conn = NULL;
+    phci_conn = malloc(sizeof(tRTK_CONN_PROF));
+    if(phci_conn)
+        phci_conn->handle = handle;
+
+    return phci_conn;
+}
+
+void init_connection_hash(tRTK_PROF* h5)
+{
+    RT_LIST_HEAD* head = &h5->conn_hash;
+    ListInitializeHeader(head);
+}
+
+void add_connection_to_hash(tRTK_PROF* h5, tRTK_CONN_PROF* desc)
+{
+    RT_LIST_HEAD* head = &h5->conn_hash;
+    ListAddToTail(&desc->list, head);
+}
+
+void delete_connection_from_hash(tRTK_CONN_PROF* desc)
+{
+    if (desc)
+    {
+        ListDeleteNode(&desc->list);
+        free(desc);
+    }
+}
+
+void flush_connection_hash(tRTK_PROF* h5)
+{
+    RT_LIST_HEAD* head = &h5->conn_hash;
+    RT_LIST_ENTRY* iter = NULL, *temp = NULL;
+    tRTK_CONN_PROF* desc = NULL;
+
+    LIST_FOR_EACH_SAFELY(iter, temp, head)
+    {
+        desc = LIST_ENTRY(iter, tRTK_CONN_PROF, list);
+        if (desc)
+        {
+            ListDeleteNode(&desc->list);
+            free(desc);
+        }
+    }
+    //ListInitializeHeader(head);
+}
+
+void init_profile_hash(tRTK_PROF* h5)
+{
+    RT_LIST_HEAD* head = &h5->profile_list;
+    ListInitializeHeader(head);
+}
+
+uint8_t list_allocate_add(uint16_t handle, uint16_t psm, int8_t profile_index, uint16_t dcid, uint16_t scid)
+{
+    tRTK_PROF_INFO* pprof_info = NULL;
+
+    if(profile_index < 0)
+    {
+        ALOGE("PSM(0x%x) do not need parse", psm);
+        return FALSE;
+    }
+
+    pprof_info = malloc(sizeof(tRTK_PROF_INFO));
+    if (NULL == pprof_info)
+    {
+        ALOGE("list_allocate_add: allocate error");
+        return FALSE;
+    }
+
+    pprof_info->handle = handle;
+    pprof_info->psm = psm;
+    pprof_info->scid = scid;
+    pprof_info->dcid = dcid;
+    pprof_info->profile_index = profile_index;
+
+    ListAddToTail(&(pprof_info->list), &(rtk_prof.profile_list));
+
+    return TRUE;
+}
+
+void delete_profile_from_hash(tRTK_PROF_INFO* desc)
+{
+    LogMsg("delete profile for handle: %x, psm:%x, dcid:%x, scid:%x", desc->handle, desc->psm, desc->dcid, desc->scid);
+    if (desc)
+    {
+        ListDeleteNode(&desc->list);
+        free(desc);
+        desc = NULL;
+    }
+}
+
+void flush_profile_hash(tRTK_PROF* h5)
+{
+    RT_LIST_HEAD* head = &h5->profile_list;
+    RT_LIST_ENTRY* iter = NULL, *temp = NULL;
+    tRTK_PROF_INFO* desc = NULL;
+
+    pthread_mutex_lock(&rtk_prof.profile_mutex);
+    LIST_FOR_EACH_SAFELY(iter, temp, head)
+    {
+        desc = LIST_ENTRY(iter, tRTK_PROF_INFO, list);
+        delete_profile_from_hash(desc);
+    }
+    //ListInitializeHeader(head);
+    pthread_mutex_unlock(&rtk_prof.profile_mutex);
+}
+
+tRTK_PROF_INFO* find_profile_by_handle_scid(tRTK_PROF* h5, uint16_t handle, uint16_t scid)
+{
+    RT_LIST_HEAD* head = &h5->profile_list;
+    RT_LIST_ENTRY* iter = NULL, *temp = NULL;
+    tRTK_PROF_INFO* desc = NULL;
+
+    LIST_FOR_EACH_SAFELY(iter, temp, head)
+    {
+        desc = LIST_ENTRY(iter, tRTK_PROF_INFO, list);
+        if (((handle & 0xFFF) == desc->handle ) && (scid == desc->scid))
+        {
+            return desc;
+        }
+    }
+    return NULL;
+}
+
+tRTK_PROF_INFO* find_profile_by_handle_dcid(tRTK_PROF* h5, uint16_t handle, uint16_t dcid)
+{
+    RT_LIST_HEAD* head = &h5->profile_list;
+    RT_LIST_ENTRY* iter = NULL, *temp = NULL;
+    tRTK_PROF_INFO* desc = NULL;
+
+    LIST_FOR_EACH_SAFELY(iter, temp, head)
+    {
+        desc = LIST_ENTRY(iter, tRTK_PROF_INFO, list);
+        if (((handle & 0xFFF) == desc->handle ) && (dcid == desc->dcid))
+        {
+            return desc;
+        }
+    }
+    return NULL;
+}
+
+tRTK_PROF_INFO* find_profile_by_handle_dcid_scid(tRTK_PROF* h5, uint16_t handle, uint16_t dcid, uint16_t scid)
+{
+    RT_LIST_HEAD* head = &h5->profile_list;
+    RT_LIST_ENTRY* iter = NULL, *temp = NULL;
+    tRTK_PROF_INFO* desc = NULL;
+
+    LIST_FOR_EACH_SAFELY(iter, temp, head)
+    {
+        desc = LIST_ENTRY(iter, tRTK_PROF_INFO, list);
+        if (((handle & 0xFFF) == desc->handle ) && (dcid == desc->dcid) && (scid == desc->scid))
+        {
+            return desc;
+        }
+    }
+    return NULL;
+}
+
+void rtk_vendor_cmd_to_fw(uint16_t opcode, uint8_t parameter_len, uint8_t* parameter)
+{
+    uint8_t temp = 0;
+    HC_BT_HDR  *p_buf=NULL;
+
+    if(buffer_allocator)
+        p_buf = (HC_BT_HDR *) buffer_allocator->alloc(BT_HC_HDR_SIZE + HCI_CMD_PREAMBLE_SIZE + parameter_len);
+
+    if(NULL == p_buf)
+    {
+        ALOGE("rtk_vendor_cmd_to_fw: HC_BT_HDR alloc error");
+        return;
+    }
+    p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
+    p_buf->offset = 0;
+    p_buf->len = HCI_CMD_PREAMBLE_SIZE + parameter_len;
+    p_buf->layer_specific = 0;
+
+    uint8_t *p = (uint8_t *) (p_buf + 1);
+    UINT16_TO_STREAM(p, opcode);
+    LogMsg("rtk_vendor_cmd_to_fw: Opcode:%x",opcode);
+
+    if(parameter_len > 0)
+    {
+        *p++ = parameter_len;
+        memcpy(p, parameter, parameter_len);
+    }
+    if(hci_interface)
+    {
+            ALOGE("hci_interface->transmit_command Opcode:%x",opcode);
+            hci_interface->transmit_command((BT_HDR *)p_buf, NULL,NULL,NULL);
+    }
+    return ;
+}
+
+void rtk_notify_profileinfo_to_fw()
+{
+    RT_LIST_HEAD* head = NULL;
+    RT_LIST_ENTRY* iter = NULL, *temp = NULL;
+    tRTK_CONN_PROF* hci_conn = NULL;
+    uint8_t  handle_number = 0;
+    uint32_t buffer_size = 0;
+    uint8_t *p_buf = NULL;
+
+    head = &rtk_prof.conn_hash;
+    LIST_FOR_EACH_SAFELY(iter, temp, head)
+    {
+        hci_conn = LIST_ENTRY(iter, tRTK_CONN_PROF, list);
+        if (hci_conn && hci_conn->profile_bitmap)
+            handle_number++;
+    }
+
+    buffer_size = 1 + handle_number*3 + 1;
+
+    if(buffer_allocator)
+        p_buf = (uint8_t *) buffer_allocator->alloc(buffer_size);
+
+    if(NULL == p_buf)
+    {
+        ALOGE("rtk_notify_profileinfo_to_fw: alloc error");
+        return;
+    }
+    uint8_t *p = (uint8_t *)p_buf;
+
+    LogMsg("rtk_notify_profileinfo_to_fw, BufferSize is %x", buffer_size);
+    *p++ = handle_number;
+    LogMsg("rtk_notify_profileinfo_to_fw, NumberOfHandles is %x", handle_number);
+    head = &rtk_prof.conn_hash;
+    LIST_FOR_EACH_SAFELY(iter, temp, head)
+    {
+        hci_conn = LIST_ENTRY(iter, tRTK_CONN_PROF, list);
+        if (hci_conn && hci_conn->profile_bitmap)
+        {
+            UINT16_TO_STREAM(p, hci_conn->handle);
+            LogMsg("rtk_notify_profileinfo_to_fw, handle is %x",hci_conn->handle);
+            *p++ = hci_conn->profile_bitmap;
+            LogMsg("rtk_notify_profileinfo_to_fw, profile_bitmap is %x",hci_conn->profile_bitmap);
+            handle_number --;
+        }
+        if(0 == handle_number)
+            break;
+    }
+
+    *p++ = rtk_prof.profile_status;
+    LogMsg("rtk_notify_profileinfo_to_fw, profile_status is %x",rtk_prof.profile_status);
+
+    rtk_vendor_cmd_to_fw(HCI_VENDOR_SET_PROFILE_REPORT_COMMAND, buffer_size, p_buf);
+
+    if(buffer_allocator)
+       buffer_allocator->free(p_buf);
+
+    return ;
+}
+
+void update_profile_state(uint8_t profile_index, uint8_t is_busy)
+{
+    uint8_t need_update = FALSE;
+
+    if((rtk_prof.profile_bitmap & BIT(profile_index)) == 0)
+    {
+        ALOGE("update_profile_state: ERROR!!! profile(Index: %x) does not exist", profile_index);
+        return;
+    }
+
+    if(is_busy)
+    {
+        if((rtk_prof.profile_status & BIT(profile_index)) == 0)
+        {
+            need_update = TRUE;
+            rtk_prof.profile_status |= BIT(profile_index);
+        }
+    }
+    else
+    {
+        if((rtk_prof.profile_status & BIT(profile_index)) > 0)
+        {
+            need_update = TRUE;
+            rtk_prof.profile_status &= ~(BIT(profile_index));
+        }
+    }
+
+    if(need_update)
+    {
+        LogMsg("update_profile_state, rtk_prof.profie_bitmap = %x", rtk_prof.profile_bitmap);
+        LogMsg("update_profile_state, rtk_prof.profile_status = %x", rtk_prof.profile_status);
+        rtk_notify_profileinfo_to_fw();
+    }
+}
+
+void rtk_check_setup_timer(int8_t profile_index)
+{
+    if(profile_index == profile_a2dp) {
+        rtk_prof.a2dp_packet_count = 0;
+        start_a2dp_packet_count_timer();
+    }
+    if(profile_index == profile_pan) {
+        rtk_prof.pan_packet_count = 0;
+        start_pan_packet_count_timer();
+    }
+    //hogp & voice share one timer now
+    if((profile_index == profile_hogp) || (profile_index == profile_voice)) {
+        if((0 == rtk_prof.profile_refcount[profile_hogp])
+                && (0 == rtk_prof.profile_refcount[profile_voice])) {
+            rtk_prof.hogp_packet_count = 0;
+            rtk_prof.voice_packet_count = 0;
+            start_hogp_packet_count_timer();
+        }
+    }
+}
+
+void rtk_check_del_timer(int8_t profile_index)
+{
+    if(profile_a2dp == profile_index)
+    {
+        rtk_prof.a2dp_packet_count = 0;
+        stop_a2dp_packet_count_timer();
+    }
+    if(profile_pan == profile_index)
+    {
+        rtk_prof.pan_packet_count = 0;
+        stop_pan_packet_count_timer();
+    }
+    if(profile_hogp == profile_index)
+    {
+        rtk_prof.hogp_packet_count = 0;
+        if(rtk_prof.profile_refcount[profile_voice] == 0)
+            stop_hogp_packet_count_timer();
+    }
+    if(profile_voice == profile_index)
+    {
+        rtk_prof.voice_packet_count = 0;
+        if(rtk_prof.profile_refcount[profile_hogp] == 0)
+            stop_hogp_packet_count_timer();
+    }
+}
+void update_profile_connection(tRTK_CONN_PROF * phci_conn, int8_t profile_index, uint8_t is_add)
+{
+    uint8_t need_update = FALSE;
+    int kk = 0;
+
+    LogMsg("update_profile_connection: is_add=%d, psm_index=%d", is_add, profile_index);
+    if (profile_index < 0)
+        return;
+
+    if(is_add)
+    {
+        if(rtk_prof.profile_refcount[profile_index] == 0)
+        {
+            need_update = TRUE;
+            rtk_prof.profile_bitmap |= BIT(profile_index);
+
+            //SCO is always busy
+            if(profile_index == profile_sco)
+                rtk_prof.profile_status |= BIT(profile_index);
+
+            rtk_check_setup_timer(profile_index);
+        }
+        rtk_prof.profile_refcount[profile_index]++;
+
+        if(0 == phci_conn->profile_refcount[profile_index])
+        {
+            need_update = TRUE;
+            phci_conn->profile_bitmap |= BIT(profile_index);
+        }
+        phci_conn->profile_refcount[profile_index]++;
+    }
+    else
+    {
+        rtk_prof.profile_refcount[profile_index]--;
+        LogMsg("for test: --, rtk_prof.profile_refcount[%x] = %x", profile_index, rtk_prof.profile_refcount[profile_index]);
+        if(rtk_prof.profile_refcount[profile_index] == 0)
+        {
+            need_update = TRUE;
+            rtk_prof.profile_bitmap &= ~(BIT(profile_index));
+
+            //If profile does not exist, Status is meaningless
+            rtk_prof.profile_status &= ~(BIT(profile_index));
+            rtk_check_del_timer(profile_index);
+        }
+
+        phci_conn->profile_refcount[profile_index]--;
+        if(0 == phci_conn->profile_refcount[profile_index])
+        {
+            need_update = TRUE;
+            phci_conn->profile_bitmap &= ~(BIT(profile_index));
+
+            //clear profile_hid_interval if need
+            if(profile_hid == profile_index)
+            {
+                if((phci_conn->profile_bitmap &(BIT(profile_hid_interval))))
+                {
+                    phci_conn->profile_bitmap &= ~(BIT(profile_hid_interval));
+                    rtk_prof.profile_refcount[profile_hid_interval]--;
+                }
+            }
+        }
+    }
+
+    if(need_update)
+    {
+        LogMsg("update_profile_connection: rtk_h5.profile_bitmap = %x", rtk_prof.profile_bitmap);
+        for(kk=0; kk<8; kk++)
+            LogMsg("update_profile_connection: rtk_h5.profile_refcount[%d] = %d", kk, rtk_prof.profile_refcount[kk]);
+        rtk_notify_profileinfo_to_fw();
+    }
+}
+
+void update_hid_active_state(uint16_t handle, uint16_t interval)
+{
+    uint8_t need_update = 0;
+    LogMsg("update_hid_active_state: handle = %x, interval = 0x%x", handle, interval);
+    tRTK_CONN_PROF *phci_conn = find_connection_by_handle(&rtk_prof, handle);
+
+    if(phci_conn == NULL)
+        return;
+
+    if(((phci_conn->profile_bitmap)&(BIT(profile_hid))) == 0)
+    {
+        LogMsg("hid not connected in the handle, nothing to be down");
+        return;
+    }
+
+    if(interval < 60)
+    {
+        if((phci_conn->profile_bitmap &(BIT(profile_hid_interval))) == 0)
+        {
+            need_update = 1;
+            phci_conn->profile_bitmap |= BIT(profile_hid_interval);
+
+            rtk_prof.profile_refcount[profile_hid_interval]++;
+            if(rtk_prof.profile_refcount[profile_hid_interval] == 1)
+                rtk_prof.profile_status |= BIT(profile_hid);
+        }
+    }
+    else
+    {
+        if((phci_conn->profile_bitmap &(BIT(profile_hid_interval))))
+        {
+            need_update = 1;
+            phci_conn->profile_bitmap &= ~(BIT(profile_hid_interval));
+
+            rtk_prof.profile_refcount[profile_hid_interval]--;
+            if(rtk_prof.profile_refcount[profile_hid_interval] == 0)
+                rtk_prof.profile_status &= ~(BIT(profile_hid));
+        }
+    }
+
+    if(need_update)
+        rtk_notify_profileinfo_to_fw();
+}
+uint8_t handle_l2cap_con_req(uint16_t handle, uint16_t psm, uint16_t scid, uint8_t direction)
+{
+    uint8_t status = FALSE;
+    tRTK_PROF_INFO* prof_info = NULL;
+
+    int8_t profile_index = psm_to_profile_index(psm);
+
+    if(profile_index < 0) {
+        LogMsg("PSM(0x%x) do not need parse", psm);
+        return status;
+    }
+
+    pthread_mutex_lock(&rtk_prof.profile_mutex);
+    if(direction)//1: out
+        prof_info = find_profile_by_handle_scid(&rtk_prof, handle, scid);
+    else // 0:in
+        prof_info = find_profile_by_handle_dcid(&rtk_prof, handle, scid);
+
+    if(prof_info)
+    {
+        LogMsg("handle_l2cap_con_req: This profile is already exist!!!");
+        pthread_mutex_unlock(&rtk_prof.profile_mutex);
+        return status;
+    }
+
+    if(direction)//1: out
+        status = list_allocate_add(handle, psm, profile_index, 0, scid);
+    else // 0:in
+        status = list_allocate_add(handle, psm, profile_index, scid, 0);
+
+    pthread_mutex_unlock(&rtk_prof.profile_mutex);
+
+    if (!status)
+        ALOGE("handle_l2cap_con_req: list_allocate_add failed!");
+
+    return status;
+}
+
+uint8_t handle_l2cap_con_rsp(uint16_t handle, uint16_t dcid, uint16_t scid, uint8_t direction, uint8_t result)
+{
+    tRTK_PROF_INFO* prof_info = NULL;
+
+    pthread_mutex_lock(&rtk_prof.profile_mutex);
+    if(!direction)//0, in
+        prof_info = find_profile_by_handle_scid(&rtk_prof, handle, scid);
+    else //1, out
+        prof_info = find_profile_by_handle_dcid(&rtk_prof, handle, scid);
+
+    if (!prof_info)
+    {
+        //LogMsg("handle_l2cap_con_rsp: prof_info Not Find!!");
+        pthread_mutex_unlock(&rtk_prof.profile_mutex);
+        return 0;
+    }
+
+    if(!result)//success
+    {
+        LogMsg("l2cap connection success, update connection");
+        if(!direction)//0, in
+            prof_info->dcid = dcid;
+        else//1, out
+            prof_info->scid = dcid;
+
+        tRTK_CONN_PROF *phci_conn = find_connection_by_handle(&rtk_prof, handle);
+        if(phci_conn)
+            update_profile_connection(phci_conn, prof_info->profile_index, TRUE);
+    }
+
+    pthread_mutex_unlock(&rtk_prof.profile_mutex);
+    return 1;
+}
+
+uint8_t handle_l2cap_discon_req(uint16_t handle, uint16_t dcid, uint16_t scid, uint8_t direction)
+{
+    tRTK_PROF_INFO* prof_info = NULL;
+    LogMsg("l2cap_discon_req, handle = %x, dcid = %x, scid = %x, direction = %x", handle, dcid, scid, direction);
+    pthread_mutex_lock(&rtk_prof.profile_mutex);
+    if(!direction)//0: in
+        prof_info = find_profile_by_handle_dcid_scid(&rtk_prof, handle, scid, dcid);
+    else //1: out
+        prof_info = find_profile_by_handle_dcid_scid(&rtk_prof, handle, dcid, scid);
+
+    if (!prof_info)
+    {
+        //LogMsg("handle_l2cap_discon_req: prof_info Not Find!");
+        pthread_mutex_unlock(&rtk_prof.profile_mutex);
+        return 0;
+    }
+
+    tRTK_CONN_PROF *phci_conn = find_connection_by_handle(&rtk_prof, handle);
+    if(NULL == phci_conn)
+    {
+        pthread_mutex_unlock(&rtk_prof.profile_mutex);
+        return 0;
+    }
+
+    update_profile_connection(phci_conn, prof_info->profile_index, FALSE);
+    delete_profile_from_hash(prof_info);
+    pthread_mutex_unlock(&rtk_prof.profile_mutex);
+
+    return 1;
+}
+
+void packets_count(uint16_t handle, uint16_t scid, uint16_t length, uint8_t direction)
+{
+    tRTK_PROF_INFO* prof_info = NULL;
+    uint8_t profile_type;
+
+    tRTK_CONN_PROF* hci_conn = find_connection_by_handle(&rtk_prof, handle);
+    if(NULL == hci_conn)
+        return;
+
+    if(0 == hci_conn->type)//l2cap
+    {
+        if(!direction)    //0: in
+            prof_info = find_profile_by_handle_scid(&rtk_prof, handle, scid);
+        else //1: out
+            prof_info = find_profile_by_handle_dcid(&rtk_prof, handle, scid);
+
+        if(!prof_info)
+        {
+            //LogMsg("packets_count: prof_info Not Find!");
+            //ALOGE("handle=%x, scid=%x, length=%d,",handle, scid, length);
+            return ;
+        }
+
+        if((prof_info->profile_index == profile_a2dp) && (length > 100))//avdtp media data
+        {
+            if(!is_profile_busy(profile_a2dp))
+                update_profile_state(profile_a2dp, TRUE);
+            rtk_prof.a2dp_packet_count++;
+        }
+
+        if(prof_info->profile_index == profile_pan)
+            rtk_prof.pan_packet_count++;
+    }
+}
+
+static void timeout_handler(int signo, siginfo_t * info, void *context)
+{
+    if (signo == TIMER_POLLING)
+    {
+        LogMsg("polling timeout");
+        if(rtk_prof.polling_enable)
+        {
+            uint8_t temp_cmd[1];
+            temp_cmd[0] = HCI_VENDOR_SUB_CMD_BT_REPORT_CONN_SCO_INQ_INFO;
+            rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 1, temp_cmd);
+        }
+    }
+    else if (signo == TIMER_A2DP_PACKET_COUNT)
+    {
+        LogMsg("count a2dp packet timeout, a2dp_packet_count = %d",rtk_prof.a2dp_packet_count);
+        if(rtk_prof.a2dp_packet_count == 0)
+        {
+            if(is_profile_busy(profile_a2dp))
+            {
+                LogMsg("timeout_handler: a2dp busy->idle!");
+                update_profile_state(profile_a2dp, FALSE);
+            }
+        }
+        rtk_prof.a2dp_packet_count = 0;
+    }
+    else if (signo == TIMER_HOGP_PACKET_COUNT)
+    {
+        LogMsg("count hogp packet timeout, hogp_packet_count = %d",rtk_prof.hogp_packet_count);
+        if(rtk_prof.hogp_packet_count == 0)
+        {
+            if(is_profile_busy(profile_hogp))
+            {
+                LogMsg("timeout_handler: hogp busy->idle!");
+                update_profile_state(profile_hogp, FALSE);
+            }
+        }
+        rtk_prof.hogp_packet_count = 0;
+
+        LogMsg("count hogp packet timeout, voice_packet_count = %d",rtk_prof.voice_packet_count);
+        if(rtk_prof.voice_packet_count == 0)
+        {
+            if(is_profile_busy(profile_voice))
+            {
+                LogMsg("timeout_handler: voice busy->idle!");
+                update_profile_state(profile_voice, FALSE);
+            }
+        }
+        rtk_prof.voice_packet_count = 0;
+    }
+    else if (signo == TIMER_PAN_PACKET_COUNT)
+    {
+        LogMsg("count pan packet timeout, pan_packet_count = %d",rtk_prof.pan_packet_count);
+        if(rtk_prof.pan_packet_count < PAN_PACKET_COUNT)
+        {
+            if(is_profile_busy(profile_pan))
+            {
+                LogMsg("timeout_handler: pan busy->idle!");
+                update_profile_state(profile_pan, FALSE);
+            }
+        }
+        else
+        {
+            if(!is_profile_busy(profile_pan))
+            {
+                LogMsg("timeout_handler: pan idle->busy!");
+                update_profile_state(profile_pan, TRUE);
+            }
+        }
+        rtk_prof.pan_packet_count = 0;
+    }
+    else
+    {
+        ALOGE("rtk_parse_data timer unspported signo(%d)", signo);
+    }
+}
+
+#if 0
+int netlink_send(int nlsk, char *buffer)
+{
+    struct nlmsghdr* nlhdr;
+    struct iovec iov;
+    struct msghdr msg;
+    struct sockaddr_nl nladdr;
+
+    if(nlsk <= 0)
+        return -1;
+
+    memset(&msg, 0 ,sizeof(struct msghdr));
+    memset(&nladdr, 0 ,sizeof(struct sockaddr_nl));
+
+    nlhdr = (struct nlmsghdr *)malloc(NLMSG_SPACE(strlen(buffer) + 1));
+    strcpy(NLMSG_DATA(nlhdr),buffer);
+
+    nlhdr->nlmsg_len = NLMSG_LENGTH(strlen(buffer) + 1);
+    nlhdr->nlmsg_pid = getpid(); //sender pid
+    nlhdr->nlmsg_flags = NLM_F_REQUEST;
+    nlhdr->nlmsg_type = NLMSG_MIN_TYPE;
+
+    nladdr.nl_family = AF_NETLINK;
+    nladdr.nl_pid = 0; //send to kernel
+    nladdr.nl_groups = 0;
+
+    iov.iov_base = (void *)nlhdr;
+    iov.iov_len = nlhdr->nlmsg_len;
+
+    msg.msg_iov = &iov;
+    msg.msg_iovlen = 1;
+    msg.msg_name = (void *)&(nladdr);
+    msg.msg_namelen = sizeof(nladdr);
+
+    return sendmsg(nlsk, &msg, 0);
+}
+#endif
+
+int udpsocket_send(char *tx_msg, int msg_size)
+{
+    int n; /* message byte size */
+
+    LogMsg("udpsocket_send tx_msg:%s",tx_msg);
+    n = sendto(rtk_prof.udpsocket, tx_msg, msg_size, 0, (struct sockaddr *) &rtk_prof.client_addr, sizeof(rtk_prof.client_addr));
+    if (n < 0)
+    {
+        ALOGE("ERROR in sendto");
+        return -1;
+    }
+    return 0;
+}
+
+int udpsocket_recv(uint8_t *recv_msg, uint8_t *msg_size)
+{
+    struct hostent *hostp;  /* client host info */
+    char buf[MAX_PAYLOAD];  /* message buf */
+    char *hostaddrp;        /* dotted decimal host addr string */
+    int n;                  /* message byte size */
+    struct sockaddr_in recv_addr;
+    socklen_t clientlen = sizeof(recv_addr);
+    struct pollfd pfd = {
+        .events = POLLPRI | POLLIN,
+        .revents = 0,
+        .fd = rtk_prof.udpsocket
+    };
+
+    bzero(buf, MAX_PAYLOAD);
+
+    while (poll(&pfd, 1, 1000) <= 0) {
+        if (rtk_prof.udpsocket_recv_thread_running ==0) {
+            LogMsg("SIGUSR2 should have caught us before this");
+            return -1;
+        }
+    }
+
+
+    n = recvfrom(rtk_prof.udpsocket, buf, MAX_PAYLOAD, 0, (struct sockaddr *) &recv_addr, &clientlen);
+    if (n < 0) {
+        ALOGE("ERROR in recvfrom");
+        return -1;
+    } else {
+        *msg_size = n;
+        memcpy(recv_msg,buf,n);
+    }
+    return 0;
+}
+
+void rtk_notify_extension_version_to_wifi()
+{
+    uint8_t para_length = 2;
+    char p_buf[para_length + HCI_CMD_PREAMBLE_SIZE];
+
+    if(!rtk_prof.wifi_on)
+        return;
+
+    char *p = p_buf;
+    UINT16_TO_STREAM(p, HCI_OP_HCI_EXTENSION_VERSION_NOTIFY);
+    *p++ = para_length;
+    UINT16_TO_STREAM(p, HCI_EXTENSION_VERSION);
+    LogMsg("extension version is 0x%x", HCI_EXTENSION_VERSION);
+    if(udpsocket_send(p_buf, para_length + HCI_CMD_PREAMBLE_SIZE) < 0)
+        ALOGE("rtk_notify_extension_version_to_wifi: udpsocket send error");
+}
+
+void rtk_notify_btpatch_version_to_wifi()
+{
+    uint8_t para_length = 4;
+    char p_buf[para_length + HCI_CMD_PREAMBLE_SIZE];
+
+    if(!rtk_prof.wifi_on)
+        return;
+
+    char *p = p_buf;
+    UINT16_TO_STREAM(p, HCI_OP_HCI_BT_PATCH_VER_NOTIFY);
+    *p++ = para_length;
+    UINT16_TO_STREAM(p, rtk_prof.hci_reversion);
+    UINT16_TO_STREAM(p, rtk_prof.lmp_subversion);
+    LogMsg("btpatch_version, length is 0x%x, hci_reversion is 0x%x, lmp_subversion is %x", para_length, rtk_prof.hci_reversion, rtk_prof.lmp_subversion);
+
+    if(udpsocket_send(p_buf, para_length + HCI_CMD_PREAMBLE_SIZE) < 0)
+        ALOGE("rtk_notify_btpatch_version_to_wifi: udpsocket send error");
+}
+
+void rtk_notify_afhmap_to_wifi()
+{
+    uint8_t para_length = 13;
+    char p_buf[para_length + HCI_CMD_PREAMBLE_SIZE];
+
+    if(!rtk_prof.wifi_on)
+        return;
+
+    char *p = p_buf;
+    UINT16_TO_STREAM(p, HCI_OP_HCI_BT_AFH_MAP_NOTIFY);
+    *p++ = para_length;
+    *p++ = rtk_prof.piconet_id;
+    *p++ = rtk_prof.mode;
+    *p++ = 10;
+    memcpy(p, rtk_prof.afh_map, 10);
+
+    LogMsg("afhmap, piconet_id is 0x%x, map type is 0x%x", rtk_prof.piconet_id, rtk_prof.mode);
+    uint8_t kk = 0;
+    for(kk=0; kk < 10; kk++)
+        LogMsg("afhmap data[%d] is 0x%x", kk, rtk_prof.afh_map[kk]);
+
+    if(udpsocket_send(p_buf, para_length + HCI_CMD_PREAMBLE_SIZE) < 0)
+        ALOGE("rtk_notify_afhmap_to_wifi: udpsocket send error");
+}
+
+void rtk_notify_btcoex_to_wifi(uint8_t opcode, uint8_t status)
+{
+    uint8_t para_length = 2;
+    char p_buf[para_length + HCI_CMD_PREAMBLE_SIZE];
+
+    if(!rtk_prof.wifi_on)
+        return;
+
+    char *p = p_buf;
+    UINT16_TO_STREAM(p, HCI_OP_HCI_BT_COEX_NOTIFY);
+    *p++ = para_length;
+    *p++ = opcode;
+    if(!status)
+        *p++ = 0;
+    else
+        *p++ = 1;
+
+    LogMsg("btcoex, opcode is 0x%x, status is 0x%x", opcode, status);
+
+    if(udpsocket_send(p_buf, para_length + HCI_CMD_PREAMBLE_SIZE) < 0)
+        ALOGE("rtk_notify_btcoex_to_wifi: udpsocket send error");
+}
+
+void rtk_notify_btoperation_to_wifi(uint8_t operation, uint8_t append_data_length, uint8_t *append_data)
+{
+    uint8_t para_length = 3 + append_data_length;
+    char p_buf[para_length + HCI_CMD_PREAMBLE_SIZE];
+
+    if(!rtk_prof.wifi_on)
+        return;
+
+    char *p = p_buf;
+    UINT16_TO_STREAM(p, HCI_OP_BT_OPERATION_NOTIFY);
+    *p++ = para_length;
+    *p++ = operation;
+    *p++ = append_data_length;
+    if(append_data_length)
+        memcpy(p, append_data, append_data_length);
+
+    LogMsg("btoperation, opration is 0x%x, append_data_length is 0x%x", operation, append_data_length);
+    uint8_t kk = 0;
+    if(append_data_length)
+    {
+        for(kk=0; kk < append_data_length; kk++)
+            LogMsg("append data is 0x%x", *(append_data+kk));
+    }
+
+    if(udpsocket_send(p_buf, para_length + HCI_CMD_PREAMBLE_SIZE) < 0)
+        ALOGE("rtk_notify_btoperation_to_wifi: udpsocket send error");
+}
+
+void rtk_notify_info_to_wifi(uint8_t reason, uint8_t length, uint8_t* report_info)
+{
+    uint8_t para_length = 4 + length;
+    char p_buf[para_length + HCI_CMD_PREAMBLE_SIZE];
+    int i;
+
+    if(!rtk_prof.wifi_on)
+        return;
+
+    char *p = p_buf;
+    UINT16_TO_STREAM(p, HCI_OP_HCI_BT_INFO_NOTIFY);
+    *p++ = para_length;
+    *p++ = rtk_prof.polling_enable;
+    *p++ = rtk_prof.polling_interval;
+    *p++ = reason;
+    *p++ = length;
+
+    if(length)
+        memcpy(p, report_info, length);
+
+    LogMsg("bt info, length is 0x%x, polling_enable is 0x%x, poiiling_interval is %x",para_length, rtk_prof.polling_enable, rtk_prof.polling_interval);
+    LogMsg("bt info, reason is 0x%x, info length is 0x%x", reason, length);
+    if(length)
+    {
+        for(i=0;i<length;i++)
+            LogMsg("bt info[%d]: %02x", i, report_info[i]); 
+    }
+
+    if(udpsocket_send(p_buf, para_length + HCI_CMD_PREAMBLE_SIZE) < 0)
+        ALOGE("rtk_notify_info_to_wifi: udpsocket send error");
+}
+
+void rtk_notify_regester_to_wifi(uint8_t* reg_value)
+{
+    uint8_t para_length = 9;
+    char p_buf[para_length + HCI_CMD_PREAMBLE_SIZE];
+
+    if(!rtk_prof.wifi_on)
+        return;
+
+    char *p = p_buf;
+    UINT16_TO_STREAM(p, HCI_OP_HCI_BT_REGISTER_VALUE_NOTIFY);
+    *p++ = para_length;
+    memcpy(p, reg_value, para_length);
+
+    tHCI_RETURN_PARAMETER_MAILBOX_REGISTER *reg = (tHCI_RETURN_PARAMETER_MAILBOX_REGISTER *)reg_value;
+    LogMsg("bt register, register type is %x", reg->type);
+    LogMsg("bt register, register offset is %x", reg->offset);
+    LogMsg("bt register, register value is %x", reg->value);
+
+    if(udpsocket_send(p_buf, para_length + HCI_CMD_PREAMBLE_SIZE) < 0)
+        ALOGE("rtk_notify_regester_to_wifi: udpsocket send error");
+}
+
+static void rtk_handle_bt_info_control(uint8_t* p)
+{
+    tHCI_EVENT_BT_INFO_CONTROL*  info = (tHCI_EVENT_BT_INFO_CONTROL*)p;
+    uint8_t temp_cmd[3];
+
+    LogMsg("rtk_prof.polling_enable is %x",rtk_prof.polling_enable);
+    LogMsg("receive bt info control event from wifi, polling enable is 0x%x, polling time is 0x%x, auto report is 0x%x",
+                    info->polling_enable, info->polling_time, info->autoreport_enable);
+
+    if(info->polling_enable && !rtk_prof.polling_enable)
+        start_polling_timer(info->polling_time * 1000);
+
+    if(!info->polling_enable && rtk_prof.polling_enable)
+        stop_polling_timer();
+
+    rtk_prof.polling_enable = info->polling_enable;
+    rtk_prof.polling_interval = info->polling_time;
+    rtk_prof.autoreport = info->autoreport_enable;
+
+    temp_cmd[0] = HCI_VENDOR_SUB_CMD_BT_AUTO_REPORT_ENABLE;
+    temp_cmd[1] = 1;
+    temp_cmd[2] = info->autoreport_enable;
+    rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 3, temp_cmd);
+
+    rtk_notify_info_to_wifi(HOST_RESPONSE, 0, NULL);
+}
+
+static void rtk_handle_bt_coex_control(uint8_t* p)
+{
+    uint8_t opcode = *p++;
+    LogMsg("receive bt coex control event from wifi, opration is 0x%x", opcode);
+    switch (opcode)
+    {
+        case BT_PATCH_VERSION_QUERY:
+        {
+            rtk_notify_btpatch_version_to_wifi();
+            break;
+        }
+
+        case IGNORE_WLAN_ACTIVE_CONTROL:
+        {
+            uint8_t opcode_len = *p++;
+            uint8_t value = *p++;
+            uint8_t temp_cmd[3];
+            temp_cmd[0] = HCI_VENDOR_SUB_CMD_BT_ENABLE_IGNORE_WLAN_ACT_CMD;
+            temp_cmd[1] = 1;
+            temp_cmd[2] = value;
+            rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 3, temp_cmd);
+            break;
+        }
+
+        case LNA_CONSTRAIN_CONTROL:
+        {
+            uint8_t opcode_len = *p++;
+            uint8_t value = *p++;
+            uint8_t temp_cmd[3];
+            temp_cmd[0] = HCI_VENDOR_SUB_CMD_SET_BT_LNA_CONSTRAINT;
+            temp_cmd[1] = 1;
+            temp_cmd[2] = value;
+            rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 3, temp_cmd);
+            break;
+        }
+
+        case BT_POWER_DECREASE_CONTROL:
+        {
+            uint8_t opcode_len = *p++;
+            uint8_t power_decrease = *p++;
+            uint8_t temp_cmd[3];
+            temp_cmd[0] = HCI_VENDOR_SUB_CMD_WIFI_FORCE_TX_POWER_CMD;
+            temp_cmd[1] = 1;
+            temp_cmd[2] = power_decrease;
+            rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 3, temp_cmd);
+            break;
+        }
+
+        case BT_PSD_MODE_CONTROL:
+        {
+            uint8_t opcode_len = *p++;
+            uint8_t psd_mode = *p++;
+            uint8_t temp_cmd[3];
+            temp_cmd[0] = HCI_VENDOR_SUB_CMD_SET_BT_PSD_MODE;
+            temp_cmd[1] = 1;
+            temp_cmd[2] = psd_mode;
+            rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 3, temp_cmd);
+            break;
+        }
+
+        case WIFI_BW_CHNL_NOTIFY:
+        {
+            uint8_t opcode_len = *p++;
+            uint8_t temp_cmd[5];
+            temp_cmd[0] = HCI_VENDOR_SUB_CMD_WIFI_CHANNEL_AND_BANDWIDTH_CMD;
+            temp_cmd[1] = 3;
+            memcpy(temp_cmd+2, p, 3);//wifi_state, wifi_centralchannel, chnnels_btnotuse
+            rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 5, temp_cmd);
+            break;
+        }
+
+        case QUERY_BT_AFH_MAP:
+        {
+            uint8_t opcode_len = *p++;
+            rtk_prof.piconet_id = *p++;
+            rtk_prof.mode = *p++;
+            uint8_t temp_cmd[4];
+            temp_cmd[0] = HCI_VENDOR_SUB_CMD_GET_AFH_MAP_L;
+            temp_cmd[1] = 2;
+            temp_cmd[2] = rtk_prof.piconet_id;
+            temp_cmd[3] = rtk_prof.mode;
+            rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 4, temp_cmd);
+            break;
+        }
+
+        case BT_REGISTER_ACCESS:
+        {
+            uint8_t opcode_len = *p++;
+            uint8_t access_type = *p++;
+            if(access_type == 0) //read
+            {
+                uint8_t temp_cmd[7];
+                temp_cmd[0] = HCI_VENDOR_SUB_CMD_RD_REG_REQ;
+                temp_cmd[1] = 5;
+                temp_cmd[2] = *p++;
+                memcpy(temp_cmd+3, p, 4);
+                rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 7, temp_cmd);
+            }
+            else //write
+            {
+                uint8_t temp_cmd[11];
+                temp_cmd[0] = HCI_VENDOR_SUB_CMD_RD_REG_REQ;
+                temp_cmd[1] = 5;
+                temp_cmd[2] = *p++;
+                memcpy(temp_cmd+3, p, 8);
+                rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 11, temp_cmd);
+            }
+            break;
+        }
+
+        default:
+            break;
+    }
+}
+
+void rtk_handle_event_from_wifi(uint8_t* msg)
+{
+    uint8_t *p = msg;
+    uint8_t event_code = *p++;
+
+    if(memcmp(msg, invite_rsp, sizeof(invite_rsp)) == 0)
+    {
+#if 0
+        LogMsg("receive invite rsp from wifi, close netlink socket if needed");
+        if(rtk_prof.nlsocket > 0)
+        {
+            close(rtk_prof.nlsocket);
+            LogMsg("close netlink socket %d", rtk_prof.nlsocket);
+        }
+#endif
+        LogMsg("receive invite rsp from wifi, wifi is already on");
+        rtk_prof.wifi_on = 1;
+        rtk_notify_extension_version_to_wifi();
+    }
+
+    if(memcmp(msg, attend_req, sizeof(attend_req)) == 0)
+    {
+        LogMsg("receive attend req from wifi, wifi turn on");
+        rtk_prof.wifi_on = 1;
+        udpsocket_send(attend_ack, sizeof(attend_ack));
+        rtk_notify_extension_version_to_wifi();
+    }
+
+    if(memcmp(msg, wifi_leave, sizeof(wifi_leave)) == 0)
+    {
+        LogMsg("receive wifi leave from wifi, wifi turn off");
+        rtk_prof.wifi_on = 0;
+        udpsocket_send(leave_ack, sizeof(leave_ack));
+        if(rtk_prof.polling_enable)
+        {
+            rtk_prof.polling_enable = 0;
+            stop_polling_timer();
+        }
+    }
+
+    if(memcmp(msg, leave_ack, sizeof(leave_ack)) == 0)
+    {
+        LogMsg("receive leave ack from wifi");
+    }
+
+    if(event_code == 0xFE)
+    {
+        uint8_t total_length = *p++;
+        uint8_t extension_event = *p++;
+        switch(extension_event)
+        {
+            case  RTK_HS_EXTENSION_EVENT_WIFI_SCAN:
+            {
+                uint8_t operation = *p;
+                LogMsg("receive wifi scan notify evnet from wifi, operation is 0x%x", operation);
+                break;
+            }
+
+            case  RTK_HS_EXTENSION_EVENT_HCI_BT_INFO_CONTROL:
+            {
+                rtk_handle_bt_info_control(p);
+                break;
+            }
+
+            case RTK_HS_EXTENSION_EVENT_HCI_BT_COEX_CONTROL:
+            {
+                rtk_handle_bt_coex_control(p);
+                break;
+            }
+
+            default:
+                break;
+        }
+    }
+
+    if(event_code == 0x0E)
+    {
+        uint16_t wifi_opcode;
+        uint8_t op_status;
+        p += 2;//length, number of complete packets
+        STREAM_TO_UINT16(wifi_opcode, p);
+        op_status = *p;
+        LogMsg("receive command complete event from wifi, op code is 0x%x, status is 0x%x", wifi_opcode, op_status);
+    }
+}
+
+static void udpsocket_receive_thread_exit_handler(int sig)
+{
+    LogMsg("USR2, this signal is %d \n", sig);
+    usleep(100);
+    pthread_exit(0);
+}
+
+static void udpsocket_receive_thread(void *arg)
+{
+    uint8_t msg_recv[MAX_PAYLOAD];
+    uint8_t recv_length;
+    struct sigaction actions;
+
+    memset(&actions, 0, sizeof(actions));
+    sigemptyset(&actions.sa_mask);
+    actions.sa_flags = 0;
+    actions.sa_handler = udpsocket_receive_thread_exit_handler;
+
+    int rc = sigaction(SIGUSR2,&actions,NULL);
+
+    LogMsg("udpsocket_receive_thread started");
+    prctl(PR_SET_NAME, (unsigned long)"udpsocket_receive_thread", 0, 0, 0);
+
+    while(rtk_prof.udpsocket_recv_thread_running)
+    {
+        memset(msg_recv, 0 , MAX_PAYLOAD);
+        if (udpsocket_recv(msg_recv, &recv_length) == 0)
+            rtk_handle_event_from_wifi(msg_recv);
+    }
+
+    LogMsg("udpsocket_receive_thread exiting");
+    pthread_exit(NULL);
+}
+
+int create_udpsocket_socket()
+{
+    int portno = CONNECT_PORT;
+    int optval; /* flag value for setsockopt */
+
+    LogMsg("create udpsocket port: %d\n", portno);
+
+    pthread_mutex_lock(&rtk_prof.udpsocket_mutex);
+
+    pthread_attr_t thread_attr_data;
+    if (rtk_prof.udpsocket_recv_thread_running)
+    {
+        ALOGE("udp_receive_thread already exit");
+        pthread_mutex_unlock(&rtk_prof.udpsocket_mutex);
+        return -1 ;
+    }
+
+    rtk_prof.udpsocket_recv_thread_running = 1;
+    rtk_prof.udpsocket = socket(AF_INET, SOCK_DGRAM, 0);
+    LogMsg("create socket %d", rtk_prof.udpsocket);
+
+    if (rtk_prof.udpsocket < 0)
+    {
+        ALOGE("create udpsocket error...%s\n", strerror(errno));
+        rtk_prof.udpsocket_recv_thread_running = 0;
+        close(rtk_prof.udpsocket);
+        LogMsg("close socket %d", rtk_prof.udpsocket);
+        pthread_mutex_unlock(&rtk_prof.udpsocket_mutex);
+        return -1 ;
+    }
+
+    bzero((char *) &rtk_prof.server_addr, sizeof(rtk_prof.server_addr));
+    rtk_prof.server_addr.sin_family = AF_INET;
+    rtk_prof.server_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+    rtk_prof.server_addr.sin_port = htons(CONNECT_PORT);
+
+    bzero((char *) &rtk_prof.client_addr, sizeof(rtk_prof.client_addr));
+    rtk_prof.client_addr.sin_family = AF_INET;
+    rtk_prof.client_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+    rtk_prof.client_addr.sin_port = htons(CONNECT_PORT_WIFI);
+
+    optval = 1;
+    setsockopt(rtk_prof.udpsocket, SOL_SOCKET, SO_REUSEADDR, (const void *)&optval , sizeof(int));
+
+    if (bind(rtk_prof.udpsocket, (struct sockaddr *)&rtk_prof.server_addr, sizeof(rtk_prof.server_addr)) < 0)
+    {
+        ALOGE("bind udpsocket error...%s\n", strerror(errno));
+        rtk_prof.udpsocket_recv_thread_running = 0;
+        close(rtk_prof.udpsocket);
+        LogMsg("close socket %d", rtk_prof.udpsocket);
+        pthread_mutex_unlock(&rtk_prof.udpsocket_mutex);
+        return -1 ;
+    }
+
+    pthread_attr_init(&thread_attr_data);
+    if (pthread_create(&rtk_prof.thread_data, &thread_attr_data, (void*)udpsocket_receive_thread, NULL) != 0)
+    {
+        ALOGE("pthread_create failed!");
+        pthread_attr_destroy(&thread_attr_data);
+        rtk_prof.udpsocket_recv_thread_running = 0;
+        pthread_mutex_unlock(&rtk_prof.udpsocket_mutex);
+        return -1 ;
+    }
+    pthread_attr_destroy(&thread_attr_data);
+    pthread_mutex_unlock(&rtk_prof.udpsocket_mutex);
+    return 0;
+}
+
+int stop_udpsocket_receive_thread()
+{
+    pthread_mutex_lock(&rtk_prof.udpsocket_mutex);
+    int result = 0;
+
+    LogMsg("notify wifi bt turn off");
+    if(rtk_prof.wifi_on)
+        udpsocket_send(bt_leave, sizeof(bt_leave));
+
+    if (rtk_prof.udpsocket_recv_thread_running)
+    {
+        LogMsg("data thread is running, stop it");
+
+        //add for pthread_cancel
+        if ((result = pthread_kill(rtk_prof.thread_data, SIGUSR2)) != 0)
+        {
+            ALOGE("error cancelling data thread");
+        }
+        rtk_prof.udpsocket_recv_thread_running = 0;
+
+        if ((result = pthread_join(rtk_prof.thread_data, NULL)) < 0)
+        {
+            ALOGE( "data thread pthread_join() failed result:%d", result);
+        }
+
+        LogMsg("close socket %d", rtk_prof.udpsocket);
+        if((result = close(rtk_prof.udpsocket)) != 0)
+        {
+            ALOGE("close socket error!");
+        }
+    }
+    pthread_mutex_unlock(&rtk_prof.udpsocket_mutex);
+    return 0;
+}
+
+#if 0
+int create_netlink_socket()
+{
+    LogMsg("in creat netlink socket");
+    rtk_prof.nlsocket = socket(PF_NETLINK, SOCK_RAW, NETLINK_USER);
+
+    if (rtk_prof.nlsocket < 0)
+    {
+        ALOGE("create netlink socket error...%s\n", strerror(errno));
+        close(rtk_prof.nlsocket);
+        LogMsg("close netlink socket %d", rtk_prof.nlsocket);
+        return -1 ;
+    }
+    LogMsg("create netlink socket %d", rtk_prof.nlsocket);
+    memset(&rtk_prof.src_addr, 0, sizeof(rtk_prof.src_addr));
+    rtk_prof.src_addr.nl_family = AF_NETLINK;
+    rtk_prof.src_addr.nl_pid = getpid(); /* self pid */
+    rtk_prof.src_addr.nl_groups    = 0 ;    /* not in mcast groups */
+    int ret = bind(rtk_prof.nlsocket, (struct sockaddr *)&rtk_prof.src_addr, sizeof(rtk_prof.src_addr));
+    if(ret < 0)
+    {
+        ALOGE("bind netlink socket error...%s\n", strerror(errno));
+        close(rtk_prof.nlsocket);
+        LogMsg("close netlink socket %d", rtk_prof.nlsocket);
+        return -1 ;
+    }
+
+    return 0;
+}
+#endif
+
+void rtk_parse_init(hci_t *hci_if)
+{
+    ALOGI("RTKBT_RELEASE_NAME: %s",RTKBT_RELEASE_NAME);
+    LogMsg("rtk_profile_init, version: %s", RTK_VERSION);
+
+    pthread_mutex_init(&rtk_prof.profile_mutex, NULL);
+    pthread_mutex_init(&rtk_prof.udpsocket_mutex, NULL);
+    alloc_a2dp_packet_count_timer();
+    alloc_pan_packet_count_timer();
+    alloc_hogp_packet_count_timer();
+    alloc_polling_timer();
+
+    init_profile_hash(&rtk_prof);
+    init_connection_hash(&rtk_prof);
+
+    create_udpsocket_socket();
+    hci_interface = hci_if;
+}
+
+void rtk_parse_cleanup()
+{
+    LogMsg("rtk_profile_cleanup");
+    int kk = 0;
+    free_a2dp_packet_count_timer();
+    free_pan_packet_count_timer();
+    free_hogp_packet_count_timer();
+    free_polling_timer();
+
+    flush_connection_hash(&rtk_prof);
+    flush_profile_hash(&rtk_prof);
+    pthread_mutex_destroy(&rtk_prof.profile_mutex);
+
+    stop_udpsocket_receive_thread();
+    pthread_mutex_destroy(&rtk_prof.udpsocket_mutex);
+
+    rtk_prof.polling_enable = 0;
+    rtk_prof.profile_bitmap = 0;
+    rtk_prof.profile_status = 0;
+    for(kk = 0; kk < 8; kk++)
+        rtk_prof.profile_refcount[kk] = 0;
+}
+
+static void rtk_handle_vender_mailbox_cmp_evt(uint8_t* p, uint8_t len)
+{
+    uint8_t status = *p++;
+    if(len <= 4)
+    {
+        LogMsg("receive mailbox cmd from fw, total length <= 4");
+        return;
+    }
+    uint8_t subcmd = *p++;
+    LogMsg("receive mailbox cmd from fw, subcmd is 0x%x, status is 0x%x", subcmd, status);
+    switch(subcmd)
+    {
+        case HCI_VENDOR_SUB_CMD_BT_REPORT_CONN_SCO_INQ_INFO:
+            if(status == 0) //success
+            {
+                if((len-5) != 8)
+                    LogMsg("rtk_handle_vender_mailbox_cmp_evt:HCI_VENDOR_SUB_CMD_BT_REPORT_CONN_SCO_INQ_INFO len=%d", len);
+                rtk_notify_info_to_wifi(POLLING_RESPONSE, (len-5), (uint8_t*)p);
+            }
+            break;
+
+        case HCI_VENDOR_SUB_CMD_WIFI_CHANNEL_AND_BANDWIDTH_CMD:
+            rtk_notify_btcoex_to_wifi(WIFI_BW_CHNL_NOTIFY, status);
+            break;
+
+        case HCI_VENDOR_SUB_CMD_WIFI_FORCE_TX_POWER_CMD:
+            rtk_notify_btcoex_to_wifi(BT_POWER_DECREASE_CONTROL, status);
+            break;
+
+        case HCI_VENDOR_SUB_CMD_BT_ENABLE_IGNORE_WLAN_ACT_CMD:
+            rtk_notify_btcoex_to_wifi(IGNORE_WLAN_ACTIVE_CONTROL, status);
+            break;
+
+        case HCI_VENDOR_SUB_CMD_SET_BT_PSD_MODE:
+            rtk_notify_btcoex_to_wifi(BT_PSD_MODE_CONTROL, status);
+            break;
+
+        case HCI_VENDOR_SUB_CMD_SET_BT_LNA_CONSTRAINT:
+            rtk_notify_btcoex_to_wifi(LNA_CONSTRAIN_CONTROL, status);
+            break;
+
+        case HCI_VENDOR_SUB_CMD_BT_AUTO_REPORT_ENABLE:
+            break;
+
+        case HCI_VENDOR_SUB_CMD_BT_SET_TXRETRY_REPORT_PARAM:
+            break;
+
+        case HCI_VENDOR_SUB_CMD_BT_SET_PTATABLE:
+            break;
+
+        case HCI_VENDOR_SUB_CMD_GET_AFH_MAP_L:
+        {
+            if(status == 0)//success
+            {
+                memcpy(rtk_prof.afh_map, p+4, 4); //cmd_idx, length, piconet_id, mode
+                uint8_t temp_cmd[4];
+                temp_cmd[0] = HCI_VENDOR_SUB_CMD_GET_AFH_MAP_M;
+                temp_cmd[1] = 2;
+                temp_cmd[2] = rtk_prof.piconet_id;
+                temp_cmd[3] = rtk_prof.mode;
+                rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 4, temp_cmd);
+            }
+            else //fail
+            {
+                memset(rtk_prof.afh_map, 0, 10);
+                rtk_notify_afhmap_to_wifi();
+            }
+            break;
+        }
+        case HCI_VENDOR_SUB_CMD_GET_AFH_MAP_M:
+        {
+            if(status == 0)//success
+            {
+                memcpy(rtk_prof.afh_map+4, p+4, 4);
+                uint8_t temp_cmd[4];
+                temp_cmd[0] = HCI_VENDOR_SUB_CMD_GET_AFH_MAP_H;
+                temp_cmd[1] = 2;
+                temp_cmd[2] = rtk_prof.piconet_id;
+                temp_cmd[3] = rtk_prof.mode;
+                rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 4, temp_cmd);
+            }
+            else //fail
+            {
+                memset(rtk_prof.afh_map, 0, 10);
+                rtk_notify_afhmap_to_wifi();
+            }
+            break;
+        }
+
+        case HCI_VENDOR_SUB_CMD_GET_AFH_MAP_H:
+        {
+            if(status == 0)
+                memcpy(rtk_prof.afh_map+8, p+4, 2);
+            else
+                memset(rtk_prof.afh_map, 0, 10);
+
+            rtk_notify_afhmap_to_wifi();
+            break;
+        }
+
+        case HCI_VENDOR_SUB_CMD_RD_REG_REQ:
+        {
+            if(status == 0)
+                rtk_notify_regester_to_wifi(p+3);//cmd_idx,length,regist type
+            break;
+        }
+
+        case HCI_VENDOR_SUB_CMD_WR_REG_REQ:
+            rtk_notify_btcoex_to_wifi(BT_REGISTER_ACCESS, status);
+            break;
+
+        default:
+            break;
+    }
+}
+
+static void rtk_handle_cmd_complete_evt(uint8_t*p, uint8_t len)
+{
+    uint16_t opcode;
+    uint8_t status;
+    p++;
+    STREAM_TO_UINT16(opcode, p);
+    switch (opcode)
+    {
+        case HCI_PERIODIC_INQUIRY_MODE:
+        {
+            status = *p++;
+            if(status && rtk_prof.isinquirying)
+            {
+                rtk_prof.isinquirying = 0;
+                LogMsg("HCI_PERIODIC_INQUIRY_MODE start error, notify wifi inquiry stop");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_INQUIRY_END, 0, NULL);
+            }
+            break;
+        }
+
+        case HCI_READ_LOCAL_VERSION_INFO:
+        {
+            status = *p++;
+            if(!status)
+            {
+                p++;
+                STREAM_TO_UINT16(rtk_prof.hci_reversion, p);
+                p+=3;
+                STREAM_TO_UINT16(rtk_prof.lmp_subversion, p);
+            }
+            LogMsg("rtk_prof.hci_reversion = %x", rtk_prof.hci_reversion);
+            LogMsg("rtk_prof.lmp_subversion = %x", rtk_prof.lmp_subversion);
+            break;
+        }
+
+        case HCI_RESET:
+        {
+            LogMsg("bt start ok");
+            udpsocket_send(invite_req, sizeof(invite_req));
+#if 0
+            if(create_netlink_socket() == 0)
+            {
+                LogMsg("wifi is already on when bt turn on");
+                rtk_prof.wifi_on = 1;
+                netlink_send(rtk_prof.nlsocket, invite_req);
+            }
+            else
+                LogMsg("wifi is off when bt turn on, wait for wifi turning on...");
+#endif
+            uint8_t ttmp[1] = {1};
+            rtk_vendor_cmd_to_fw(0xfc1b, 1, ttmp);
+            break;
+        }
+
+        case 0xfc1b:
+            LogMsg("received cmd complete event for fc1b");
+            poweroff_allowed = 1;
+            break;
+
+        case HCI_VENDOR_MAILBOX_CMD:
+            rtk_handle_vender_mailbox_cmp_evt(p, len);
+            break;
+
+        case HCI_VENDOR_ADD_BITPOOL_FW:
+            status = *p++;
+            LogMsg("received cmd complete event for HCI_VENDOR_ADD_BITPOOL_FW status:%d",status);
+
+        default:
+            break;
+    }
+}
+
+static void rtk_handle_connection_complete_evt(uint8_t* p)
+{
+    uint8_t status = 0;
+    uint16_t handle = 0;
+    status = *p++;
+    STREAM_TO_UINT16 (handle, p);
+    p +=6;
+    uint8_t link_type = *p++;
+
+    if(status == 0)
+    {
+        if(rtk_prof.ispaging)
+        {
+            rtk_prof.ispaging = 0;
+            LogMsg("notify wifi page success end");
+            rtk_notify_btoperation_to_wifi(BT_OPCODE_PAGE_SUCCESS_END, 0, NULL);
+        }
+
+        tRTK_CONN_PROF* hci_conn = find_connection_by_handle(&rtk_prof, handle);
+        if(hci_conn == NULL)
+        {
+            hci_conn = allocate_connection_by_handle(handle);
+            if(hci_conn)
+            {
+                add_connection_to_hash(&rtk_prof, hci_conn);
+                hci_conn->profile_bitmap = 0;
+                memset(hci_conn->profile_refcount, 0, 8);
+                if((0 == link_type) ||(2 == link_type))//sco or esco
+                {
+                    hci_conn->type = 1;
+                    update_profile_connection(hci_conn, profile_sco, TRUE);
+                }
+                else
+                    hci_conn->type = 0;
+            }
+            else
+            {
+                ALOGE("HciConnAllocate fail");
+            }
+        }
+        else
+        {
+            LogMsg("HCI Connection handle(0x%x) has already exist!", handle);
+            hci_conn->profile_bitmap = 0;
+            memset(hci_conn->profile_refcount, 0, 8);
+            if((0 == link_type)||(2 == link_type))//sco or esco
+            {
+                hci_conn->type = 1;
+                update_profile_connection(hci_conn, profile_sco, TRUE);
+            }
+            else
+                hci_conn->type = 0;
+        }
+    }
+    else if(rtk_prof.ispaging)
+    {
+        rtk_prof.ispaging = 0;
+        LogMsg("notify wifi page unsuccess end");
+        rtk_notify_btoperation_to_wifi(BT_OPCODE_PAGE_UNSUCCESS_END, 0, NULL);
+    }
+}
+
+static void rtk_handle_disconnect_complete_evt(uint8_t* p)
+{
+    if(rtk_prof.ispairing)//for slave: connection will be disconnected if authentication fail
+    {
+        rtk_prof.ispairing = 0;
+        LogMsg("notify wifi pair end");
+        rtk_notify_btoperation_to_wifi(BT_OPCODE_PAIR_END, 0, NULL);
+    }
+
+    uint8_t status = 0;
+    uint16_t handle = 0;
+    uint8_t reason = 0;
+    status = *p++;
+    STREAM_TO_UINT16(handle, p);
+    reason = *p;
+
+    if(status == 0)
+    {
+        tRTK_CONN_PROF *hci_conn = find_connection_by_handle(&rtk_prof, handle);
+        if(hci_conn)
+        {
+            switch(hci_conn->type)
+            {
+                case 0:
+                {
+                    RT_LIST_ENTRY* iter = NULL, *temp = NULL;
+                    tRTK_PROF_INFO* prof_info = NULL;
+
+                    pthread_mutex_lock(&rtk_prof.profile_mutex);
+                    LIST_FOR_EACH_SAFELY(iter, temp, &rtk_prof.profile_list)
+                    {
+                        prof_info = LIST_ENTRY(iter, tRTK_PROF_INFO, list);
+                        if ((handle == prof_info->handle) && prof_info->scid && prof_info->dcid)
+                        {
+                            LogMsg("find info when hci disconnect, handle:%x, psm:%x, dcid:%x, scid:%x", prof_info->handle, prof_info->psm, prof_info->dcid, prof_info->scid);
+                            //If both scid and dcid > 0, L2cap connection is exist.
+                            update_profile_connection(hci_conn, prof_info->profile_index, FALSE);
+                            delete_profile_from_hash(prof_info);
+                        }
+                    }
+                    pthread_mutex_unlock(&rtk_prof.profile_mutex);
+                    break;
+                }
+
+                case 1:
+                    update_profile_connection(hci_conn, profile_sco, FALSE);
+                    break;
+
+                case 2:
+                {
+                    if(hci_conn->profile_bitmap & BIT(profile_hogp))
+                        update_profile_connection(hci_conn, profile_hogp, FALSE);
+
+                    if(hci_conn->profile_bitmap & BIT(profile_voice))
+                        update_profile_connection(hci_conn, profile_voice, FALSE);
+
+                    update_profile_connection(hci_conn, profile_hid, FALSE);
+                    break;
+                }
+
+                default:
+                    break;
+            }
+            delete_connection_from_hash(hci_conn);
+        }
+        else
+        {
+            ALOGE("HCI Connection handle(0x%x) not found", handle);
+        }
+    }
+}
+
+static void rtk_handle_le_connection_complete_evt(uint8_t* p)
+{
+    uint16_t handle, interval;
+    uint8_t status;
+    tRTK_CONN_PROF* hci_conn = NULL;
+
+    status = *p++;
+    STREAM_TO_UINT16 (handle, p);
+    p += 8; //role, address type, address
+    STREAM_TO_UINT16 (interval, p);
+
+    if(status == 0) {
+        if(rtk_prof.ispaging){
+            rtk_prof.ispaging = 0;
+            LogMsg("notify wifi page success end");
+            rtk_notify_btoperation_to_wifi(BT_OPCODE_PAGE_SUCCESS_END, 0, NULL);
+        }
+
+        hci_conn = find_connection_by_handle(&rtk_prof, handle);
+        if(hci_conn == NULL) {
+            hci_conn = allocate_connection_by_handle(handle);
+            if(hci_conn) {
+                add_connection_to_hash(&rtk_prof, hci_conn);
+                hci_conn->profile_bitmap = 0;
+                memset(hci_conn->profile_refcount, 0, 8);
+                hci_conn->type = 2;
+                update_profile_connection(hci_conn, profile_hid, TRUE); //for coex, le is the same as hid
+                update_hid_active_state(handle, interval);
+            } else {
+                ALOGE("hci connection allocate fail");
+            }
+        } else {
+            LogMsg("hci connection handle(0x%x) has already exist!", handle);
+            hci_conn->profile_bitmap = 0;
+            memset(hci_conn->profile_refcount, 0, 8);
+            hci_conn->type = 2;
+            update_profile_connection(hci_conn, profile_hid, TRUE);
+            update_hid_active_state(handle, interval);
+        }
+    } else if(rtk_prof.ispaging) {
+        rtk_prof.ispaging = 0;
+        LogMsg("notify wifi page unsuccess end");
+        rtk_notify_btoperation_to_wifi(BT_OPCODE_PAGE_UNSUCCESS_END, 0, NULL);
+    }
+}
+
+static void rtk_handle_le_connection_update_complete_evt(uint8_t* p)
+{
+    uint16_t handle, interval;
+    uint8_t status;
+
+    status = *p++;
+    STREAM_TO_UINT16 (handle, p);
+    STREAM_TO_UINT16 (interval, p);
+    update_hid_active_state(handle, interval);
+}
+
+static void rtk_handle_le_meta_evt(uint8_t* p)
+{
+    uint8_t sub_event = *p++;
+    switch (sub_event) {
+    case HCI_BLE_CONN_COMPLETE_EVT:
+        rtk_handle_le_connection_complete_evt(p);
+        break;
+
+    case HCI_BLE_LL_CONN_PARAM_UPD_EVT:
+        rtk_handle_le_connection_update_complete_evt(p);
+        break;
+
+    default :
+        break;
+    }
+}
+
+void rtk_parse_internal_event_intercept(uint8_t *p_msg)
+{
+    //ALOGE("in rtk_parse_internal_event_intercept, *p= %x", *p);
+    uint8_t *p = p_msg;
+    uint8_t event_code = *p++;
+    uint8_t len = *p++;
+    uint16_t opcode, mode_change_handle, mode_interval, subcode;
+    uint8_t status, num_hci_cmd_pkts;
+
+    switch (event_code)
+    {
+        case HCI_INQUIRY_COMP_EVT:
+        {
+            if(rtk_prof.isinquirying)
+            {
+                rtk_prof.isinquirying = 0;
+                LogMsg("notify wifi inquiry end");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_INQUIRY_END, 0, NULL);
+            }
+            break;
+        }
+
+        case HCI_PIN_CODE_REQUEST_EVT:
+        {
+            if(!rtk_prof.ispairing)
+            {
+                rtk_prof.ispairing = 1;
+                LogMsg("notify wifi pair start");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_PAIR_START, 0, NULL);
+            }
+            break;
+        }
+
+        case HCI_IO_CAPABILITY_REQUEST_EVT:
+        {
+            if(!rtk_prof.ispairing)
+            {
+                rtk_prof.ispairing = 1;
+                LogMsg("notify wifi pair start");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_PAIR_START, 0, NULL);
+            }
+            break;
+        }
+
+        case HCI_AUTHENTICATION_COMP_EVT:
+        {
+            if(rtk_prof.ispairing)
+            {
+                rtk_prof.ispairing = 0;
+                LogMsg("notify wifi pair end");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_PAIR_END, 0, NULL);
+            }
+            break;
+        }
+
+        case HCI_LINK_KEY_NOTIFICATION_EVT:
+        {
+            if(rtk_prof.ispairing)
+            {
+                rtk_prof.ispairing = 0;
+                LogMsg("notify wifi pair end");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_PAIR_END, 0, NULL);
+            }
+            break;
+        }
+
+        case HCI_MODE_CHANGE_EVT:
+        {
+            status = *p++;
+            STREAM_TO_UINT16(mode_change_handle, p);
+            p++;
+            STREAM_TO_UINT16(mode_interval, p);
+            update_hid_active_state(mode_change_handle, mode_interval);
+            break;
+        }
+
+        case HCI_COMMAND_COMPLETE_EVT:
+            rtk_handle_cmd_complete_evt(p, len);
+            break;
+
+        case HCI_COMMAND_STATUS_EVT:
+        {
+            status = *p++;
+            num_hci_cmd_pkts = *p++;
+            STREAM_TO_UINT16(opcode, p);
+            if((opcode == HCI_INQUIRY) && (status))
+            {
+                if(rtk_prof.isinquirying)
+                {
+                    rtk_prof.isinquirying = 0;
+                    LogMsg("inquiry start error, notify wifi inquiry stop");
+                    rtk_notify_btoperation_to_wifi(BT_OPCODE_INQUIRY_END, 0, NULL);
+                }
+            }
+
+            if(opcode == HCI_CREATE_CONNECTION)
+            {
+                if(!status && !rtk_prof.ispaging)
+                {
+                    rtk_prof.ispaging = 1;
+                    LogMsg("notify wifi start page");
+                    rtk_notify_btoperation_to_wifi(BT_OPCODE_PAGE_START, 0, NULL);
+                }
+            }
+            break;
+        }
+
+        case HCI_CONNECTION_COMP_EVT:
+        case HCI_ESCO_CONNECTION_COMP_EVT:
+            rtk_handle_connection_complete_evt(p);
+            break;
+
+        case HCI_DISCONNECTION_COMP_EVT:
+            rtk_handle_disconnect_complete_evt(p);
+            break;
+
+        case HCI_VENDOR_SPECIFIC_EVT:
+        {
+            STREAM_TO_UINT16(subcode, p);
+            if(subcode == HCI_VENDOR_PTA_AUTO_REPORT_EVENT)
+            {
+                LogMsg("notify wifi driver with autoreport data");
+                if((len-2) != 8)
+                    LogMsg("rtk_parse_internal_event_intercept:HCI_VENDOR_SPECIFIC_EVT:HCI_VENDOR_PTA_AUTO_REPORT_EVENT len=%d", len);
+                rtk_notify_info_to_wifi(AUTO_REPORT, (len-2), (uint8_t *)p);
+            }
+            break;
+        }
+
+        case HCI_BLE_EVENT:
+            rtk_handle_le_meta_evt(p);
+            break;
+
+        default:
+            break;
+    }
+}
+
+void rtk_parse_command(uint8_t *pp)
+{
+    uint8_t *p =pp;
+    uint16_t cmd;
+    STREAM_TO_UINT16(cmd, p);
+
+    switch (cmd)
+    {
+        case HCI_INQUIRY:
+        case HCI_PERIODIC_INQUIRY_MODE:
+        {
+            if(!rtk_prof.isinquirying)
+            {
+                rtk_prof.isinquirying = 1;
+                LogMsg("notify wifi inquiry start");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_INQUIRY_START, 0, NULL);
+            }
+            break;
+        }
+
+        case HCI_INQUIRY_CANCEL:
+        case HCI_EXIT_PERIODIC_INQUIRY_MODE:
+        {
+            if(rtk_prof.isinquirying)
+            {
+                rtk_prof.isinquirying = 0;
+                LogMsg("notify wifi inquiry stop");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_INQUIRY_END, 0, NULL);
+            }
+            break;
+        }
+
+        case HCI_ACCEPT_CONNECTION_REQUEST:
+        {
+            if(!rtk_prof.ispaging)
+            {
+                rtk_prof.ispaging = 1;
+                LogMsg("notify wifi page start");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_PAGE_START, 0, NULL);
+            }
+            break;
+        }
+
+        default:
+            break;
+    }
+}
+
+void rtk_parse_l2cap_data(uint8_t *pp, uint8_t direction)
+{
+    uint16_t handle, total_len, pdu_len, channel_ID, command_len, psm, scid, dcid, result, status;
+    uint8_t flag, code, identifier;
+    STREAM_TO_UINT16 (handle, pp);
+    flag = handle >> 12;
+    handle = handle & 0x0FFF;
+    STREAM_TO_UINT16 (total_len, pp);
+    STREAM_TO_UINT16 (pdu_len, pp);
+    STREAM_TO_UINT16 (channel_ID, pp);
+
+    if(channel_ID == 0x0001)
+    {
+        code = (uint8_t)(*pp++);
+        switch (code)
+        {
+            case L2CAP_CONNECTION_REQ:
+                identifier = (uint8_t)(*pp++);
+                STREAM_TO_UINT16 (command_len, pp);
+                STREAM_TO_UINT16 (psm, pp);
+                STREAM_TO_UINT16 (scid, pp);
+                LogMsg("L2CAP_CONNECTION_REQ, handle=%x, PSM=%x, scid=%x", handle, psm, scid);
+                handle_l2cap_con_req(handle, psm, scid, direction);
+                break;
+
+            case L2CAP_CONNECTION_RSP:
+                identifier = (uint8_t)(*pp++);
+                STREAM_TO_UINT16 (command_len, pp);
+                STREAM_TO_UINT16 (dcid, pp);
+                STREAM_TO_UINT16 (scid, pp);
+                STREAM_TO_UINT16 (result, pp);
+                STREAM_TO_UINT16 (status, pp);
+                LogMsg("L2CAP_CONNECTION_RESP, handle=%x, dcid=%x, scid=%x, result=%x", handle, dcid, scid, result);
+                //if(result == 0)
+                    handle_l2cap_con_rsp(handle, dcid, scid, direction, result);
+                break;
+
+            case L2CAP_DISCONNECTION_REQ:
+                identifier = (uint8_t)(*pp++);
+                STREAM_TO_UINT16 (command_len, pp);
+                STREAM_TO_UINT16 (dcid, pp);
+                STREAM_TO_UINT16 (scid, pp);
+                LogMsg("L2CAP_DISCONNECTION_REQ, handle=%x, dcid=%x, scid=%x",handle, dcid, scid);
+                handle_l2cap_discon_req(handle, dcid, scid, direction);
+                break;
+
+            case L2CAP_DISCONNECTION_RSP:
+                break;
+
+            default:
+                break;
+        }
+    }
+    else
+    {
+        if((flag != 0x01)&&(is_profile_connected(profile_a2dp) || is_profile_connected(profile_pan)))//Do not count the continuous packets
+            packets_count(handle, channel_ID, pdu_len, direction);
+    }
+}
+
+void rtk_add_le_profile(BD_ADDR bdaddr, uint16_t handle, uint8_t profile_map)
+{
+    LogMsg("rtk_add_le_profile, handle is %x, profile_map is %x", handle, profile_map);
+
+    tRTK_CONN_PROF* hci_conn = find_connection_by_handle(&rtk_prof, handle);
+    if(hci_conn)
+    {
+        if((profile_map & 0x01) || (profile_map & 0x02))//bit0: mouse, bit1:keyboard
+            update_profile_connection(hci_conn, profile_hogp, TRUE);
+
+        if(profile_map & 0x04)
+            update_profile_connection(hci_conn, profile_voice, TRUE);
+    }
+    else
+    {
+        ALOGE("rtk_add_le_profile, connection handle(0x%x) not exist!", handle);
+    }
+}
+
+void rtk_delete_le_profile(BD_ADDR bdaddr, uint16_t handle, uint8_t profile_map)
+{
+    LogMsg("rtk_delete_le_profile, handle is %x, profile_map is %x", handle, profile_map);
+
+    pthread_mutex_lock(&rtk_prof.profile_mutex);
+    tRTK_CONN_PROF* hci_conn = find_connection_by_handle(&rtk_prof, handle);
+    if(hci_conn == NULL)
+    {
+        ALOGE("rtk_delete_le_profile, hci_conn not exist with handle %x", handle);
+    }
+    else
+    {
+        if((profile_map & 0x01) || (profile_map & 0x02))//bit0: mouse, bit1:keyboard
+            update_profile_connection(hci_conn, profile_hogp, FALSE);
+
+        if(profile_map & 0x04)
+            update_profile_connection(hci_conn, profile_voice, FALSE);
+    }
+    pthread_mutex_unlock(&rtk_prof.profile_mutex);
+}
+
+void rtk_add_le_data_count(uint8_t data_type)
+{
+    LogMsg("rtk_add_le_data_count, data_type is %x", data_type);
+
+    if((data_type == 1) || (data_type == 2))//1:keyboard, 2:mouse
+    {
+        rtk_prof.hogp_packet_count++;
+        if(!is_profile_busy(profile_hogp))
+        {
+            LogMsg("hogp idle->busy");
+            update_profile_state(profile_hogp, TRUE);
+        }
+    }
+
+    if(data_type == 3)//voice
+    {
+        rtk_prof.voice_packet_count ++;
+        if(!is_profile_busy(profile_voice))
+        {
+            LogMsg("voice idle->busy");
+            update_profile_state(profile_voice, TRUE);
+        }
+    }
+}
+
+void rtk_add_bitpool_to_fw(uint8_t bitpool)
+{
+    uint8_t temp_cmd[1];
+    ALOGE("rtk_add_bitpool_to_fw bitpool:%d", bitpool);
+    temp_cmd[0] = bitpool;
+    rtk_vendor_cmd_to_fw(HCI_VENDOR_ADD_BITPOOL_FW, 1, temp_cmd);
+}
+
+static const rtk_parse_manager_t interface = {
+  rtk_parse_internal_event_intercept,
+  rtk_parse_l2cap_data,
+  rtk_parse_init,
+  rtk_parse_cleanup,
+  rtk_parse_command,
+  rtk_add_le_profile,
+  rtk_delete_le_profile,
+  rtk_add_le_data_count,
+  rtk_add_bitpool_to_fw,
+};
+
+const rtk_parse_manager_t *rtk_parse_manager_get_interface() {
+  buffer_allocator = buffer_allocator_get_interface();
+  return &interface;
+}
+
+
diff --git a/hci/src/vendor.c b/hci/src/vendor.c
old mode 100644
new mode 100755
index 2e220e4..f3a070b
--- a/hci/src/vendor.c
+++ b/hci/src/vendor.c
@@ -29,6 +29,11 @@
 
 #define LAST_VENDOR_OPCODE_VALUE VENDOR_DO_EPILOG
 
+#ifdef BLUETOOTH_RTK
+#include "bdroid_buildcfg.h"
+static const char *VENDOR_LIBRARY_NAME_USB = "libbt-vendor_usb.so";
+static const char *VENDOR_LIBRARY_NAME_UART = "libbt-vendor_uart.so";
+#endif
 static const char *VENDOR_LIBRARY_NAME = "libbt-vendor.so";
 static const char *VENDOR_LIBRARY_SYMBOL_NAME = "BLUETOOTH_VENDOR_LIB_INTERFACE";
 
@@ -49,11 +54,29 @@ static bool vendor_open(
   assert(lib_handle == NULL);
   hci = hci_interface;
 
+#ifdef BLUETOOTH_RTK
+  if(!bluetooth_rtk_h5_flag ) {
+    lib_handle = dlopen(VENDOR_LIBRARY_NAME_USB,RTLD_NOW);
+    if (!lib_handle) {
+        ALOGE("%s unable to open %s: %s", __func__, VENDOR_LIBRARY_NAME_USB,
+        dlerror());
+        goto error;
+    }
+  } else {
+    lib_handle = dlopen(VENDOR_LIBRARY_NAME_UART,RTLD_NOW);
+    if (!lib_handle) {
+      ALOGE("%s unable to open %s: %s", __func__, VENDOR_LIBRARY_NAME_UART,
+      dlerror());
+      goto error;
+    }
+  }
+#else
   lib_handle = dlopen(VENDOR_LIBRARY_NAME, RTLD_NOW);
   if (!lib_handle) {
     LOG_ERROR("%s unable to open %s: %s", __func__, VENDOR_LIBRARY_NAME, dlerror());
     goto error;
   }
+#endif
 
   lib_interface = (bt_vendor_interface_t *)dlsym(lib_handle, VENDOR_LIBRARY_SYMBOL_NAME);
   if (!lib_interface) {
@@ -63,7 +86,11 @@ static bool vendor_open(
 
   LOG_INFO("alloc value %p", lib_callbacks.alloc);
 
+#ifdef BLUETOOTH_RTK
+  int status = lib_interface->init(&lib_callbacks, (unsigned char *)local_bdaddr,bt_hci_device_node);
+#else
   int status = lib_interface->init(&lib_callbacks, (unsigned char *)local_bdaddr);
+#endif
   if (status) {
     LOG_ERROR("%s unable to initialize vendor library: %d", __func__, status);
     goto error;
@@ -172,7 +199,11 @@ static void transmit_completed_callback(BT_HDR *response, void *context) {
 // Called back from vendor library when it wants to send an HCI command.
 static uint8_t transmit_cb(UNUSED_ATTR uint16_t opcode, void *buffer, tINT_CMD_CBACK callback) {
   assert(hci != NULL);
+#ifdef BLUETOOTH_RTK
+  hci->transmit_int_command(opcode, (BT_HDR *)buffer, callback);
+#else
   hci->transmit_command((BT_HDR *)buffer, transmit_completed_callback, NULL, callback);
+#endif
   return true;
 }
 
diff --git a/include/bt_target.h b/include/bt_target.h
old mode 100644
new mode 100755
index f712d2c..8842179
--- a/include/bt_target.h
+++ b/include/bt_target.h
@@ -675,8 +675,12 @@
 
 /* Minimum number of ACL credit for high priority link */
 #ifndef L2CAP_HIGH_PRI_MIN_XMIT_QUOTA
+#ifdef BLUETOOTH_RTK_COEX
+#define L2CAP_HIGH_PRI_MIN_XMIT_QUOTA       8
+#else
 #define L2CAP_HIGH_PRI_MIN_XMIT_QUOTA       5
 #endif
+#endif
 
 /* used for monitoring HCI ACL credit management */
 #ifndef L2CAP_HCI_FLOW_CONTROL_DEBUG
@@ -786,7 +790,7 @@
  * Enables or disables support for local privacy (ex. address rotation)
  */
 #ifndef BLE_LOCAL_PRIVACY_ENABLED
-#define BLE_LOCAL_PRIVACY_ENABLED         TRUE
+#define BLE_LOCAL_PRIVACY_ENABLED         FALSE
 #endif
 
 /*
@@ -1040,17 +1044,17 @@
 
 /* The port receive queue low watermark level, in number of buffers. */
 #ifndef PORT_RX_BUF_LOW_WM
-#define PORT_RX_BUF_LOW_WM          4
+#define PORT_RX_BUF_LOW_WM          10
 #endif
 
 /* The port receive queue high watermark level, in number of buffers. */
 #ifndef PORT_RX_BUF_HIGH_WM
-#define PORT_RX_BUF_HIGH_WM         10
+#define PORT_RX_BUF_HIGH_WM         40
 #endif
 
 /* The port receive queue critical watermark level, in number of buffers. */
 #ifndef PORT_RX_BUF_CRITICAL_WM
-#define PORT_RX_BUF_CRITICAL_WM     15
+#define PORT_RX_BUF_CRITICAL_WM     45
 #endif
 
 /* The port transmit queue high watermark level, in bytes. */
@@ -1655,8 +1659,12 @@ The maximum number of payload octets that the local device can receive in a sing
 ******************************************************************************/
 
 #ifndef HCILP_INCLUDED
+#ifdef BLUETOOTH_RTK
+#define HCILP_INCLUDED                  FALSE
+#else
 #define HCILP_INCLUDED                  TRUE
 #endif
+#endif
 
 /******************************************************************************
 **
diff --git a/main/Android.mk b/main/Android.mk
old mode 100644
new mode 100755
index ff7b4a5..5290e4e
--- a/main/Android.mk
+++ b/main/Android.mk
@@ -161,12 +161,22 @@ LOCAL_MODULE_CLASS := SHARED_LIBRARIES
 #
 LOCAL_LDLIBS := -Wl,-Bsymbolic,-Bsymbolic-functions
 
+ifeq ($(BOARD_HAVE_BLUETOOTH_RTK),true)
+LOCAL_REQUIRED_MODULES := \
+    auto_pair_devlist.conf \
+    bt_did.conf \
+    bt_stack.conf \
+    libbt-hci \
+    libbt-vendor_uart \
+    libbt-vendor_usb
+else
 LOCAL_REQUIRED_MODULES := \
     auto_pair_devlist.conf \
     bt_did.conf \
     bt_stack.conf \
     libbt-hci \
     libbt-vendor
+endif
 
 LOCAL_MULTILIB := 32
 
diff --git a/main/bte_conf.c b/main/bte_conf.c
old mode 100644
new mode 100755
index 2bf61da..dbc7bf8
--- a/main/bte_conf.c
+++ b/main/bte_conf.c
@@ -21,12 +21,144 @@
 #include <assert.h>
 #include <stdio.h>
 #include <string.h>
-
+#ifdef BLUETOOTH_RTK
+#include <stdlib.h>
+#include <dirent.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <sys/types.h>
+#endif
 #include "bta_api.h"
 #include "osi/include/compat.h"
 #include "osi/include/config.h"
 #include "osi/include/log.h"
+#ifdef BLUETOOTH_RTK
+#include "bt_hci_bdroid.h"
+#include "bdroid_buildcfg.h"
+extern char bt_hci_device_node[BT_HCI_DEVICE_NODE_MAX_LEN];
+extern unsigned int rtkbt_logfilter;
+#endif
 
+#ifdef BLUETOOTH_RTK
+
+#define USB_DEVICE_DIRECTORY  "/sys/bus/usb/devices"
+#define DEBUG_SCAN_USB     FALSE
+
+int Check_Key_Value(char* path,char* key,int value){
+    FILE *fp;
+    char newpath[100];
+    char string_get[6];
+    int value_int = 0;
+    memset(newpath,0,100);
+    sprintf(newpath,"%s/%s",path,key);
+    if((fp=fopen(newpath,"r"))!=NULL){
+        memset(string_get,0,6);
+        if(fgets(string_get,5,fp)!=NULL)
+            if(DEBUG_SCAN_USB)
+                ALOGE("string_get %s =%s\n",key,string_get);
+        fclose(fp);
+        value_int = strtol(string_get,NULL,16);
+        if(value_int == value)
+            return 1;
+    }
+    return 0;
+}
+
+int Scan_Usb_Devices_For_RTK(char* path){
+    char newpath[100];
+    char subpath[100];
+    DIR * pdir;
+    DIR * newpdir;
+    struct dirent * ptr;
+    struct dirent * newptr;
+    struct stat filestat;
+    struct stat subfilestat;
+    if(stat(path, &filestat) != 0){
+        ALOGE("The file or path(%s) can not be get stat!\n", newpath);
+        return -1;
+    }
+    if((filestat.st_mode & S_IFDIR) != S_IFDIR){
+        ALOGE("(%s) is not be a path!\n", path);
+        return -1;
+    }
+    pdir =opendir(path);
+    /*enter sub direc*/
+    while((ptr = readdir(pdir))!=NULL){
+        if(strcmp(ptr->d_name, ".") == 0 || strcmp(ptr->d_name, "..") == 0)
+            continue;
+        memset(newpath,0,100);
+        sprintf(newpath,"%s/%s", path,ptr->d_name);
+        if(DEBUG_SCAN_USB)
+            ALOGE("The file or path(%s)\n", newpath);
+        if(stat(newpath, &filestat) != 0){
+            ALOGE("The file or path(%s) can not be get stat!\n", newpath);
+            continue;
+        }
+        /* Check if it is path. */
+        if((filestat.st_mode & S_IFDIR) == S_IFDIR){
+            if(!Check_Key_Value(newpath,"idVendor",0x0bda))
+                continue;
+            newpdir =opendir(newpath);
+            /*read sub directory*/
+            while((newptr = readdir(newpdir))!=NULL){
+                if(strcmp(newptr->d_name, ".") == 0 || strcmp(newptr->d_name, "..") == 0)
+                    continue;
+                memset(subpath,0,100);
+                sprintf(subpath,"%s/%s", newpath,newptr->d_name);
+                if(DEBUG_SCAN_USB)
+                    ALOGE("The file or path(%s)\n", subpath);
+                if(stat(subpath, &subfilestat) != 0){
+                    ALOGE("The file or path(%s) can not be get stat!\n", newpath);
+                    continue;
+                }
+                 /* Check if it is path. */
+                if((subfilestat.st_mode & S_IFDIR) == S_IFDIR){
+                    if(Check_Key_Value(subpath,"bInterfaceClass",0xe0) && \
+                        Check_Key_Value(subpath,"bInterfaceSubClass",0x01) && \
+                        Check_Key_Value(subpath,"bInterfaceProtocol",0x01)){
+                        closedir(newpdir);
+                        closedir(pdir);
+                        return 1;
+                    }
+                }
+            }
+            closedir(newpdir);
+        }
+    }
+    closedir(pdir);
+    return 0;
+}
+
+void bte_load_rtkbt_conf(const char *path)
+{
+    assert(path != NULL);
+
+    ALOGI("%s attempt to load rtkbt conf from %s",__func__, path);
+
+    config_t *config = config_new(path);
+    if (!config) {
+      ALOGI("%s file >%s< not found", __func__, path);
+      return;
+    }
+    memset(bt_hci_device_node, 0, sizeof(bt_hci_device_node));
+    /*0.check rtkbt.conf*/
+    strlcpy(bt_hci_device_node, config_get_string(config, CONFIG_DEFAULT_SECTION, "BtDeviceNode","/dev/rtk_btusb"), sizeof(bt_hci_device_node));
+    if(bt_hci_device_node[0]=='?'){
+        /*1.Scan_Usb_Device*/
+        if(Scan_Usb_Devices_For_RTK(USB_DEVICE_DIRECTORY) == 0x01)
+            strlcpy(bt_hci_device_node,"/dev/rtk_btusb", sizeof(bt_hci_device_node));
+        else{
+            int i = 0;
+            while(bt_hci_device_node[i]!= '\0'){
+                bt_hci_device_node[i] = bt_hci_device_node[i+1];
+                i++;
+            }
+        }
+    }
+    ALOGI("bt_hci_device_node   = %s \n",bt_hci_device_node);
+    config_free(config);
+}
+#endif
 #if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
 extern int btm_ble_tx_power[BTM_BLE_ADV_TX_POWER_MAX + 1];
 void bte_load_ble_conf(const char* path)
diff --git a/main/bte_main.c b/main/bte_main.c
old mode 100644
new mode 100755
index d08d6f6..eb53248
--- a/main/bte_main.c
+++ b/main/bte_main.c
@@ -65,6 +65,11 @@
 #define BTE_BLE_STACK_CONF_FILE "/etc/bluetooth/ble_stack.conf"
 #endif
 
+#ifdef BLUETOOTH_RTK
+#ifndef BTE_RTK_CONF_FILE
+#define BTE_RTK_CONF_FILE "/etc/bluetooth/rtkbt.conf"
+#endif
+#endif
 /******************************************************************************
 **  Variables
 ******************************************************************************/
@@ -111,6 +116,9 @@ void bte_main_boot_entry(void)
     data_dispatcher_register_default(hci->event_dispatcher, btu_hci_msg_queue);
     hci->set_data_queue(btu_hci_msg_queue);
 
+#ifdef BLUETOOTH_RTK
+    bte_load_rtkbt_conf(BTE_RTK_CONF_FILE);
+#endif
 #if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
     bte_load_ble_conf(BTE_BLE_STACK_CONF_FILE);
 #endif
diff --git a/osi/Android.mk b/osi/Android.mk
old mode 100644
new mode 100755
index 52dc2cf..eb47a31
--- a/osi/Android.mk
+++ b/osi/Android.mk
@@ -49,6 +49,9 @@ LOCAL_SRC_FILES := \
     ./src/thread.c
 
 LOCAL_CFLAGS := -std=c99 -Wall -Werror -UNDEBUG
+ifeq ($(BOARD_HAVE_BLUETOOTH_RTK),true)
+LOCAL_CFLAGS += -DBLUETOOTH_RTK
+endif
 # Many .h files have redefined typedefs
 LOCAL_CLANG_CFLAGS += -Wno-error=typedef-redefinition
 LOCAL_MODULE := libosi
diff --git a/osi/src/semaphore.c b/osi/src/semaphore.c
old mode 100644
new mode 100755
index 5ee9926..2d9bc67
--- a/osi/src/semaphore.c
+++ b/osi/src/semaphore.c
@@ -65,8 +65,28 @@ void semaphore_wait(semaphore_t *semaphore) {
   assert(semaphore->fd != INVALID_FD);
 
   uint64_t value;
+#ifdef BLUETOOTH_RTK
+  int ret;
+
+  while(1) {
+    ret = eventfd_read(semaphore->fd,&value);
+    if (ret == -1) {
+        if(errno == EINTR) {
+            LOG_ERROR("%s unable to eventfd_read(semaphore->fd,&value): %s", __func__, strerror(errno));
+            continue;
+        } else {
+            LOG_ERROR("%s unable to eventfd_read(semaphore->fd,&value) : %s", __func__, strerror(errno));
+            break;
+        }
+    }
+    if(ret >= 0) {
+        break;
+    }
+  }
+#else
   if (eventfd_read(semaphore->fd, &value) == -1)
     LOG_ERROR("%s unable to wait on semaphore: %s", __func__, strerror(errno));
+#endif
 }
 
 bool semaphore_try_wait(semaphore_t *semaphore) {
@@ -95,9 +115,28 @@ bool semaphore_try_wait(semaphore_t *semaphore) {
 void semaphore_post(semaphore_t *semaphore) {
   assert(semaphore != NULL);
   assert(semaphore->fd != INVALID_FD);
-
+#ifdef BLUETOOTH_RTK
+  int ret;
+
+  while(1) {
+    ret = eventfd_write(semaphore->fd, 1ULL);
+    if (ret == -1) {
+        if(errno == EINTR) {
+            LOG_ERROR("%s unable to eventfd_write eventfd_write(semaphore->fd, 1ULL): %s", __func__, strerror(errno));
+            continue;
+        } else {
+            LOG_ERROR("%s unable to eventfd_write eventfd_write(semaphore->fd, 1ULL) : %s", __func__, strerror(errno));
+            break;
+        }
+    }
+    if(ret >= 0) {
+        break;
+    }
+  }
+#else
   if (eventfd_write(semaphore->fd, 1ULL) == -1)
     LOG_ERROR("%s unable to post to semaphore: %s", __func__, strerror(errno));
+#endif
 }
 
 int semaphore_get_fd(const semaphore_t *semaphore) {
diff --git a/stack/btm/btm_ble_int.h b/stack/btm/btm_ble_int.h
old mode 100644
new mode 100755
index f644548..0a5ce36
--- a/stack/btm/btm_ble_int.h
+++ b/stack/btm/btm_ble_int.h
@@ -62,9 +62,14 @@
 #define BTM_BLE_GAP_DISC_SCAN_WIN      18         /* scan_window = 11.25 ms= 0x0010 * 0.625 ms */
 #define BTM_BLE_GAP_ADV_INT            512        /* Tgap(gen_disc) = 1.28 s= 512 * 0.625 ms */
 #define BTM_BLE_GAP_LIM_TOUT           180        /* Tgap(lim_timeout) = 180s max */
+
+#ifdef BLUETOOTH_RTK
+#define BTM_BLE_LOW_LATENCY_SCAN_INT   18       /* Interval(scan_int) = 11.25ms = 18 * 0.625 ms */
+#define BTM_BLE_LOW_LATENCY_SCAN_WIN   18       /* scan_window = 11.25ms = 18 * 0.625 ms */
+#else
 #define BTM_BLE_LOW_LATENCY_SCAN_INT   8000       /* Interval(scan_int) = 5s= 8000 * 0.625 ms */
 #define BTM_BLE_LOW_LATENCY_SCAN_WIN   8000       /* scan_window = 5s= 8000 * 0.625 ms */
-
+#endif
 
 #define BTM_BLE_GAP_ADV_FAST_INT_1         48         /* TGAP(adv_fast_interval1) = 30(used) ~ 60 ms  = 48 *0.625 */
 #define BTM_BLE_GAP_ADV_FAST_INT_2         160         /* TGAP(adv_fast_interval2) = 100(used) ~ 150 ms = 160 * 0.625 ms */
diff --git a/stack/btm/btm_int.h b/stack/btm/btm_int.h
old mode 100644
new mode 100755
index 65f0895..3e9807e
--- a/stack/btm/btm_int.h
+++ b/stack/btm/btm_int.h
@@ -39,6 +39,9 @@
 #include "smp_api.h"
 #endif
 #endif
+#ifdef BLUETOOTH_RTK_COEX
+#include "rtk_parse.h"
+#endif
 
 #if BTM_MAX_LOC_BD_NAME_LEN > 0
 typedef char tBTM_LOC_BD_NAME[BTM_MAX_LOC_BD_NAME_LEN + 1];
@@ -519,6 +522,9 @@ typedef struct
     LINK_KEY             link_key;          /* Device link key                    */
     UINT8                pin_code_length;   /* Length of the pin_code used for paring */
 
+#ifdef BLUETOOTH_RTK_COEX
+    UINT8                profile_map;       /* Profile_map For BT_Wifi Coex */
+#endif
 #define BTM_SEC_AUTHORIZED      BTM_SEC_FLAG_AUTHORIZED     /* 0x01 */
 #define BTM_SEC_AUTHENTICATED   BTM_SEC_FLAG_AUTHENTICATED  /* 0x02 */
 #define BTM_SEC_ENCRYPTED       BTM_SEC_FLAG_ENCRYPTED      /* 0x04 */
diff --git a/stack/btm/btm_sec.c b/stack/btm/btm_sec.c
old mode 100644
new mode 100755
index 68e9a8e..abc718e
--- a/stack/btm/btm_sec.c
+++ b/stack/btm/btm_sec.c
@@ -36,6 +36,9 @@
 #include "bt_utils.h"
 #include "osi/include/log.h"
 
+#ifdef BLUETOOTH_RTK_COEX
+#include "rtk_parse.h"
+#endif
 #if (BT_USE_TRACES == TRUE && BT_TRACE_VERBOSE == FALSE)
 /* needed for sprintf() */
 #include <stdio.h>
@@ -4783,6 +4786,11 @@ void btm_sec_disconnected (UINT16 handle, UINT8 reason)
     if (!p_dev_rec)
         return;
 
+#ifdef BLUETOOTH_RTK_COEX
+    if ((p_dev_rec->device_type &= BT_DEVICE_TYPE_BLE) == 0x02) {
+      rtk_parse_manager_get_interface()->rtk_delete_le_profile(p_dev_rec->bd_addr, p_dev_rec->hci_handle, p_dev_rec->profile_map);
+    }
+#endif
     transport  = (handle == p_dev_rec->hci_handle) ? BT_TRANSPORT_BR_EDR: BT_TRANSPORT_LE;
 
     p_dev_rec->rs_disc_pending = BTM_SEC_RS_NOT_PENDING;     /* reset flag */
diff --git a/stack/l2cap/l2c_utils.c b/stack/l2cap/l2c_utils.c
old mode 100644
new mode 100755
index e80d16b..573ad0e
--- a/stack/l2cap/l2c_utils.c
+++ b/stack/l2cap/l2c_utils.c
@@ -2504,7 +2504,9 @@ BOOLEAN l2cu_set_acl_priority (BD_ADDR bd_addr, UINT8 priority, BOOLEAN reset_af
         return (FALSE);
     }
 
+#ifndef BLUETOOTH_RTK_COEX
     if (BTM_IS_BRCM_CONTROLLER())
+#endif
     {
         /* Called from above L2CAP through API; send VSC if changed */
         if ((!reset_after_rs && (priority != p_lcb->acl_priority)) ||
@@ -2518,7 +2520,9 @@ BOOLEAN l2cu_set_acl_priority (BD_ADDR bd_addr, UINT8 priority, BOOLEAN reset_af
             UINT16_TO_STREAM (pp, p_lcb->handle);
             UINT8_TO_STREAM  (pp, vs_param);
 
+#ifndef BLUETOOTH_RTK_COEX
             BTM_VendorSpecificCommand (HCI_BRCM_SET_ACL_PRIORITY, HCI_BRCM_ACL_PRIORITY_PARAM_SIZE, command, NULL);
+#endif
 
             /* Adjust lmp buffer allocation for this channel if priority changed */
             if (p_lcb->acl_priority != priority)
diff --git a/stack/rfcomm/rfc_int.h b/stack/rfcomm/rfc_int.h
old mode 100644
new mode 100755
index 719a99d..cb1884d
--- a/stack/rfcomm/rfc_int.h
+++ b/stack/rfcomm/rfc_int.h
@@ -208,7 +208,11 @@ typedef struct
 #define RFC_PORT_T1_TIMEOUT             60   /* seconds to wait for reply with Poll bit other than MX */
 #define RFC_T2_TIMEOUT                  20   /* timeout to wait for Mx UIH */
 // btla-specific --
+#ifdef BLUETOOTH_RTK
+#define RFC_DISC_TIMEOUT                30    /* If something goes wrong and we send DISC we should not wait for min */
+#else
 #define RFC_DISC_TIMEOUT                3    /* If something goes wrong and we send DISC we should not wait for min */
+#endif
 #define RFC_CLOSE_TIMEOUT               10
 #define RFCOMM_CONN_TIMEOUT            120   /* first connection to be established on Mx */
 
