diff --git a/AndroidManifest.xml b/AndroidManifest.xml
old mode 100644
new mode 100755
index 85910aa..914653f
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -61,6 +61,13 @@
     <uses-permission android:name="android.permission.VIBRATE" />
     <uses-permission android:name="android.permission.DEVICE_POWER" />
     <uses-permission android:name="android.permission.REAL_GET_TASKS" />
+    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
+
+    <!-- MStar Android Patch Begin -->
+    <!-- For use audio patch -->
+    <uses-permission android:name="android.permission.MODIFY_AUDIO_ROUTING" />
+    <!-- MStar Android Patch End -->
 
     <!-- For PBAP Owner Vcard Info -->
     <uses-permission android:name="android.permission.READ_PROFILE"/>
@@ -127,6 +134,7 @@
             android:theme="@android:style/Theme.Material.Light.Dialog"
             android:label="@string/bt_share_picker_label"
             android:enabled="@bool/profile_supported_opp">
+            <!--
             <intent-filter>
                 <action android:name="android.intent.action.SEND" />
                 <category android:name="android.intent.category.DEFAULT" />
@@ -147,6 +155,7 @@
                 <data android:mimeType="application/vnd.openxmlformats-officedocument.presentationml.presentation" />
                 <data android:mimeType="application/x-hwp" />
             </intent-filter>
+            -->
             <intent-filter>
                 <action android:name="android.intent.action.SEND_MULTIPLE" />
                 <category android:name="android.intent.category.DEFAULT" />
@@ -329,5 +338,21 @@
                 <action android:name="android.bluetooth.IBluetoothHeadsetClient" />
             </intent-filter>
         </service>
+	<!-- MStar Android Patch Begin -->
+        <service
+            android:process="@string/process"
+            android:name = ".rtkbt.RtkbtService"
+            android:enabled="@bool/profile_supported_rtkbt">
+            <intent-filter>
+                <action android:name="android.bluetooth.IBluetoothRtkbt" />
+            </intent-filter>
+        </service>
+        <activity android:name="com.broadcom.bt.settings.BluetoothAdvancedSettings"
+            android:process="@string/process"
+            android:label="@string/bt_advanced_settings"
+            android:excludeFromRecents="true"
+            android:enabled="@bool/supports_advanced_settings">
+        </activity>
+        <!-- MStar Android Patch End -->
     </application>
 </manifest>
diff --git a/jni/Android.mk b/jni/Android.mk
old mode 100644
new mode 100755
index fc4d871..9b32cc0
--- a/jni/Android.mk
+++ b/jni/Android.mk
@@ -15,7 +15,13 @@ LOCAL_SRC_FILES:= \
     com_android_bluetooth_pan.cpp \
     com_android_bluetooth_gatt.cpp \
     com_android_bluetooth_sdp.cpp
-
+ifeq ($(BOARD_HAVE_BLUETOOTH_RTK),true)
+LOCAL_CFLAGS += \
+    -DBLUETOOTH_RTK \
+    -DBLUETOOTH_RTK_API
+LOCAL_SRC_FILES += \
+    com_android_bluetooth_rtkbt.cpp
+endif
 LOCAL_C_INCLUDES += \
     $(JNI_H_INCLUDE) \
 
diff --git a/jni/com_android_bluetooth.h b/jni/com_android_bluetooth.h
old mode 100644
new mode 100755
index 4f55c06..8c69abd
--- a/jni/com_android_bluetooth.h
+++ b/jni/com_android_bluetooth.h
@@ -54,6 +54,10 @@ int register_com_android_bluetooth_gatt (JNIEnv* env);
 
 int register_com_android_bluetooth_sdp (JNIEnv* env);
 
+#ifdef BLUETOOTH_RTK_API
+int register_com_android_bluetooth_rtkbt(JNIEnv* env);
+#endif
+
 }
 
 #endif /* COM_ANDROID_BLUETOOTH_H */
diff --git a/jni/com_android_bluetooth_a2dp.cpp b/jni/com_android_bluetooth_a2dp.cpp
old mode 100644
new mode 100755
index 415f6fe..52b35ee
--- a/jni/com_android_bluetooth_a2dp.cpp
+++ b/jni/com_android_bluetooth_a2dp.cpp
@@ -22,6 +22,7 @@
 #include "hardware/bt_av.h"
 #include "utils/Log.h"
 #include "android_runtime/AndroidRuntime.h"
+#include "cutils/properties.h"
 
 #include <string.h>
 
@@ -67,7 +68,22 @@ static void bta2dp_connection_state_callback(btav_connection_state_t state, bt_b
     sCallbackEnv->CallVoidMethod(mCallbacksObj, method_onConnectionStateChanged, (jint) state,
                                  addr);
     checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
-    sCallbackEnv->DeleteLocalRef(addr);
+    //sCallbackEnv->DeleteLocalRef(addr);
+     // MStar Android Patch Begin
+    // setprop when a2dp connected
+    if (BTAV_CONNECTION_STATE_CONNECTED == state) {
+        ALOGV("a2dp connected set bluetooth.a2dp.connection 2!");
+        if (property_set("bluetooth.a2dp.connection", "2") < 0) {
+            ALOGE("Failed to set bluetooth.a2dp.connection 1!!");
+        }
+    } else if(BTAV_CONNECTION_STATE_DISCONNECTED == state) {
+        ALOGV("a2dp connected set bluetooth.a2dp.connection 0!");
+        if (property_set("bluetooth.a2dp.connection", "0") < 0) {
+            ALOGE("Failed to set bluetooth.a2dp.connection 0!!");
+        }
+    }
+    // MStar Android Patch End
+	sCallbackEnv->DeleteLocalRef(addr);
 }
 
 static void bta2dp_audio_state_callback(btav_audio_state_t state, bt_bdaddr_t* bd_addr) {
diff --git a/jni/com_android_bluetooth_btservice_AdapterService.cpp b/jni/com_android_bluetooth_btservice_AdapterService.cpp
index 9223157..6332f4a 100755
--- a/jni/com_android_bluetooth_btservice_AdapterService.cpp
+++ b/jni/com_android_bluetooth_btservice_AdapterService.cpp
@@ -682,7 +682,6 @@ static bool initNative(JNIEnv* env, jobject obj) {
                   sBluetoothInterface->get_profile_interface(BT_PROFILE_SOCKETS_ID)) == NULL) {
                 ALOGE("Error getting socket interface");
         }
-
         return JNI_TRUE;
     }
     return JNI_FALSE;
@@ -1245,6 +1244,12 @@ jint JNI_OnLoad(JavaVM *jvm, void *reserved)
         ALOGE("jni sdp registration failure: %d", status);
         return JNI_ERR;
     }
+#ifdef BLUETOOTH_RTK_API
+    if ((status = android::register_com_android_bluetooth_rtkbt(e)) < 0) {
+        ALOGE("jni rtkbt registration failure: %d", status);
+        return JNI_ERR;
+    }
+#endif
 
     return JNI_VERSION_1_6;
 }
diff --git a/jni/com_android_bluetooth_rtkbt.cpp b/jni/com_android_bluetooth_rtkbt.cpp
new file mode 100755
index 0000000..55eecc7
--- /dev/null
+++ b/jni/com_android_bluetooth_rtkbt.cpp
@@ -0,0 +1,213 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "RTKBT"
+
+#define LOG_NDEBUG 0
+
+#include "utils/Log.h"
+#include <string.h>
+#include "com_android_bluetooth.h"
+#include "hardware/bluetooth.h"
+#include "hardware/bt_rtkbt.h"
+#include "android_runtime/AndroidRuntime.h"
+
+namespace android {
+static jmethodID method_onGenericEvent;
+
+static const bt_interface_t* sBtIf;
+static rtkbt_interface_t* sRtkbtIf = NULL;
+
+static jobject mCallbacksObj = NULL;
+static JNIEnv *sCallbackEnv = NULL;
+
+/*
+*utilits function
+*/
+static void dumpData(jbyte* data, int len) {
+       ALOGE(" the len is:%d, the data is : ", len);
+       for(int i=0; i<len; i++)
+              ALOGE("%2x ", data[i]);
+}
+
+
+static bool checkCallbackThread() {
+    // Always fetch the latest callbackEnv from AdapterService.
+    // Caching this could cause this sCallbackEnv to go out-of-sync
+    // with the AdapterService's ENV if an ASSOCIATE/DISASSOCIATE event
+    // is received
+    sCallbackEnv = getCallbackEnv();
+
+    JNIEnv* env = AndroidRuntime::getJNIEnv();
+    if (sCallbackEnv != env || sCallbackEnv == NULL) return false;
+    return true;
+}
+
+static int GenericEvent(int id, int event, unsigned char * data, int len) {
+    jbyteArray evt_data;
+    jbyte lenth = (jbyte)len;
+    ALOGI("%s, data_len = %d", __FUNCTION__, len);
+
+    if (!checkCallbackThread()) {
+        ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
+        return -1;
+    }
+
+    if(sCallbackEnv == NULL) {
+        ALOGI("%s, sCallbackEnv is NULL!!!!", __FUNCTION__);
+        return -2;
+    }
+
+    evt_data = sCallbackEnv->NewByteArray(lenth);
+    if (!evt_data) {
+        ALOGE("Fail to new jbyteArray GenericEvent");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return -3;
+    }
+
+    sCallbackEnv->SetByteArrayRegion(evt_data, 0, lenth, (jbyte*)data);
+    ALOGI("%s, CallVoidMethod1", __FUNCTION__);
+    if(mCallbacksObj == NULL)
+        ALOGI("%s, mCallbacksObj is NULL", __FUNCTION__);
+    if(method_onGenericEvent == NULL)
+        ALOGI("%s, method_onGenericEvent is NULL", __FUNCTION__);
+    if(mCallbacksObj != NULL && method_onGenericEvent != NULL)
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_onGenericEvent, id, event, evt_data, len);
+
+    ALOGI("%s, CallVoidMethod2", __FUNCTION__);
+    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(evt_data);
+    return 0;
+}
+
+/*
+*3dd callback
+*/
+static rtkbt_callbacks_t sRtkbtCallbacks = {
+    sizeof(rtkbt_callbacks_t),
+    GenericEvent,
+};
+static void classInitNative(JNIEnv* env, jclass clazz) {
+    method_onGenericEvent = env->GetMethodID(clazz, "onGenericEvent","(II[BI)V");
+}
+/*
+* native function definition
+*/
+static void InitNative(JNIEnv *env, jobject object) {
+    int status;
+    ALOGI("%s", __FUNCTION__);
+    /*bluetooth interface provide by bluedroid*/
+    if(sBtIf == NULL)  {
+    if ( (sBtIf = getBluetoothInterface()) == NULL) {
+        ALOGE("Bluetooth module is not loaded");
+        return;
+    }
+    }
+
+    if ( (sRtkbtIf = (rtkbt_interface_t *)
+          sBtIf->get_profile_interface(BT_PROFILE_RTKBT_ID)) == NULL) {
+        ALOGE("Failed to get RTKBT Interface");
+        return;
+    }
+    if(sRtkbtIf->init)
+        sRtkbtIf->init(&sRtkbtCallbacks);
+    ALOGE("Bluetooth rtkbt successfully");
+    mCallbacksObj = env->NewGlobalRef(object);
+}
+
+static void CleanupNative(JNIEnv *env, jobject object) {
+    int status;
+
+    if (mCallbacksObj != NULL) {
+        env->DeleteGlobalRef(mCallbacksObj);
+        mCallbacksObj = NULL;
+    }
+    if (!sBtIf) return;
+    if (!sRtkbtIf) return;
+
+    if(sRtkbtIf->cleanup)
+        sRtkbtIf->cleanup();
+
+    sBtIf = NULL;
+    sRtkbtIf = NULL;
+    return;
+}
+
+static int GetFeatureNative(JNIEnv *env, jobject object, jint id) {
+    ALOGI("%s", __FUNCTION__);
+    jbyte *data;
+    uint8_t len;
+    int res;
+    if (!sBtIf) return -1;
+    if (!sRtkbtIf) return -2;
+    if(sRtkbtIf->GetFeature == NULL) return -3;
+    ALOGI("GetFeatureNative,id=%d", id);
+
+    res = sRtkbtIf->GetFeature(id);
+    ALOGE("GetFeatureNative->GetFeature return res: %d", res);
+    return res;
+}
+
+static int GenericCommandNative(JNIEnv *env, jobject object, jint id, jint command,jbyteArray args,jint len) {
+    ALOGI("%s", __FUNCTION__);
+    jbyte * data = NULL;
+    int res;
+    if (!sBtIf) return -1;
+    if (!sRtkbtIf) return -2;
+    if(sRtkbtIf->GenericCommand == NULL) return -3;
+
+    /*get command data and length*/
+    if(len > 0)
+    {
+        data = env->GetByteArrayElements(args, NULL);
+        if (!data) {
+            jniThrowIOException(env, EINVAL);
+            return JNI_FALSE;
+        }
+    }else
+        data = NULL;
+
+    ALOGI("GenericCommandNative,id=%d len = %d", id, len);
+
+    res = sRtkbtIf->GenericCommand(id, command, (uint8_t*)data, len);
+
+    ALOGE("GenericCommandNative->GenericCommand return res: %d", res);
+    if(len > 0)
+        env->ReleaseByteArrayElements(args, data, 0);
+    return res;
+}
+
+/**
+ * JNI function definitinos
+ */
+static JNINativeMethod sMethods[] = {
+    {"classInitNative", "()V", (void *) classInitNative},
+    {"InitNative", "()V", (void *) InitNative},
+    {"CleanupNative", "()V", (void *) CleanupNative},
+    {"GetFeatureNative", "(I)I", (void *) GetFeatureNative},
+    {"GenericCommandNative", "(II[BI)I", (void *) GenericCommandNative},
+};
+
+/*
+* register 3dd native method and get java methods
+*/
+int register_com_android_bluetooth_rtkbt(JNIEnv* env)
+{
+    ALOGE("jniRegisterNativeMethods");
+    return jniRegisterNativeMethods(env, "com/android/bluetooth/rtkbt/RtkbtService",
+                                    sMethods, NELEM(sMethods));
+}
+}
diff --git a/res/layout/preference_header_item.xml b/res/layout/preference_header_item.xml
new file mode 100755
index 0000000..9f8222b
--- /dev/null
+++ b/res/layout/preference_header_item.xml
@@ -0,0 +1,97 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+   Copyright (C) 2012-2013 Broadcom Corporation
+
+   This program is the proprietary software of Broadcom Corporation and/or its
+   licensors, and may only be used, duplicated, modified or distributed
+   pursuant to the terms and conditions of a separate, written license
+   agreement executed between you and Broadcom (an "Authorized License").
+   Except as set forth in an Authorized License, Broadcom grants no license
+   (express or implied), right to use, or waiver of any kind with respect to
+   the Software, and Broadcom expressly reserves all rights in and to the
+   Software and all intellectual property rights therein.
+   IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
+   SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+   ALL USE OF THE SOFTWARE.
+
+   Except as expressly set forth in the Authorized License,
+
+   1.     This program, including its structure, sequence and organization,
+          constitutes the valuable trade secrets of Broadcom, and you shall
+          use all reasonable efforts to protect the confidentiality thereof,
+          and to use this information only in connection with your use of
+          Broadcom integrated circuit products.
+
+   2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
+          "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+          REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+          OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+          DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+          NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+          ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+          CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
+          OF USE OR PERFORMANCE OF THE SOFTWARE.
+
+   3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
+          ITS LICENSORS BE LIABLE FOR
+          (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
+                DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
+                YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
+                HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
+          (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
+                SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
+                LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
+                ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
+-->
+<!-- Layout of a header item in PreferenceActivity. -->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:minHeight="48dp"
+    android:background="?android:attr/activatedBackgroundIndicator"
+    android:gravity="center_vertical"
+    android:paddingRight="?android:attr/scrollbarSize">
+
+    <LinearLayout
+        android:id="@+id/image_layout"
+        android:visibility="gone"
+        android:layout_width="@dimen/header_icon_width"
+        android:layout_marginLeft="6dip"
+        android:layout_marginRight="6dip"
+        android:layout_height="wrap_content">
+        <ImageView
+            android:id="@+id/icon"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center" />
+    </LinearLayout>
+
+    <RelativeLayout
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginLeft="2dip"
+        android:layout_marginRight="6dip"
+        android:layout_marginTop="6dip"
+        android:layout_marginBottom="6dip"
+        android:layout_weight="1">
+
+        <TextView android:id="@+android:id/title"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:singleLine="true"
+            android:textAppearance="?android:attr/textAppearanceMedium"
+            android:ellipsize="marquee"
+            android:fadingEdge="horizontal" />
+
+        <TextView android:id="@+android:id/summary"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_below="@android:id/title"
+            android:layout_alignLeft="@android:id/title"
+            android:textAppearance="?android:attr/textAppearanceSmall"
+            android:ellipsize="end"
+            android:maxLines="2" />
+
+    </RelativeLayout>
+
+</LinearLayout>
diff --git a/res/layout/preference_header_mode_switch_item.xml b/res/layout/preference_header_mode_switch_item.xml
new file mode 100755
index 0000000..0e1f802
--- /dev/null
+++ b/res/layout/preference_header_mode_switch_item.xml
@@ -0,0 +1,105 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+   Copyright (C) 2012-2013 Broadcom Corporation
+
+   This program is the proprietary software of Broadcom Corporation and/or its
+   licensors, and may only be used, duplicated, modified or distributed
+   pursuant to the terms and conditions of a separate, written license
+   agreement executed between you and Broadcom (an "Authorized License").
+   Except as set forth in an Authorized License, Broadcom grants no license
+   (express or implied), right to use, or waiver of any kind with respect to
+   the Software, and Broadcom expressly reserves all rights in and to the
+   Software and all intellectual property rights therein.
+   IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
+   SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+   ALL USE OF THE SOFTWARE.
+
+   Except as expressly set forth in the Authorized License,
+
+   1.     This program, including its structure, sequence and organization,
+          constitutes the valuable trade secrets of Broadcom, and you shall
+          use all reasonable efforts to protect the confidentiality thereof,
+          and to use this information only in connection with your use of
+          Broadcom integrated circuit products.
+
+   2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
+          "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+          REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+          OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+          DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+          NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+          ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+          CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
+          OF USE OR PERFORMANCE OF THE SOFTWARE.
+
+   3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
+          ITS LICENSORS BE LIABLE FOR
+          (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
+                DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
+                YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
+                HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
+          (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
+                SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
+                LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
+                ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
+-->
+<!-- Layout of a header item in PreferenceActivity. -->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:minHeight="48dp"
+    android:background="?android:attr/activatedBackgroundIndicator"
+    android:gravity="center_vertical"
+    android:paddingEnd="?android:attr/scrollbarSize">
+
+    <LinearLayout
+        android:layout_width="@dimen/header_icon_width"
+        android:layout_marginStart="6dip"
+        android:layout_marginEnd="6dip"
+        android:layout_height="wrap_content">
+        <ImageView
+            android:id="@+id/icon"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center" />
+    </LinearLayout>
+
+    <RelativeLayout
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginStart="2dip"
+        android:layout_marginEnd="6dip"
+        android:layout_marginTop="6dip"
+        android:layout_marginBottom="6dip"
+        android:layout_weight="1">
+
+        <TextView android:id="@+android:id/title"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:singleLine="true"
+            android:textAppearance="?android:attr/textAppearanceMedium"
+            android:ellipsize="marquee"
+            android:fadingEdge="horizontal" />
+
+        <TextView android:id="@+android:id/summary"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_below="@android:id/title"
+            android:layout_alignStart="@android:id/title"
+            android:textAppearance="?android:attr/textAppearanceSmall"
+            android:ellipsize="end"
+            android:maxLines="2" />
+
+    </RelativeLayout>
+
+   <Switch android:id="@+id/switchWidget"
+       android:layout_width="wrap_content"
+       android:layout_height="wrap_content"
+       android:layout_gravity="center"
+       android:padding="8dip"
+       android:focusable="false"
+       android:clickable="true"
+       android:textOn="TV"
+       android:textOff="HeadSet" />
+
+</LinearLayout>
diff --git a/res/layout/preference_header_switch_item.xml b/res/layout/preference_header_switch_item.xml
new file mode 100755
index 0000000..4099316
--- /dev/null
+++ b/res/layout/preference_header_switch_item.xml
@@ -0,0 +1,105 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+   Copyright (C) 2012-2013 Broadcom Corporation
+
+   This program is the proprietary software of Broadcom Corporation and/or its
+   licensors, and may only be used, duplicated, modified or distributed
+   pursuant to the terms and conditions of a separate, written license
+   agreement executed between you and Broadcom (an "Authorized License").
+   Except as set forth in an Authorized License, Broadcom grants no license
+   (express or implied), right to use, or waiver of any kind with respect to
+   the Software, and Broadcom expressly reserves all rights in and to the
+   Software and all intellectual property rights therein.
+   IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
+   SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+   ALL USE OF THE SOFTWARE.
+
+   Except as expressly set forth in the Authorized License,
+
+   1.     This program, including its structure, sequence and organization,
+          constitutes the valuable trade secrets of Broadcom, and you shall
+          use all reasonable efforts to protect the confidentiality thereof,
+          and to use this information only in connection with your use of
+          Broadcom integrated circuit products.
+
+   2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
+          "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+          REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+          OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+          DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+          NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+          ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+          CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
+          OF USE OR PERFORMANCE OF THE SOFTWARE.
+
+   3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
+          ITS LICENSORS BE LIABLE FOR
+          (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
+                DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
+                YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
+                HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
+          (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
+                SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
+                LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
+                ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
+-->
+
+<!-- Layout of a header item in PreferenceActivity. -->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:minHeight="48dp"
+    android:background="?android:attr/activatedBackgroundIndicator"
+    android:gravity="center_vertical"
+    android:paddingRight="?android:attr/scrollbarSize">
+    <LinearLayout
+        android:id="@+id/image_layout"
+        android:visibility="gone"
+        android:layout_width="@dimen/header_icon_width"
+        android:layout_marginLeft="6dip"
+        android:layout_marginRight="6dip"
+        android:layout_height="wrap_content">
+        <ImageView
+            android:id="@+id/icon"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center" />
+    </LinearLayout>
+
+    <RelativeLayout
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginLeft="2dip"
+        android:layout_marginRight="6dip"
+        android:layout_marginTop="6dip"
+        android:layout_marginBottom="6dip"
+        android:layout_weight="1">
+
+        <TextView android:id="@+android:id/title"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:singleLine="true"
+            android:textAppearance="?android:attr/textAppearanceMedium"
+            android:ellipsize="marquee"
+            android:fadingEdge="horizontal" />
+
+        <TextView android:id="@+android:id/summary"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_below="@android:id/title"
+            android:layout_alignLeft="@android:id/title"
+            android:textAppearance="?android:attr/textAppearanceSmall"
+            android:ellipsize="end"
+            android:maxLines="2" />
+
+    </RelativeLayout>
+
+   <Switch android:id="@+id/switchWidget"
+       android:layout_width="wrap_content"
+       android:layout_height="wrap_content"
+       android:layout_gravity="center"
+       android:padding="8dip"
+       android:focusable="false"
+       android:clickable="true" />
+
+</LinearLayout>
diff --git a/res/values/config.xml b/res/values/config.xml
old mode 100644
new mode 100755
index 1684183..214357a
--- a/res/values/config.xml
+++ b/res/values/config.xml
@@ -13,8 +13,12 @@
    limitations under the License.
 -->
 <resources>
+    <bool name="profile_supported_rtkbt">true</bool>
     <bool name="profile_supported_a2dp">true</bool>
-    <bool name="profile_supported_a2dp_sink">false</bool>
+    <!-- MStar Android Patch Begin -->
+    <!-- Support a2dp sink profile -->
+    <bool name="profile_supported_a2dp_sink">true</bool>
+    <!-- MStar Android Patch End -->
     <bool name="profile_supported_hdp">true</bool>
     <bool name="profile_supported_hs_hfp">true</bool>
     <bool name="profile_supported_hfpclient">false</bool>
diff --git a/res/values/config_bt.xml b/res/values/config_bt.xml
new file mode 100755
index 0000000..da083cf
--- /dev/null
+++ b/res/values/config_bt.xml
@@ -0,0 +1,157 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+   Copyright (C) 2012-2013 Broadcom Corporation
+
+   This program is the proprietary software of Broadcom Corporation and/or its
+   licensors, and may only be used, duplicated, modified or distributed
+   pursuant to the terms and conditions of a separate, written license
+   agreement executed between you and Broadcom (an "Authorized License").
+   Except as set forth in an Authorized License, Broadcom grants no license
+   (express or implied), right to use, or waiver of any kind with respect to
+   the Software, and Broadcom expressly reserves all rights in and to the
+   Software and all intellectual property rights therein.
+   IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
+   SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+   ALL USE OF THE SOFTWARE.
+
+   Except as expressly set forth in the Authorized License,
+
+   1.     This program, including its structure, sequence and organization,
+          constitutes the valuable trade secrets of Broadcom, and you shall
+          use all reasonable efforts to protect the confidentiality thereof,
+          and to use this information only in connection with your use of
+          Broadcom integrated circuit products.
+
+   2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
+          "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+          REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+          OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+          DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+          NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+          ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+          CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
+          OF USE OR PERFORMANCE OF THE SOFTWARE.
+
+   3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
+          ITS LICENSORS BE LIABLE FOR
+          (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
+                DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
+                YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
+                HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
+          (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
+                SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
+                LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
+                ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
+-->
+<resources>
+
+    <!-- Supports advanced settings configuration by user -->
+    <bool name="supports_advanced_settings">true</bool>
+
+
+    <bool name="supports_device_mode_cfg">true</bool>
+
+
+    <!-- Standard Profiles. Enable/disable from config.xml -->
+    <!--Refer ProfileConfig.java for configuring profile_cfg_run_in_device_mode_-->
+    <bool name="profile_default_start_hs_hfp">false</bool>
+    <bool name="profile_configurable_hs_hfp">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_hs_hfp">2</integer>
+    <bool name="profile_default_start_a2dp">true</bool>
+    <bool name="profile_default_start_a2dp_sink">false</bool>
+    <bool name="profile_configurable_a2dp">false</bool>
+    <bool name="profile_configurable_a2dp_sink">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_a2dp">2</integer>
+    <integer name="profile_cfg_run_in_device_mode_a2dp_sink">1</integer>
+    <bool name="profile_default_start_hid">true</bool>
+    <bool name="profile_configurable_hid">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_hid">0</integer>
+    <bool name="profile_default_start_hdp">true</bool>
+    <bool name="profile_configurable_hdp">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_hdp">0</integer>
+    <bool name="profile_default_start_pan">false</bool>
+    <bool name="profile_configurable_pan">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_pan">0</integer>
+    <bool name="profile_default_start_mse">false</bool>
+    <bool name="profile_configurable_mse">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_mse">0</integer>
+
+    <bool name="profile_configurable_hfclient">false</bool>
+    <bool name="profile_default_start_hfclient">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_hfclient">0</integer>
+    <!-- Broadcom Profiles -->
+    <bool name="profile_default_start_3d_sync">true</bool>
+    <bool name="profile_configurable_3d_sync">false</bool>
+    <bool name="run_in_quiet_mode_3d_sync">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_3d_sync">0</integer>
+
+    <!-- Gatt Profile -->
+    <bool name="profile_default_start_gatt">true</bool>
+    <bool name="profile_configurable_gatt">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_gatt">0</integer>
+    <!-- RTKBT profile -->
+    <bool name="profile_default_start_rtkbt">true</bool>
+    <bool name="profile_configurable_rtkbt">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_rtkbt">0</integer>
+
+    <!-- Opp Profile  -->
+    <bool name="profile_supported_opp_1_2_service">true</bool>
+    <bool name="profile_default_start_opp_service">true</bool>
+    <bool name="profile_configurable_opp_service">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_opp">0</integer>
+
+
+    <!-- FTP Profile -->
+    <bool name="profile_supported_ftp_server">false</bool>
+    <bool name="profile_default_start_ftp_server">false</bool>
+    <bool name="profile_configurable_ftp_server">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_ftp_server">0</integer>
+
+    <!-- SAP Profile -->
+    <bool name="profile_default_start_sap">false</bool>
+    <bool name="profile_configurable_sap">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_sap">0</integer>
+
+    <!-- MAP MSE Profile -->
+    <bool name="mse_datasource_supported_sms">false</bool>
+    <bool name="mse_datasource_supported_mms">false</bool>
+    <string name="profile_map_version">MAP 1.2</string>
+
+    <!-- DUN Profile -->
+    <bool name="profile_supported_dun">false</bool>
+    <bool name="profile_default_start_dun">false</bool>
+    <bool name="profile_configurable_dun">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_dun">0</integer>
+
+    <!-- HID Device Profile -->
+    <bool name="profile_supported_hidd">false</bool>
+    <bool name="profile_default_start_hidd">false</bool>
+    <bool name="profile_configurable_hidd">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_hidd">0</integer>
+
+    <!-- AVRCP Controller Profile -->
+    <bool name="profile_default_start_avrcp_ct">true</bool>
+    <bool name="profile_configurable_avrcp_ct">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_avrcp_ct">0</integer>
+
+    <!-- MAP MCE Profile -->
+    <bool name="profile_supported_mce">false</bool>
+    <bool name="profile_default_start_mce">false</bool>
+    <bool name="profile_configurable_mce">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_mce">0</integer>
+
+    <bool name="tv_mode">true</bool>
+
+    <!-- HF device Profile -->
+    <bool name="profile_supported_hfdevice">false</bool>
+    <bool name="profile_default_start_hfdevice">false</bool>
+    <bool name="profile_configurable_hfdevice">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_hfdevice">1</integer>
+
+    <!-- IPSP Profile -->
+    <bool name="profile_supported_ipsp">false</bool>
+    <bool name="profile_default_start_ipsp">false</bool>
+    <bool name="profile_configurable_ipsp">false</bool>
+    <integer name="profile_cfg_run_in_device_mode_ipsp">0</integer>
+
+</resources>
diff --git a/res/values/dimens_bt.xml b/res/values/dimens_bt.xml
new file mode 100755
index 0000000..2ad3fe0
--- /dev/null
+++ b/res/values/dimens_bt.xml
@@ -0,0 +1,54 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+   Copyright (C) 2015 Broadcom Corporation
+
+   This program is the proprietary software of Broadcom Corporation and/or its
+   licensors, and may only be used, duplicated, modified or distributed
+   pursuant to the terms and conditions of a separate, written license
+   agreement executed between you and Broadcom (an "Authorized License").
+   Except as set forth in an Authorized License, Broadcom grants no license
+   (express or implied), right to use, or waiver of any kind with respect to
+   the Software, and Broadcom expressly reserves all rights in and to the
+   Software and all intellectual property rights therein.
+   IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
+   SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+   ALL USE OF THE SOFTWARE.
+
+   Except as expressly set forth in the Authorized License,
+
+   1.     This program, including its structure, sequence and organization,
+          constitutes the valuable trade secrets of Broadcom, and you shall
+          use all reasonable efforts to protect the confidentiality thereof,
+          and to use this information only in connection with your use of
+          Broadcom integrated circuit products.
+
+   2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
+          "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+          REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+          OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+          DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+          NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+          ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+          CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
+          OF USE OR PERFORMANCE OF THE SOFTWARE.
+
+   3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
+          ITS LICENSORS BE LIABLE FOR
+          (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
+                DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
+                YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
+                HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
+          (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
+                SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
+                LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
+                ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
+-->
+
+<resources>
+
+
+    <!--  Size of icons in the top-level of settings  -->
+    <dimen name="header_icon_width">28dp</dimen>
+    <dimen name="appwidget_min_width">260dip</dimen>
+    <dimen name="appwidget_min_height">40dip</dimen>
+</resources>
diff --git a/res/values/strings_bt.xml b/res/values/strings_bt.xml
new file mode 100755
index 0000000..9e80677
--- /dev/null
+++ b/res/values/strings_bt.xml
@@ -0,0 +1,110 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+   Copyright (C) 2015 Broadcom Corporation
+
+   This program is the proprietary software of Broadcom Corporation and/or its
+   licensors, and may only be used, duplicated, modified or distributed
+   pursuant to the terms and conditions of a separate, written license
+   agreement executed between you and Broadcom (an "Authorized License").
+   Except as set forth in an Authorized License, Broadcom grants no license
+   (express or implied), right to use, or waiver of any kind with respect to
+   the Software, and Broadcom expressly reserves all rights in and to the
+   Software and all intellectual property rights therein.
+   IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
+   SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+   ALL USE OF THE SOFTWARE.
+
+   Except as expressly set forth in the Authorized License,
+
+   1.     This program, including its structure, sequence and organization,
+          constitutes the valuable trade secrets of Broadcom, and you shall
+          use all reasonable efforts to protect the confidentiality thereof,
+          and to use this information only in connection with your use of
+          Broadcom integrated circuit products.
+
+   2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
+          "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+          REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+          OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+          DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+          NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+          ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+          CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
+          OF USE OR PERFORMANCE OF THE SOFTWARE.
+
+   3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
+          ITS LICENSORS BE LIABLE FOR
+          (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
+                DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
+                YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
+                HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
+          (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
+                SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
+                LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
+                ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
+-->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+    <string name="permlab_bluetoothMap">Access Bluetooth Message Access Profile content provider.</string>
+    <string name="permdesc_bluetoothMap">Allows the app to access the Bluetooth Message Access Profile content provider and use it send messages to MAP messages to clients.</string>
+    <string name="permlab_fm_receiver">access FM receiver</string>
+    <string name="permdesc_fm_receiver">Allows an application to access the FM receiver functions.</string>
+    <string name="bt_advanced_settings">Bluetooth Advanced Settings</string>
+    <string name="profile_hs_hfp">HS/HFP</string>
+    <string name="profile_description_hs_hfp">Headset/Handsfree Profile</string>
+    <string name="profile_a2dp">A2DP</string>
+    <string name="profile_a2dp_sink">A2DP_SINK</string>
+    <string name="profile_description_a2dp_sink">A2DP Profile Sink</string>
+    <string name="profile_description_a2dp">A2DP Profile</string>
+    <string name="profile_hid">HID Host</string>
+    <string name="profile_description_hid">Human Interface Device (Host) Profile</string>
+    <string name="profile_hdp">HDP</string>
+    <string name="profile_description_hdp">Health Devices Profile</string>
+    <string name="profile_pan">PAN</string>
+    <string name="profile_description_pan">Personal Area Network Profile</string>
+    <string name="profile_dun">DUN</string>
+    <string name="profile_description_dun">Dial Up Network Profile</string>
+    <string name="profile_gatt">GATT</string>
+    <string name="profile_description_gatt">GATT/BLE Profile</string>
+    <string name="profile_rtkbt">RTKBT</string>
+    <string name="profile_description_rtkbt">Realtek Private Profile</string>
+    <string name="profile_sap">SAP</string>
+    <string name="profile_description_sap">SIM Access Profile</string>
+    <string name="profile_ftp">FTP</string>
+    <string name="profile_description_ftp">File Transfer (Server) Profile</string>
+    <string name="profile_mse">MAP</string>
+    <string name="profile_description_mse">Message Access Profile</string>
+    <string name="title_bt_mse_settings">Bluetooth MAP Advanced Settings</string>
+    <string name="map_provider_smsmms_name">Messaging</string>
+    <string name="map_datasource_sms_name">SMS</string>
+    <string name="map_datasource_mms_name">MMS</string>
+    <string name="map_datasource_smsmms_name">SMS and MMS</string>
+    <string name="profile_hidd">HID Device</string>
+    <string name="profile_description_hidd">Human Interface Device (Device) Profile</string>
+    <string name="profile_avrcp_ct">AVRCP Controller</string>
+    <string name="profile_description_avrcp_ct">AVRCP Controller Profile</string>
+    <string name="profile_hfdevice">HF Device</string>
+    <string name="profile_hfclient">HF Client</string>
+    <string name="profile_description_hfdevice">HFP-HF</string>
+    <string name="profile_mce">MAP MCE</string>
+    <string name="profile_description_mce">Message Access Profile (Client)</string>
+    <string name="title_bt_mce_settings">MAP Client Advanced Settings</string>
+    <string name="profile_ipsp">IPSP Profile</string>
+    <string name="profile_description_ipsp">IPSP Profile</string>
+    <!-- For Selecting the Active Modes -->
+    <string name="active_mode">Phone Device Mode</string>
+    <string name="TV_mode">TV_mode</string>
+    <string name="Headset_mode">Headset_mode</string>
+    <string name="bt_toast_conn">Connection not allowed in this mode
+    </string>
+    <string name="profile_3d_sync">3D Glass</string>
+    <string name="profile_description_3d_sync">3D Glass Profile</string>
+    <!--Enabling and disabling of OPP service -->
+    <string name="profile_opp">OPP</string>
+    <string name="profile_description_opp">Object Push Profile</string>
+    <!-- newly added string for OPP 1.2 implementation -->
+    <string name="status_no_permission">no permission.</string>
+    <string name="status_srv_unavailable">Service unavailable.</string>
+    <string name="status_opc_not_found">response not found.</string>
+
+</resources>
diff --git a/src/com/android/bluetooth/a2dp/A2dpService.java b/src/com/android/bluetooth/a2dp/A2dpService.java
index e14302c..9952ab8 100755
--- a/src/com/android/bluetooth/a2dp/A2dpService.java
+++ b/src/com/android/bluetooth/a2dp/A2dpService.java
@@ -149,7 +149,8 @@ public class A2dpService extends ProfileService {
         return true;
     }
 
-    boolean disconnect(BluetoothDevice device) {
+    // MStar Android Patch Begin
+    public boolean disconnect(BluetoothDevice device) {
         enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
                                        "Need BLUETOOTH ADMIN permission");
         int connectionState = mStateMachine.getConnectionState(device);
@@ -161,16 +162,22 @@ public class A2dpService extends ProfileService {
         mStateMachine.sendMessage(A2dpStateMachine.DISCONNECT, device);
         return true;
     }
+    // MStar Android Patch End
 
     public List<BluetoothDevice> getConnectedDevices() {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        // MStar Android Patch Begin
+        if (mStateMachine == null) return new ArrayList<BluetoothDevice>(0);
+        // MStar Android Patch End
         return mStateMachine.getConnectedDevices();
     }
 
-    List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
+    // MStar Android Patch Begin
+    public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
         return mStateMachine.getDevicesMatchingConnectionStates(states);
     }
+    // MStar Android Patch End
 
     int getConnectionState(BluetoothDevice device) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
@@ -258,6 +265,13 @@ public class A2dpService extends ProfileService {
             return service.disconnect(device);
         }
 
+        // MStar Android Patch Begin
+        // broadcom patch
+        public boolean selectStream(BluetoothDevice device) {
+            return true;
+        }
+        // MStar Android Patch End
+
         public List<BluetoothDevice> getConnectedDevices() {
             A2dpService service = getService();
             if (service == null) return new ArrayList<BluetoothDevice>(0);
diff --git a/src/com/android/bluetooth/a2dp/A2dpSinkService.java b/src/com/android/bluetooth/a2dp/A2dpSinkService.java
old mode 100644
new mode 100755
index 5dcec73..81718e2
--- a/src/com/android/bluetooth/a2dp/A2dpSinkService.java
+++ b/src/com/android/bluetooth/a2dp/A2dpSinkService.java
@@ -20,6 +20,10 @@ import android.bluetooth.BluetoothAudioConfig;
 import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothProfile;
 import android.bluetooth.IBluetoothA2dpSink;
+// MStar Android Patch Begin
+import android.provider.Settings;
+// MStar Android Patch End
+
 import android.util.Log;
 import com.android.bluetooth.btservice.ProfileService;
 import com.android.bluetooth.Utils;
@@ -53,7 +57,8 @@ public class A2dpSinkService extends ProfileService {
     }
 
     protected boolean stop() {
-        mStateMachine.doQuit();
+        if(mStateMachine != null)
+            mStateMachine.doQuit();
         return true;
     }
 
@@ -115,7 +120,9 @@ public class A2dpSinkService extends ProfileService {
         return true;
     }
 
-    boolean disconnect(BluetoothDevice device) {
+    // MStar Android Patch Begin
+    public boolean disconnect(BluetoothDevice device) {
+    // MStar Android Patch End
         enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
                                        "Need BLUETOOTH ADMIN permission");
         int connectionState = mStateMachine.getConnectionState(device);
@@ -130,10 +137,15 @@ public class A2dpSinkService extends ProfileService {
 
     public List<BluetoothDevice> getConnectedDevices() {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        // MStar Android Patch Begin
+        if (mStateMachine == null) return new ArrayList<BluetoothDevice>(0);
+        // MStar Android Patch End
         return mStateMachine.getConnectedDevices();
     }
 
-    List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
+    // MStar Android Patch Begin
+    public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
+    // MStar Android Patch End
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
         return mStateMachine.getDevicesMatchingConnectionStates(states);
     }
@@ -148,6 +160,27 @@ public class A2dpSinkService extends ProfileService {
         return mStateMachine.getAudioConfig(device);
     }
 
+    // MStar Android Patch Begin
+    public boolean setPriority(BluetoothDevice device, int priority) {
+        enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                       "Need BLUETOOTH_ADMIN permission");
+        Settings.Global.putInt(getContentResolver(),
+            Settings.Global.getBluetoothA2dpSinkPriorityKey(device.getAddress()),
+            priority);
+        if (DBG) Log.d(TAG,"Saved priority " + device + " = " + priority);
+        return true;
+    }
+
+    public int getPriority(BluetoothDevice device) {
+        enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                       "Need BLUETOOTH_ADMIN permission");
+        int priority = Settings.Global.getInt(getContentResolver(),
+            Settings.Global.getBluetoothA2dpSinkPriorityKey(device.getAddress()),
+            BluetoothProfile.PRIORITY_UNDEFINED);
+        return priority;
+    }
+    // MStar Android Patch End
+
     //Binder object: Must be static class or memory leak may occur
     private static class BluetoothA2dpSinkBinder extends IBluetoothA2dpSink.Stub
         implements IProfileServiceBinder {
@@ -209,6 +242,20 @@ public class A2dpSinkService extends ProfileService {
             if (service == null) return null;
             return service.getAudioConfig(device);
         }
+
+        // MStar Android Patch Begin
+        public boolean setPriority(BluetoothDevice device, int priority) {
+            A2dpSinkService service = getService();
+            if (service == null) return false;
+            return service.setPriority(device, priority);
+        }
+
+        public int getPriority(BluetoothDevice device) {
+            A2dpSinkService service = getService();
+            if (service == null) return BluetoothProfile.PRIORITY_UNDEFINED;
+            return service.getPriority(device);
+        }
+        // MStar Android Patch End
     };
 
     @Override
diff --git a/src/com/android/bluetooth/a2dp/A2dpSinkStateMachine.java b/src/com/android/bluetooth/a2dp/A2dpSinkStateMachine.java
old mode 100644
new mode 100755
index d57a0ca..b6e5358
--- a/src/com/android/bluetooth/a2dp/A2dpSinkStateMachine.java
+++ b/src/com/android/bluetooth/a2dp/A2dpSinkStateMachine.java
@@ -60,8 +60,22 @@ import java.util.List;
 import java.util.HashMap;
 import java.util.Set;
 
+// MStar Android Patch Begin
+import android.util.Log;
+import android.bluetooth.BluetoothAudioConfig;
+import android.media.AudioDevicePort;
+import android.media.AudioManager;
+import android.media.AudioPatch;
+import android.media.AudioPort;
+import android.media.AudioPortConfig;
+import android.media.AudioSystem;
+// MStar Android Patch End
+
 final class A2dpSinkStateMachine extends StateMachine {
-    private static final boolean DBG = false;
+    private static final boolean DBG = true;
+    // MStar Android Patch Begin
+    private static final String TAG = "A2dpSinkStateMachine";
+    // MStar Android Patch End
 
     static final int CONNECT = 1;
     static final int DISCONNECT = 2;
@@ -249,7 +263,9 @@ final class A2dpSinkStateMachine extends StateMachine {
                     AdapterService adapterService = AdapterService.getAdapterService();
                     if (adapterService != null) {
                         adapterService.connectOtherProfile(device,
-                                                           AdapterService.PROFILE_CONN_REJECTED);
+                                                           AdapterService.PROFILE_CONN_REJECTED,
+                                                           BluetoothProfile.A2DP_SINK);
+                        // MStar Android Patch End
                     }
                 }
                 break;
@@ -270,8 +286,11 @@ final class A2dpSinkStateMachine extends StateMachine {
                     // the other profile connection should be initiated
                     AdapterService adapterService = AdapterService.getAdapterService();
                     if (adapterService != null) {
+                        // MStar Android Patch Begin
                         adapterService.connectOtherProfile(device,
-                                                           AdapterService.PROFILE_CONN_REJECTED);
+                                                           AdapterService.PROFILE_CONN_REJECTED,
+                                                           BluetoothProfile.A2DP_SINK);
+                        // MStar Android Patch End
                     }
                 }
                 break;
@@ -700,6 +719,12 @@ final class A2dpSinkStateMachine extends StateMachine {
 //FIXME        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
         mContext.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
 
+        Intent intent_rtk = new Intent("android.bluetooth.a2dpsink.profile.action.PLAYING_STATE_CHANGED");
+        intent_rtk.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+        intent_rtk.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
+        intent_rtk.putExtra(BluetoothProfile.EXTRA_STATE, state);
+//FIXME        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        mContext.sendBroadcast(intent_rtk, ProfileService.BLUETOOTH_PERM);
         log("A2DP Playing state : device: " + device + " State:" + prevState + "->" + state);
     }
 
@@ -766,6 +791,12 @@ final class A2dpSinkStateMachine extends StateMachine {
 //FIXME            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
             mContext.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
             log("Connection state " + device + ": " + prevState + "->" + state);
+            Intent intent_rtk = new Intent("android.bluetooth.a2dpsink.profile.action.CONNECTION_STATE_CHANGED");
+            intent_rtk.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
+            intent_rtk.putExtra(BluetoothProfile.EXTRA_STATE, state);
+            intent_rtk.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+//FIXME            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            mContext.sendBroadcast(intent_rtk, ProfileService.BLUETOOTH_PERM);
             mService.notifyProfileConnectionStateChanged(device, BluetoothProfile.A2DP_SINK,
                     state, prevState);
         }
diff --git a/src/com/android/bluetooth/a2dp/A2dpStateMachine.java b/src/com/android/bluetooth/a2dp/A2dpStateMachine.java
index 7ad4a59..85d8100 100755
--- a/src/com/android/bluetooth/a2dp/A2dpStateMachine.java
+++ b/src/com/android/bluetooth/a2dp/A2dpStateMachine.java
@@ -57,6 +57,7 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 
+import android.os.SystemProperties;
 final class A2dpStateMachine extends StateMachine {
     private static final boolean DBG = false;
 
@@ -154,6 +155,7 @@ final class A2dpStateMachine extends StateMachine {
     }
 
     public void cleanup() {
+	SystemProperties.set("bluetooth.a2dp.connection", "0");
         cleanupNative();
     }
 
@@ -239,8 +241,10 @@ final class A2dpStateMachine extends StateMachine {
                     // the other profile connection should be initiated
                     AdapterService adapterService = AdapterService.getAdapterService();
                     if (adapterService != null) {
+                        // MStar Android Patch Begin
                         adapterService.connectOtherProfile(device,
-                                                           AdapterService.PROFILE_CONN_REJECTED);
+                            AdapterService.PROFILE_CONN_REJECTED, BluetoothProfile.A2DP);
+                        // MStar Android Patch End
                     }
                 }
                 break;
@@ -261,8 +265,10 @@ final class A2dpStateMachine extends StateMachine {
                     // the other profile connection should be initiated
                     AdapterService adapterService = AdapterService.getAdapterService();
                     if (adapterService != null) {
+                        // MStar Android Patch Begin
                         adapterService.connectOtherProfile(device,
-                                                           AdapterService.PROFILE_CONN_REJECTED);
+                            AdapterService.PROFILE_CONN_REJECTED, BluetoothProfile.A2DP);
+                        // MStar Android Patch End
                     }
                 }
                 break;
diff --git a/src/com/android/bluetooth/btservice/AdapterApp.java b/src/com/android/bluetooth/btservice/AdapterApp.java
old mode 100644
new mode 100755
index b7b988a..8be9eb3
--- a/src/com/android/bluetooth/btservice/AdapterApp.java
+++ b/src/com/android/bluetooth/btservice/AdapterApp.java
@@ -20,6 +20,10 @@
 
 package com.android.bluetooth.btservice;
 
+// MStar Android Patch Begin
+import com.broadcom.bt.service.ProfileConfig;
+// MStar Android Patch End
+
 import android.app.Application;
 import android.util.Log;
 
@@ -48,7 +52,10 @@ public class AdapterApp extends Application {
     public void onCreate() {
         super.onCreate();
         if (DBG) Log.d(TAG, "onCreate");
-        Config.init(this);
+        // MStar Android Patch Begin
+        //Config.init(this);
+        ProfileConfig.init(this);
+        // MStar Android Patch End
     }
 
     @Override
diff --git a/src/com/android/bluetooth/btservice/AdapterProperties.java b/src/com/android/bluetooth/btservice/AdapterProperties.java
old mode 100644
new mode 100755
index 242e271..6582a40
--- a/src/com/android/bluetooth/btservice/AdapterProperties.java
+++ b/src/com/android/bluetooth/btservice/AdapterProperties.java
@@ -373,7 +373,7 @@ class AdapterProperties {
                         convertToAdapterState(state));
                 intent.putExtra(BluetoothAdapter.EXTRA_PREVIOUS_CONNECTION_STATE,
                         convertToAdapterState(prevState));
-                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+                //intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                 mService.sendBroadcastAsUser(intent, UserHandle.ALL,
                         mService.BLUETOOTH_PERM);
                 Log.d(TAG, "CONNECTION_STATE_CHANGE: " + device + ": "
diff --git a/src/com/android/bluetooth/btservice/AdapterService.java b/src/com/android/bluetooth/btservice/AdapterService.java
old mode 100644
new mode 100755
index a26b515..a612889
--- a/src/com/android/bluetooth/btservice/AdapterService.java
+++ b/src/com/android/bluetooth/btservice/AdapterService.java
@@ -62,9 +62,21 @@ import com.android.bluetooth.hfp.HeadsetService;
 import com.android.bluetooth.hdp.HealthService;
 import com.android.bluetooth.pan.PanService;
 import com.android.bluetooth.sdp.SdpManager;
+import com.android.bluetooth.rtkbt.RtkbtService;
 import com.android.internal.R;
 import com.android.bluetooth.Utils;
 import com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;
+// MStar Android Patch Begin
+import android.bluetooth.BluetoothOobData;
+import android.bluetooth.BluetoothLeOobData;
+import android.media.AudioManager;
+import android.content.SharedPreferences;
+import android.content.res.Resources;
+import android.preference.PreferenceManager;
+import com.android.bluetooth.a2dp.A2dpSinkService;
+import com.broadcom.bt.service.IProfileStateChangeListener;
+import com.broadcom.bt.service.ProfileConfig;
+// MStar Android Patch End
 
 import java.io.FileDescriptor;
 import java.io.FileWriter;
@@ -87,9 +99,13 @@ public class AdapterService extends Service {
     private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;
     private static final int MIN_OFFLOADED_FILTERS = 10;
     private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;
+    // MStar Android Patch Begin
+    private AudioManager mAudioManager;
+    // MStar Android Patch End
     //For Debugging only
     private static int sRefCount=0;
-
+    private static int mFlagGattService = 0;
+    private static int mFlagRtkbtService = 0;
     private int mStackReportedState;
     private int mTxTimeTotalMs;
     private int mRxTimeTotalMs;
@@ -106,6 +122,12 @@ public class AdapterService extends Service {
     public static final int PROFILE_CONN_CONNECTED  = 1;
     public static final int PROFILE_CONN_REJECTED  = 2;
 
+    // MStar Android Patch Begin
+    public static int DEFAULT_MODE  = 0;
+    public static int HEADSET_MODE  = 1;
+    private Context mContext;
+    // MStar Android Patch End
+
     private static final String ACTION_ALARM_WAKEUP =
         "com.android.bluetooth.btservice.action.ALARM_WAKEUP";
 
@@ -225,6 +247,9 @@ public class AdapterService extends Service {
     private void processInitProfilePriorities (BluetoothDevice device, ParcelUuid[] uuids){
         HidService hidService = HidService.getHidService();
         A2dpService a2dpService = A2dpService.getA2dpService();
+        // MStar Android Patch Begin
+        A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
+        // MStar Android Patch End
         HeadsetService headsetService = HeadsetService.getHeadsetService();
 
         // Set profile priorities only for the profiles discovered on the remote device.
@@ -250,13 +275,23 @@ public class AdapterService extends Service {
             (headsetService.getPriority(device) == BluetoothProfile.PRIORITY_UNDEFINED))){
             headsetService.setPriority(device,BluetoothProfile.PRIORITY_ON);
         }
+        // MStar Android Patch Begin
+        if((a2dpSinkService != null) &&
+            ( BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.AudioSource) ||
+                    BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.AdvAudioDist)) &&
+            (a2dpSinkService.getPriority(device) == BluetoothProfile.PRIORITY_UNDEFINED)){
+            a2dpSinkService.setPriority(device,BluetoothProfile.PRIORITY_ON);
+        }
+        // MStar Android Patch End
     }
 
     private void processProfileStateChanged(BluetoothDevice device, int profileId, int newState, int prevState) {
-        if (((profileId == BluetoothProfile.A2DP) ||(profileId == BluetoothProfile.HEADSET)) &&
+        // MStar Android Patch Begin
+        if (((profileId == BluetoothProfile.A2DP) ||(profileId == BluetoothProfile.HEADSET) ||
+             (profileId == BluetoothProfile.A2DP_SINK)) &&
              (newState == BluetoothProfile.STATE_CONNECTED)){
             debugLog( "Profile connected. Schedule missing profile connection if any");
-            connectOtherProfile(device, PROFILE_CONN_CONNECTED);
+            connectOtherProfile(device, PROFILE_CONN_CONNECTED, profileId);
             setProfileAutoConnectionPriority(device, profileId);
         }
         IBluetooth.Stub binder = mBinder;
@@ -269,6 +304,89 @@ public class AdapterService extends Service {
         }
     }
 
+    // MStar Android Patch Begin
+    // advanced settings/ enable/disable profiles
+    IProfileStateChangeListener mProfileStateChangeListener;
+
+    /**
+     * Register a profile state change listener
+     * @param listener
+     */
+    public void setProfileStateChangeListener(IProfileStateChangeListener listener) {
+        synchronized (mProfileServicesState) {
+            mProfileStateChangeListener = listener;
+        }
+    }
+
+    public void unsetProfileStateChangeListener() {
+        synchronized (mProfileServicesState) {
+            mProfileStateChangeListener=null;
+        }
+    }
+    /**
+     * Returns true if the specified profile is started
+     * @param profileName
+     * @return
+     */
+    public boolean isProfileStarted(String profileName) {
+        synchronized (mProfileServicesState) {
+            Integer profileState = mProfileServicesState.get(profileName);
+            if (profileState == null) {
+                Log.w(TAG,"isProfileEnabled(): profile not found "
+                        + toNonNullString(profileName));
+                return false;
+            }
+            Log.w(TAG,"isProfileEnabled(): profile " + toNonNullString(profileName)
+                    + ", state= " + profileState);
+            return profileState == BluetoothAdapter.STATE_ON;
+        }
+    }
+
+    public static String toNonNullString(String s) {
+        return s == null ? "" : s;
+    }
+
+    /**
+     * Turn on/off a specified profile. Returns true of the request is valid.
+     * @param profileName
+     * @param setEnabled
+     * @return
+     */
+    public boolean setProfileState(String profileName, boolean setEnabled) {
+        synchronized (mProfileServicesState) {
+
+
+            Integer profileState = mProfileServicesState.get(profileName);
+            if (profileState == null) {
+                Log.w(TAG,"setProfileState(): profile not found "
+                        + toNonNullString(profileName));
+                mProfileServicesState.put(profileName,BluetoothAdapter.STATE_OFF);
+                profileState = BluetoothAdapter.STATE_OFF;
+            }
+            if (setEnabled && (profileState != BluetoothAdapter.STATE_OFF) ||
+                !setEnabled &&(profileState !=BluetoothAdapter.STATE_ON)) {
+                Log.w(TAG,"setProfileState(): error setting profile state: "
+                        + toNonNullString(profileName) + " to enabled=" +setEnabled
+                        +" Current state=" + profileState);
+                return false;
+            }
+            //Set the pending state
+            mProfileServicesState.put(profileName,setEnabled?
+                    BluetoothAdapter.STATE_TURNING_ON: BluetoothAdapter.STATE_TURNING_OFF);
+            Intent intent = new Intent();
+            intent.setClassName(this, profileName);
+            intent.putExtra(EXTRA_ACTION,ACTION_SERVICE_STATE_CHANGED);
+            intent.putExtra(BluetoothAdapter.EXTRA_STATE,setEnabled?
+                    BluetoothAdapter.STATE_ON:BluetoothAdapter.STATE_OFF);
+            Log.d(TAG,"setProfileState(): setting profile "
+                    + toNonNullString(profileName) +" to state = " + profileState);
+            startService(intent);
+
+            return true;
+        }
+    }
+    // MStar Android Patch End
+
     public void addProfile(ProfileService profile) {
         synchronized (mProfiles) {
             mProfiles.add(profile);
@@ -301,6 +419,17 @@ public class AdapterService extends Service {
                 mProfileServicesState.put(serviceName,state);
                 doUpdate=true;
             }
+            // MStar Android Patch Begin
+            // advanced settings turn on/off profiles
+            // dispatch event
+            if (mProfileStateChangeListener != null) {
+                Message m = mHandler.obtainMessage(MESSAGE_UPDATE_PROFILE_STATE_LISTENER);
+                m.obj=serviceName;
+                m.arg1 = state;
+                m.arg2 = prevState;
+                mHandler.sendMessage(m);
+            }
+            // MStar Android Patch End
         }
         debugLog("onProfileServiceStateChange() serviceName=" + serviceName
             + ", state=" + state +", doUpdate=" + doUpdate);
@@ -309,6 +438,10 @@ public class AdapterService extends Service {
             return;
         }
 
+        // MStar Android Patch Begin
+        processDeviceModeSwitchProfileServiceState(serviceName,state);
+        // MStar Android Patch End
+
         synchronized (mAdapterStateMachine) {
             isTurningOff = mAdapterStateMachine.isTurningOff();
             isTurningOn = mAdapterStateMachine.isTurningOn();
@@ -323,9 +456,16 @@ public class AdapterService extends Service {
         if (isBleTurningOn) {
             if (serviceName.equals("com.android.bluetooth.gatt.GattService")) {
                 debugLog("GattService is started");
-                mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BLE_STARTED));
-                return;
+                //mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BLE_STARTED));
+                mFlagGattService = 1;
+            }
+            if (serviceName.equals("com.android.bluetooth.rtkbt.RtkbtService")) {
+                debugLog("RtkbtService is started");
+                //mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BLE_STARTED));
+                mFlagRtkbtService = 1;
             }
+            if(mFlagGattService == 1 && mFlagRtkbtService == 1)
+                mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BLE_STARTED));
 
         } else if(isBleTurningOff) {
             if (serviceName.equals("com.android.bluetooth.gatt.GattService")) {
@@ -426,11 +566,19 @@ public class AdapterService extends Service {
 
     void BleOnProcessStart() {
         debugLog("BleOnProcessStart()");
-        Class[] supportedProfileServices = Config.getSupportedProfiles();
-        //Initialize data objects
+        // MStar Android Patch Begin
+        Class[] supportedProfileServices = ProfileConfig.getSupportedProfiles();
         for (int i=0; i < supportedProfileServices.length;i++) {
-            mProfileServicesState.put(supportedProfileServices[i].getName(),BluetoothAdapter.STATE_OFF);
+            String profileName = supportedProfileServices[i].getName();
+            if (ProfileConfig.isProfileConfiguredEnabled(profileName)){
+                if (isProfileStarted(profileName) == false) {
+                    mProfileServicesState.put(profileName, BluetoothAdapter.STATE_OFF);
+                }
+            } else {
+                Log.w(TAG,"processStart(): profile not enabled: "  + profileName);
+            }
         }
+        // MStar Android Patch End
         mRemoteDevices = new RemoteDevices(this);
         mAdapterProperties.init(mRemoteDevices);
 
@@ -449,7 +597,11 @@ public class AdapterService extends Service {
     void startCoreServices()
     {
         debugLog("startCoreServices()");
-        Class[] supportedProfileServices = Config.getSupportedProfiles();
+        // MStar Android Patch Begin
+        Class[] supportedProfileServices = ProfileConfig.getSupportedProfiles();
+
+        checkAndSetDeviceModeProperty();
+        // MStar Android Patch End
 
         //Start profile services
         if (!mProfilesStarted && supportedProfileServices.length >0) {
@@ -461,16 +613,46 @@ public class AdapterService extends Service {
         }
     }
 
+    // MStar Android Patch Begin
+    private void checkAndSetDeviceModeProperty() {
+
+         /* The last set device mode value before BT turn off is retrieved from
+         sharedpreference while BT turning on Set this property before
+         enabling BT AdapterService,JNI layer and BTIF layer use this
+         value as the default device mode*/
+         Context context = getApplicationContext();
+         SharedPreferences settings = PreferenceManager.
+             getDefaultSharedPreferences(context);
+
+         int deviceMode = settings.getInt("DEVICEMODE",-1);
+         mAdapterStateMachine.setDeviceMode(deviceMode);
+         Log.d(TAG,"deviceMode from shared preference   " + deviceMode );
+         if( deviceMode == -1 )
+         {
+             Resources r = context.getResources();
+             boolean isDevicemode = r
+                     .getBoolean(com.android.bluetooth.R.bool.tv_mode);
+             if( isDevicemode )
+                mAdapterStateMachine.setDeviceMode(DEFAULT_MODE);
+             else
+                mAdapterStateMachine.setDeviceMode(HEADSET_MODE);
+         }
+         Log.d(TAG,"AdapterState deviceMode" + deviceMode );
+    }
+    // MStar Android Patch End
+
     void startBluetoothDisable() {
         mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BEGIN_DISABLE));
     }
 
     boolean stopProfileServices() {
-        Class[] supportedProfileServices = Config.getSupportedProfiles();
+        // MStar Android Patch Begin
+        Class[] supportedProfileServices = ProfileConfig.getSupportedProfiles();
         if (mProfilesStarted && supportedProfileServices.length>0) {
             setProfileServiceState(supportedProfileServices,BluetoothAdapter.STATE_OFF);
             return true;
         }
+        // MStar Android Patch End
         debugLog("stopProfileServices() - No profiles services to stop or already stopped.");
         return false;
     }
@@ -478,7 +660,9 @@ public class AdapterService extends Service {
     boolean stopGattProfileService() {
         //TODO: can optimize this instead of looping around all supported profiles
         debugLog("stopGattProfileService()");
-        Class[] supportedProfileServices = Config.getSupportedProfiles();
+        // MStar Android Patch Begin
+        Class[] supportedProfileServices = ProfileConfig.getSupportedProfiles();
+        // MStar Android Patch End
 
         setGattProfileServiceState(supportedProfileServices,BluetoothAdapter.STATE_OFF);
         return true;
@@ -508,7 +692,8 @@ public class AdapterService extends Service {
         }
 
         mCleaningUp = true;
-
+        mFlagGattService = 0;
+        mFlagRtkbtService = 0;
         unregisterReceiver(mAlarmBroadcastReceiver);
 
         if (mPendingAlarm != null) {
@@ -580,7 +765,13 @@ public class AdapterService extends Service {
     private static final int MESSAGE_PROFILE_CONNECTION_STATE_CHANGED=20;
     private static final int MESSAGE_CONNECT_OTHER_PROFILES = 30;
     private static final int MESSAGE_PROFILE_INIT_PRIORITIES=40;
+    // MStar Android Patch Begin
+    private static final int MESSAGE_SEND_UUID_CHANGED = 50;
+    public static final int MESSAGE_DELAY_FOR_SEND_UUID_CHANGED = 3000;
     private static final int CONNECT_OTHER_PROFILES_TIMEOUT= 6000;
+    private static final int CONNECT_OTHER_PROFILES_DEVICE_MODE_TIMEOUT= 8000;
+    private static final int MESSAGE_UPDATE_PROFILE_STATE_LISTENER= 10000;
+    // MStar Android Patch End
 
     private final Handler mHandler = new Handler() {
         @Override
@@ -608,11 +799,35 @@ public class AdapterService extends Service {
                             mUuids);
                 }
                     break;
+                // MStar Android Patch Begin
                 case MESSAGE_CONNECT_OTHER_PROFILES: {
                     debugLog( "handleMessage() - MESSAGE_CONNECT_OTHER_PROFILES");
-                    processConnectOtherProfiles((BluetoothDevice) msg.obj,msg.arg1);
+                    processConnectOtherProfiles((BluetoothDevice) msg.obj,msg.arg1, msg.arg2);
                 }
                     break;
+                case MESSAGE_SEND_UUID_CHANGED: {
+                    debugLog( "handleMessage() - MESSAGE_SEND_UUID_CHANGED");
+                    Intent intent = new Intent(BluetoothAdapter.ACTION_UUID_CHANGED);
+                    sendBroadcast(intent, BLUETOOTH_PERM);
+                    // Whenever UUID change happens reinit profile priorities
+                    reInitProfilePriorities();
+                }
+                    break;
+                // advanced settings: profile on/off
+                case MESSAGE_UPDATE_PROFILE_STATE_LISTENER: {
+                    if (DBG) debugLog( "MESSAGE_UPDATE_PROFILE_STATE_LISTENER");
+                    try {
+                        IProfileStateChangeListener listener = mProfileStateChangeListener;
+                        if (listener != null) {
+                            listener.onProfileStateChanged((String)msg.obj,msg.arg1,msg.arg2);
+                        }
+                    } catch (Throwable t) {
+                        Log.e(TAG,
+                                "MESSAGE_UPDATE_PROFILE_STATE_LISTENER: error calling listener",t);
+                    }
+                }
+                    break;
+                // MStar Android Patch Begin
             }
         }
     };
@@ -636,7 +851,7 @@ public class AdapterService extends Service {
             String serviceName = services[i].getName();
             String simpleName = services[i].getSimpleName();
 
-            if (simpleName.equals("GattService")) {
+            if (simpleName.equals("GattService") || simpleName.equals("RtkbtService")) {
                 Integer serviceState = mProfileServicesState.get(serviceName);
 
                 if(serviceState != null && serviceState != expectedCurrentState) {
@@ -655,7 +870,7 @@ public class AdapterService extends Service {
                 intent.putExtra(EXTRA_ACTION,ACTION_SERVICE_STATE_CHANGED);
                 intent.putExtra(BluetoothAdapter.EXTRA_STATE,state);
                 startService(intent);
-                return;
+                //return;
             }
         }
     }
@@ -675,31 +890,42 @@ public class AdapterService extends Service {
             pendingState = BluetoothAdapter.STATE_TURNING_OFF;
         }
 
-        for (int i=0; i <services.length;i++) {
-            String serviceName = services[i].getName();
-            String simpleName = services[i].getSimpleName();
+        // MStar Android Patch Begin
+        synchronized (mProfileServicesState) {
+            for (int i=0; i <services.length;i++) {
+                String serviceName = services[i].getName();
+                String simpleName = services[i].getSimpleName();
 
-            if (simpleName.equals("GattService")) continue;
+                if (simpleName.equals("GattService")) continue;
+                //if (simpleName.equals("RtkbtService")) continue;
 
-            Integer serviceState = mProfileServicesState.get(serviceName);
-            if(serviceState != null && serviceState != expectedCurrentState) {
-                debugLog("setProfileServiceState() - Unable to "
-                    + (state == BluetoothAdapter.STATE_OFF ? "start" : "stop" )
-                    + " service " + serviceName
-                    + ". Invalid state: " + serviceState);
-                continue;
-            }
+                if (ProfileConfig.isProfileConfiguredEnabled(serviceName) == false) {
+                    Log.w(TAG, "Profile supported, But not enabled " + serviceName);
+                    continue;
+                }
 
-            debugLog("setProfileServiceState() - "
-                + (state == BluetoothAdapter.STATE_OFF ? "Stopping" : "Starting")
-                + " service " + serviceName);
 
-            mProfileServicesState.put(serviceName,pendingState);
-            Intent intent = new Intent(this,services[i]);
-            intent.putExtra(EXTRA_ACTION,ACTION_SERVICE_STATE_CHANGED);
-            intent.putExtra(BluetoothAdapter.EXTRA_STATE,state);
-            startService(intent);
+                Integer serviceState = mProfileServicesState.get(serviceName);
+                if(serviceState != null && serviceState != expectedCurrentState) {
+                    debugLog("setProfileServiceState() - Unable to "
+                        + (state == BluetoothAdapter.STATE_OFF ? "start" : "stop" )
+                        + " service " + serviceName
+                        + ". Invalid state: " + serviceState);
+                    continue;
+                }
+
+                debugLog("setProfileServiceState() - "
+                    + (state == BluetoothAdapter.STATE_OFF ? "Stopping" : "Starting")
+                    + " service " + serviceName);
+
+                mProfileServicesState.put(serviceName,pendingState);
+                Intent intent = new Intent(this,services[i]);
+                intent.putExtra(EXTRA_ACTION,ACTION_SERVICE_STATE_CHANGED);
+                intent.putExtra(BluetoothAdapter.EXTRA_STATE,state);
+                startService(intent);
+            }
         }
+        // MStar Android Patch End
     }
 
     private boolean isAvailable() {
@@ -946,6 +1172,21 @@ public class AdapterService extends Service {
             return service.createBond(device, transport);
         }
 
+        // MStar Android Patch Begin
+        // broadcom patch
+        public boolean createBondOutOfBandEx(BluetoothOobData oobData) {
+            return true;
+        }
+
+        public boolean setDeviceOutOfBandDataEx(BluetoothOobData oobData) {
+            return true;
+        }
+
+        public boolean setDeviceLeOutOfBandDataEx(BluetoothLeOobData oobData, boolean send_bond_req) {
+            return true;
+        }
+        // MStar Android Patch End
+
         public boolean cancelBondProcess(BluetoothDevice device) {
             if (!Utils.checkCaller()) {
                 Log.w(TAG, "cancelBondProcess() - Not allowed for non-active user");
@@ -981,6 +1222,13 @@ public class AdapterService extends Service {
             return service.getConnectionState(device);
         }
 
+        // MStar Android Patch Begin
+        // broadcom patch
+        public int getLinkState(BluetoothDevice device) {
+            return 0;
+        }
+        // MStar Android Patch End
+
         public String getRemoteName(BluetoothDevice device) {
             if (!Utils.checkCallerAllowManagedProfiles(mService)) {
                 Log.w(TAG, "getRemoteName() - Not allowed for non-active user");
@@ -1159,6 +1407,14 @@ public class AdapterService extends Service {
             return service.setSimAccessPermission(device, value);
         }
 
+        // MStar Android Patch Begin
+        // broadcom patch
+        public boolean authorizeService(BluetoothDevice device, ParcelUuid ServiceUuid,
+                                           boolean authorize, boolean autoReply) {
+            return true;
+        }
+        // MStar Android Patch End
+
         public void sendConnectionStateChange(BluetoothDevice
                 device, int profile, int state, int prevState) {
             AdapterService service = getService();
@@ -1220,6 +1476,13 @@ public class AdapterService extends Service {
 
         }
 
+        // MStar Android Patch Begin
+        // broadcom patch
+        public int sendVsc(int opcode, byte[] params, int len) {
+            return 0;
+       }
+        // MStar Android Patch End
+
         public void registerCallback(IBluetoothCallback cb) {
             AdapterService service = getService();
             if (service == null) return ;
@@ -1288,6 +1551,25 @@ public class AdapterService extends Service {
              service.onLeServiceUp();
          }
 
+        // MStar Android Patch Begin
+        // broadcom patch
+        public boolean createOutOfBandData() {
+            return true;
+        }
+
+        public boolean createLEOutOfBandData(BluetoothDevice device) {
+            return true;
+        }
+
+        public BluetoothOobData readOutOfBandDataEx() {
+            return null;
+        }
+
+         public BluetoothLeOobData readLeOutOfBandDataEx() {
+            return null;
+        }
+        // MStar Android Patch End
+
          public void onBrEdrDown(){
              AdapterService service = getService();
              if (service == null) return;
@@ -1460,6 +1742,13 @@ public class AdapterService extends Service {
         return true;
     }
 
+    // MStar Android Patch Begin
+    // broadcom patch
+    boolean createBondOutOfBand(BluetoothOobData oobData,boolean createBond){
+        return true;
+    }
+    // MStar Android Patch End
+
       public boolean isQuietModeEnabled() {
           debugLog("isQuetModeEnabled() - Enabled = " + mQuietmode);
           return mQuietmode;
@@ -1509,17 +1798,39 @@ public class AdapterService extends Service {
         }
     }
 
-     public void connectOtherProfile(BluetoothDevice device, int firstProfileStatus){
-        if ((mHandler.hasMessages(MESSAGE_CONNECT_OTHER_PROFILES) == false) &&
-            (isQuietModeEnabled()== false)){
+    public void autoConnectA2dpSink(){
+        A2dpSinkService a2dpServiceSink = A2dpSinkService .getA2dpServiceSink();
+        BluetoothDevice bondedDevices[] = getBondedDevices();
+        if ((bondedDevices == null) ||(a2dpServiceSink == null)) {
+            return;
+        }
+        for (BluetoothDevice device : bondedDevices) {
+            if (a2dpServiceSink.getPriority(device) == BluetoothProfile.PRIORITY_AUTO_CONNECT ){
+                debugLog("autoConnectA2dpSink() - Connecting A2DP Sink with " + device.toString());
+                a2dpServiceSink.connect(device);
+            }
+        }
+    }
+     // MStar Android Patch Begin
+    public void connectOtherProfile(BluetoothDevice device,
+        int firstProfileStatus,int profileId){
+
+        mHandler.removeMessages(MESSAGE_CONNECT_OTHER_PROFILES);
+        if(isQuietModeEnabled()== false){
             Message m = mHandler.obtainMessage(MESSAGE_CONNECT_OTHER_PROFILES);
             m.obj = device;
             m.arg1 = (int)firstProfileStatus;
-            mHandler.sendMessageDelayed(m,CONNECT_OTHER_PROFILES_TIMEOUT);
+            m.arg2 = (int)profileId;
+            if (DEFAULT_MODE == mAdapterStateMachine.getDeviceMode())
+                mHandler.sendMessageDelayed(m,CONNECT_OTHER_PROFILES_TIMEOUT);
+            else
+                mHandler.sendMessageDelayed(m,CONNECT_OTHER_PROFILES_DEVICE_MODE_TIMEOUT);
         }
     }
 
-     private void processConnectOtherProfiles (BluetoothDevice device, int firstProfileStatus){
+    private void processConnectOtherProfiles (BluetoothDevice device,
+                                                 int firstProfileStatus,int profileId ){
+
         if (getState()!= BluetoothAdapter.STATE_ON){
             return;
         }
@@ -1527,30 +1838,288 @@ public class AdapterService extends Service {
         A2dpService a2dpService = A2dpService.getA2dpService();
 
         // if any of the profile service is  null, second profile connection not required
-        if ((hsService == null) ||(a2dpService == null )){
+        if ((hsService == null) || ((a2dpService == null ))){
             return;
         }
-        List<BluetoothDevice> a2dpConnDevList= a2dpService.getConnectedDevices();
-        List<BluetoothDevice> hfConnDevList= hsService.getConnectedDevices();
+        List<BluetoothDevice> a2dpConnDevList= null;
+        List<BluetoothDevice> hfConnDevList = null;
+        if (null != hsService)
+            hfConnDevList= hsService.getConnectedDevices();
+        if (null != a2dpService)
+            a2dpConnDevList = a2dpService.getConnectedDevices();
+
         // Check if the device is in disconnected state and if so return
         // We ned to connect other profile only if one of the profile is still in connected state
         // This is required to avoide a race condition in which profiles would
         // automaticlly connect if the disconnection is initiated within 6 seconds of connection
         //First profile connection being rejected is an exception
-        if((hfConnDevList.isEmpty() && a2dpConnDevList.isEmpty())&&
-            (PROFILE_CONN_CONNECTED  == firstProfileStatus)){
+        if((hfConnDevList.isEmpty() && a2dpConnDevList.isEmpty()) 
+            && (PROFILE_CONN_CONNECTED  == firstProfileStatus)){
             return;
         }
+
         if((hfConnDevList.isEmpty()) &&
             (hsService.getPriority(device) >= BluetoothProfile.PRIORITY_ON)){
             hsService.connect(device);
         }
-        else if((a2dpConnDevList.isEmpty()) &&
+
+        if((a2dpConnDevList.isEmpty()) &&
             (a2dpService.getPriority(device) >= BluetoothProfile.PRIORITY_ON)){
             a2dpService.connect(device);
         }
     }
 
+
+      /**
+       * Return  the switched device mode.
+       * @param
+       * @return current device mode
+       */
+    public int getDeviceMode() {
+        Log.d(TAG,"getDeviceMode  deviceMode "+  mAdapterStateMachine.getDeviceMode());
+        return mAdapterStateMachine.getDeviceMode();
+    }
+
+      /**
+       * Switch the device mode TV mode and Headset Mode. Returns true of the request is valid.
+       * @param devicemode
+       * @return
+       */
+    public boolean setDeviceMode(int deviceMode) {
+        if (getState()!= BluetoothAdapter.STATE_ON){
+            return false;
+        }
+
+        Message msg = mAdapterStateMachine.
+             obtainMessage(AdapterState.USER_DEVICE_MODE_SWITCH);
+        msg.arg1 = deviceMode;
+        mAdapterStateMachine.sendMessage(msg);
+        return true;
+    }
+
+    public boolean setProfileStateForDeviceModeSwitch(int deviceMode, boolean enable) {
+        boolean profileStateSet = false;
+        if (DEFAULT_MODE == deviceMode) {
+            Class[] supportedProfileServices = ProfileConfig.getSupportedProfiles();
+                for (int i=0; i < supportedProfileServices.length;i++) {
+                    String profileName = supportedProfileServices[i].getName();
+                    if (ProfileConfig.isPhoneModeProfile(profileName)){
+                        ProfileConfig.saveProfileSetting(profileName, enable);
+                        setProfileState(profileName, enable);
+                        if (!profileStateSet)
+                            profileStateSet = true;
+                    } else {
+                        Log.w(TAG,"Profile not configured for Device Mode Cfg: "  + profileName);
+                    }
+                }
+        } else if (HEADSET_MODE == deviceMode) {
+            Class[] supportedProfileServices = ProfileConfig.getSupportedProfiles();
+            for (int i=0; i < supportedProfileServices.length;i++) {
+                String profileName = supportedProfileServices[i].getName();
+                if (ProfileConfig.isDeviceModeProfile(profileName)){
+                        ProfileConfig.saveProfileSetting(profileName, enable);
+                        setProfileState(profileName, enable);
+                        if (!profileStateSet)
+                            profileStateSet = true;
+                } else {
+                    Log.w(TAG,"Profile not configured for Device Mode Cfg: "  + profileName);
+                }
+            }
+        }
+        return profileStateSet;
+    }
+
+    public void broadcastDeviceModeSwitchStatus () {
+        Log.d(TAG, "Send broadcastDeviceModeSwitchStatus");
+        sendUUIDChange(0);
+        try {
+            IProfileStateChangeListener listener = mProfileStateChangeListener;
+            if (listener != null) {
+                listener.onDeviceModeSwitchComplete();
+            }
+        } catch (Throwable t) {
+            Log.e(TAG, "onDeviceModeSwitchComplete: error calling listener",t);
+        }
+    }
+
+    public void sendUUIDChange (int delay) {
+        Log.d(TAG, "Send ACTION_UUID_CHANGED message posted");
+        mHandler.sendEmptyMessageDelayed (MESSAGE_SEND_UUID_CHANGED, delay);
+    }
+
+    public void reInitProfilePriorities() {
+        Log.d(TAG,"Initialize All profile priorities after Device Mode Switch");
+        BluetoothDevice bondedDevices[] = getBondedDevices();
+        if(bondedDevices != null) {
+            for (BluetoothDevice device : bondedDevices) {
+                DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);
+                initProfilePriorities(device, deviceProp.getUuids());
+            }
+        }
+    }
+    private void processDeviceModeSwitchProfileServiceState(String serviceName,
+                                                                 int state) {
+        boolean isDeviceModeSwitchTurningOff;
+        boolean isDeviceModeSwitchTurningOn;
+        int pendingDeviceModeState;
+        synchronized (mAdapterStateMachine) {
+            isDeviceModeSwitchTurningOff = mAdapterStateMachine.isDeviceModeSwitchTurningOff();
+            isDeviceModeSwitchTurningOn = mAdapterStateMachine.isDeviceModeSwitchTurningOn();
+            pendingDeviceModeState = mAdapterStateMachine.getPendingDeviceMode();
+        }
+
+        Log.d(TAG, "processDeviceModeSwitchProfileServiceState(): serviceName="
+                + toNonNullString(serviceName) + ", state=" + state
+                + ", DeviceMode isDeviceModeSwitchTurningOff=" + isDeviceModeSwitchTurningOff
+                + ",DeviceMode isDeviceModeSwitchTurningOn=" + isDeviceModeSwitchTurningOn);
+
+        if (isDeviceModeSwitchTurningOff) {
+            //Check if all Device Switch Mode services are stopped if so, do cleanup
+            //if (DBG) Log.d(TAG,"Checking if all Device Switch Mode profiles are stopped...");
+            synchronized (mProfileServicesState) {
+                Iterator<Map.Entry<String,Integer>> i = mProfileServicesState.entrySet().iterator();
+                while (i.hasNext()) {
+                    Map.Entry<String,Integer> entry = i.next();
+                    boolean isDeviceSwitchModeProfile;
+
+                    if (HEADSET_MODE  == pendingDeviceModeState)
+                        isDeviceSwitchModeProfile =
+                                ProfileConfig.isPhoneModeProfile(entry.getKey());
+                    else //if (DEFAULT_MODE == pendingDeviceModeState)
+                        isDeviceSwitchModeProfile =
+                                ProfileConfig.isDeviceModeProfile(entry.getKey());
+
+                    if ((BluetoothAdapter.STATE_OFF != entry.getValue()) &&
+                                     isDeviceSwitchModeProfile) {
+                            Log.d(TAG, "DeviceSwitchModeProfile still running: " +
+                                     entry.getKey());
+                            return;
+                    }
+                }
+            }
+            if (DBG) Log.d(TAG, "All DeviceSwitchModeProfile services stopped...");
+            mAdapterStateMachine.sendMessage
+                (mAdapterStateMachine.obtainMessage(
+                AdapterState.DEVICE_MODE_SWITCH_SERVICES_TURNED_OFF));
+
+        } else if (isDeviceModeSwitchTurningOn) {
+            //Check if all Device Switch Mode services are started if so, update state
+            //if (DBG) Log.d(TAG,"Checking if all Device Switch Mode profiles are running...");
+            synchronized (mProfileServicesState) {
+                Iterator<Map.Entry<String,Integer>> i =
+                        mProfileServicesState.entrySet().iterator();
+                while (i.hasNext()) {
+                    Map.Entry<String,Integer> entry = i.next();
+                    boolean isDeviceSwitchModeProfile;
+
+                    if (HEADSET_MODE  == pendingDeviceModeState)
+                        isDeviceSwitchModeProfile =
+                                ProfileConfig.isDeviceModeProfile(entry.getKey());
+                    else //if (DEFAULT_MODE == PendingDeviceModeState)
+                        isDeviceSwitchModeProfile =
+                                ProfileConfig.isPhoneModeProfile(entry.getKey());
+
+                    if ((BluetoothAdapter.STATE_ON != entry.getValue()) &&
+                                isDeviceSwitchModeProfile) {
+                        Log.d(TAG, "DeviceSwitchModeProfile still not running:" +
+                                entry.getKey());
+                        return;
+                    }
+                }
+            }
+            if (DBG) Log.d(TAG, "All DeviceSwitchModeProfile services started.");
+            mAdapterStateMachine.sendMessage
+                (mAdapterStateMachine.obtainMessage(
+                AdapterState.DEVICE_MODE_SWITCH_SERVICES_TURNED_ON));
+        }
+    }
+
+        /**
+         * device mode change should be attempted only after all the connected profiles are
+         * disconnected.
+         * @param
+         * @return
+         */
+    public synchronized void disconnectDeviceModeProfiles() {
+
+        A2dpService a2dpService = A2dpService.getA2dpService();
+        A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
+        HeadsetService  hsService = HeadsetService.getHeadsetService();
+
+        if ( null != a2dpService) {
+            List<BluetoothDevice> a2dpConnDevList= a2dpService.getConnectedDevices();
+            for(BluetoothDevice device:a2dpConnDevList) {
+              Log.d(TAG,"disconnectDeviceModeProfile() disconnecting a2dp device "
+                      +  device);
+                  a2dpService.disconnect(device);
+            }
+        }
+
+        if ( null != a2dpSinkService) {
+            List<BluetoothDevice> a2dpSinkConnDevList= a2dpSinkService.getConnectedDevices();
+            for(BluetoothDevice device:a2dpSinkConnDevList) {
+                Log.d(TAG,"disconnectDeviceModeProfile() disconnecting a2dp Sink device "
+                       +  device);
+                a2dpSinkService.disconnect(device);
+            }
+        }
+
+        if ( null != hsService) {
+            List<BluetoothDevice> hfConnDevList= hsService.getConnectedDevices();
+            for(BluetoothDevice device:hfConnDevList) {
+                Log.d(TAG,"disconnectDeviceModeProfile() disconnecting Headeset AG "
+                       +  device);
+                hsService.disconnect(device);
+            }
+        }
+    }
+
+    public synchronized boolean  isDeviceModeProfilesDisconnected (){
+
+        mAudioManager = (AudioManager)getApplicationContext().
+                        getSystemService(getApplicationContext().AUDIO_SERVICE);
+        A2dpService a2dpService = A2dpService.getA2dpService();
+        A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
+        HeadsetService hsService = HeadsetService.getHeadsetService();
+
+        if (a2dpService != null) {
+            List<BluetoothDevice> a2dpConnDevList= a2dpService.getDevicesMatchingConnectionStates(
+                   new int[] {BluetoothProfile.STATE_CONNECTED,
+                              BluetoothProfile.STATE_CONNECTING,
+                              BluetoothProfile.STATE_DISCONNECTING});
+            Log.d(TAG,"A2dp isempty = "+ a2dpConnDevList.isEmpty()+ " isBluetoothA2dpOn = "
+                + mAudioManager.isBluetoothA2dpOn());
+            if(!a2dpConnDevList.isEmpty()
+                || mAudioManager.isBluetoothA2dpOn())
+                return false;
+        }
+
+        if (a2dpSinkService != null) {
+            List<BluetoothDevice> a2dpSinkConnDevList= a2dpSinkService.getDevicesMatchingConnectionStates(
+                   new int[] {BluetoothProfile.STATE_CONNECTED,
+                              BluetoothProfile.STATE_CONNECTING,
+                              BluetoothProfile.STATE_DISCONNECTING});
+            Log.d(TAG,"A2dp Sink isempty = "+ a2dpSinkConnDevList.isEmpty()+ " isBluetoothA2dpOn = "
+                 + mAudioManager.isBluetoothA2dpOn());
+            if(!a2dpSinkConnDevList.isEmpty()
+                || mAudioManager.isBluetoothA2dpOn())
+                return false;
+        }
+
+        if (hsService != null){
+            List<BluetoothDevice> hfConnDevList= hsService.getDevicesMatchingConnectionStates(
+                   new int[] {BluetoothProfile.STATE_CONNECTED,
+                              BluetoothProfile.STATE_CONNECTING,
+                              BluetoothProfile.STATE_DISCONNECTING});
+            Log.d(TAG,"HS isempty = "+ hfConnDevList.isEmpty());
+
+            if(!hfConnDevList.isEmpty())
+                return false;
+        }
+
+        return true;
+    }
+
      private void adjustOtherHeadsetPriorities(HeadsetService  hsService,
                                                     List<BluetoothDevice> connectedDeviceList) {
         for (BluetoothDevice device : getBondedDevices()) {
@@ -1571,24 +2140,45 @@ public class AdapterService extends Service {
          }
      }
 
-     void setProfileAutoConnectionPriority (BluetoothDevice device, int profileId){
-         if (profileId == BluetoothProfile.HEADSET) {
-             HeadsetService  hsService = HeadsetService.getHeadsetService();
-             List<BluetoothDevice> deviceList = hsService.getConnectedDevices();
-             if ((hsService != null) &&
-                (BluetoothProfile.PRIORITY_AUTO_CONNECT != hsService.getPriority(device))){
-                 adjustOtherHeadsetPriorities(hsService, deviceList);
-                 hsService.setPriority(device,BluetoothProfile.PRIORITY_AUTO_CONNECT);
-             }
-         }
-         else if (profileId ==  BluetoothProfile.A2DP) {
-             A2dpService a2dpService = A2dpService.getA2dpService();
-             if ((a2dpService != null) &&
-                (BluetoothProfile.PRIORITY_AUTO_CONNECT != a2dpService.getPriority(device))){
-                 adjustOtherSinkPriorities(a2dpService, device);
-                 a2dpService.setPriority(device,BluetoothProfile.PRIORITY_AUTO_CONNECT);
-             }
-         }
+    private void adjustOtherSourcePriorities(A2dpSinkService a2dpSinkService,
+                                                   BluetoothDevice connectedDevice) {
+        for (BluetoothDevice device : getBondedDevices()) {
+            if (a2dpSinkService.getPriority(device) >= BluetoothProfile.PRIORITY_AUTO_CONNECT &&
+                !device.equals(connectedDevice)) {
+                a2dpSinkService.setPriority(device, BluetoothProfile.PRIORITY_ON);
+            }
+        }
+    }
+    // MStar Android Patch End
+
+    void setProfileAutoConnectionPriority (BluetoothDevice device, int profileId){
+        if (profileId == BluetoothProfile.HEADSET) {
+            HeadsetService  hsService = HeadsetService.getHeadsetService();
+            List<BluetoothDevice> deviceList = hsService.getConnectedDevices();
+            if ((hsService != null) &&
+               (BluetoothProfile.PRIORITY_AUTO_CONNECT != hsService.getPriority(device))){
+                adjustOtherHeadsetPriorities(hsService, deviceList);
+                hsService.setPriority(device,BluetoothProfile.PRIORITY_AUTO_CONNECT);
+            }
+        }
+        else if (profileId ==  BluetoothProfile.A2DP) {
+            A2dpService a2dpService = A2dpService.getA2dpService();
+            if ((a2dpService != null) &&
+               (BluetoothProfile.PRIORITY_AUTO_CONNECT != a2dpService.getPriority(device))){
+                adjustOtherSinkPriorities(a2dpService, device);
+                a2dpService.setPriority(device,BluetoothProfile.PRIORITY_AUTO_CONNECT);
+            }
+        }
+        // MStar Android Patch Begin
+        else if (profileId ==  BluetoothProfile.A2DP_SINK) {
+            A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
+            if ((a2dpSinkService != null) &&
+               (BluetoothProfile.PRIORITY_AUTO_CONNECT != a2dpSinkService.getPriority(device))){
+                adjustOtherSourcePriorities(a2dpSinkService, device);
+                a2dpSinkService.setPriority(device,BluetoothProfile.PRIORITY_AUTO_CONNECT);
+            }
+        }
+        // MStar Android Patch End
     }
 
      boolean cancelBondProcess(BluetoothDevice device) {
diff --git a/src/com/android/bluetooth/btservice/AdapterState.java b/src/com/android/bluetooth/btservice/AdapterState.java
old mode 100644
new mode 100755
index 555e175..8f265a6
--- a/src/com/android/bluetooth/btservice/AdapterState.java
+++ b/src/com/android/bluetooth/btservice/AdapterState.java
@@ -24,6 +24,16 @@ import android.util.Log;
 
 import com.android.internal.util.State;
 import com.android.internal.util.StateMachine;
+// MStar Android Patch Begin
+import android.bluetooth.BluetoothDevice;
+import java.util.Arrays;
+import android.content.SharedPreferences;
+import android.content.res.Resources;
+import com.android.bluetooth.Utils;
+import android.preference.PreferenceManager;
+import com.broadcom.bt.settings.BluetoothAdvancedSettings;
+import com.broadcom.bt.settings.HeaderAdapter.HeaderViewHolder;
+// MStar Android Patch End
 
 /**
  * This state machine handles Bluetooth Adapter State.
@@ -65,6 +75,18 @@ final class AdapterState extends StateMachine {
 
     static final int USER_TURN_OFF_DELAY_MS=500;
 
+    // MStar Android Patch Begin
+    static final int USER_DEVICE_MODE_SWITCH = 300;
+    static final int DEVICE_MODE_DISCONNECT_PROFILES = 301;
+    static final int DEVICE_MODE_CHECK_DISCONNECTED_PROFILES = 302;
+    static final int DEVICE_MODE_SWITCH_SERVICES_TURN_OFF = 303;
+    static final int DEVICE_MODE_SWITCH_SERVICES_TURN_ON = 304;
+    static final int DEVICE_MODE_SWITCH_SERVICES_TURNED_OFF = 305;
+    static final int DEVICE_MODE_SWITCH_SERVICES_TURNED_ON = 306;
+
+    static final int DEVICE_MODE_SWITCH_DISCONNECT_CHECK_MAX = 10;
+    // MStar Android Patch End
+
     //TODO: tune me
     private static final int ENABLE_TIMEOUT_DELAY = 12000;
     private static final int DISABLE_TIMEOUT_DELAY = 8000;
@@ -82,6 +104,40 @@ final class AdapterState extends StateMachine {
     private OffState mOffState = new OffState();
     private BleOnState mBleOnState = new BleOnState();
 
+    // MStar Android Patch Begin
+    private int mDeviceMode = -1;
+    private int mPendingDeviceModeState = -1;
+    private int mPrevState = BluetoothAdapter.STATE_OFF;
+    public synchronized int getDeviceMode()
+    {
+        return mDeviceMode;
+    }
+
+    public synchronized void setDeviceMode(int devicemode)
+    {
+        mDeviceMode =devicemode;
+    }
+
+    public synchronized int getPendingDeviceMode()
+    {
+        return mPendingDeviceModeState;
+    }
+
+    public synchronized boolean isDeviceModeSwitchTurningOn() {
+        boolean isDeviceModeSwitchTurningOn=  mPendingCommandState.isDeviceModeSwitchTurningOn();
+        if (VDBG) Log.d(TAG,"isDeviceModeSwitchTurningOn()="+
+            isDeviceModeSwitchTurningOn);
+        return isDeviceModeSwitchTurningOn;
+    }
+
+    public synchronized boolean isDeviceModeSwitchTurningOff() {
+        boolean isDeviceModeSwitchTurningOff= mPendingCommandState.isDeviceModeSwitchTurningOff();
+        if (VDBG) Log.d(TAG,"isDeviceModeSwitchTurningOff()="
+            + isDeviceModeSwitchTurningOff);
+        return isDeviceModeSwitchTurningOff;
+    }
+    // MStar Android Patch End
+
     public boolean isTurningOn() {
         boolean isTurningOn=  mPendingCommandState.isTurningOn();
         verboseLog("isTurningOn()=" + isTurningOn);
@@ -231,7 +287,12 @@ final class AdapterState extends StateMachine {
                 errorLog("Entered OnState after cleanup");
                 return;
             }
-            adapterService.autoConnect();
+            // MStar Android Patch Begin
+            // Only autoconnect when BT is turned ON but not after device mode switch
+            if (mPrevState == BluetoothAdapter.STATE_TURNING_ON)
+                adapterService.autoConnect();
+            adapterService.autoConnectA2dpSink();
+            // MStar Android Patch End
         }
 
         @Override
@@ -260,6 +321,20 @@ final class AdapterState extends StateMachine {
                case USER_TURN_ON:
                    break;
 
+               // MStar Android Patch Begin
+               case USER_DEVICE_MODE_SWITCH:
+                    // Start the device mode switching in Pending mode
+                   if (DBG) Log.d(TAG,"CURRENT_STATE=ON, MSG = USER_DEVICE_MODE_SWITCH");
+                   if (mPendingDeviceModeState != -1) {
+                       Log.d(TAG,"Error in setting USER_DEVICE_MODE_SWITCH");
+                       return false;
+                   }
+                   mPendingDeviceModeState = msg.arg1;
+                   transitionTo(mPendingCommandState);
+                   sendMessage(DEVICE_MODE_DISCONNECT_PROFILES);
+                   break;
+                // MStar Android Patch End
+
                default:
                    return false;
             }
@@ -272,6 +347,11 @@ final class AdapterState extends StateMachine {
         private boolean mIsTurningOff;
         private boolean mIsBleTurningOn;
         private boolean mIsBleTurningOff;
+        // MStar Android Patch Begin
+        private boolean mIsDeviceModeSwitchTurningOn = false;
+        private boolean mIsDeviceModeSwitchTurningOff = false;
+        private int mDisconnectCheckCount = 0;
+        // MStar Android Patch End
 
         public void enter() {
             infoLog("Entering PendingCommandState");
@@ -309,6 +389,24 @@ final class AdapterState extends StateMachine {
             return mIsBleTurningOff;
         }
 
+        // MStar Android Patch Begin
+        public void setDeviceModeSwitchTurningOn(boolean isTurningOn) {
+            mIsDeviceModeSwitchTurningOn = isTurningOn;
+        }
+
+        public boolean isDeviceModeSwitchTurningOn() {
+            return mIsDeviceModeSwitchTurningOn;
+        }
+
+        public void setDeviceModeSwitchTurningOff(boolean isTurningOff) {
+            mIsDeviceModeSwitchTurningOff = isTurningOff;
+        }
+
+        public boolean isDeviceModeSwitchTurningOff() {
+            return mIsDeviceModeSwitchTurningOff;
+        }
+        // MStar Android Patch End
+
         @Override
         public boolean processMessage(Message msg) {
 
@@ -316,6 +414,9 @@ final class AdapterState extends StateMachine {
             boolean isTurningOff = isTurningOff();
             boolean isBleTurningOn = isBleTurningOn();
             boolean isBleTurningOff = isBleTurningOff();
+            // MStar Android Patch Begin
+            mPrevState = mAdapterProperties.getState();
+            // MStar Android Patch End
 
             AdapterService adapterService = mAdapterService;
             AdapterProperties adapterProperties = mAdapterProperties;
@@ -472,8 +573,112 @@ final class AdapterState extends StateMachine {
                     notifyAdapterStateChange(BluetoothAdapter.STATE_OFF);
                     break;
 
+                // MStar Android Patch Begin
+                case DEVICE_MODE_DISCONNECT_PROFILES:
+                    Log.d(TAG,"DEVICE_MODE_DISCONNECT_PROFILES");
+                    mDisconnectCheckCount = 0;
+                    mAdapterService.disconnectDeviceModeProfiles();
+                    sendMessageDelayed(
+                        DEVICE_MODE_CHECK_DISCONNECTED_PROFILES, 500);
+                    break;
+
+                case DEVICE_MODE_CHECK_DISCONNECTED_PROFILES:
+                    boolean isDisconnected =
+                            mAdapterService.isDeviceModeProfilesDisconnected();
+                    Log.d(TAG,"DEVICE_MODE_CHECK_DISCONNECTED_PROFILES isDisconnected="+
+                                isDisconnected+"mDisconnectCheckCount="+mDisconnectCheckCount);
+                    mDisconnectCheckCount++;
+                    if (!isDisconnected &&
+                            (mDisconnectCheckCount < DEVICE_MODE_SWITCH_DISCONNECT_CHECK_MAX)) {
+                        Log.d(TAG,"Device mode profile still not disconnected");
+                        mAdapterService.disconnectDeviceModeProfiles();
+                        sendMessageDelayed
+                            (DEVICE_MODE_CHECK_DISCONNECTED_PROFILES, 500);
+                    } else {
+                        mPendingCommandState.setDeviceModeSwitchTurningOff(true);
+                        sendMessage(DEVICE_MODE_SWITCH_SERVICES_TURN_OFF);
+                    }
+                    break;
+
+                case DEVICE_MODE_SWITCH_SERVICES_TURN_OFF:
+                    // Initiate turn OFF the currnet Mode(Device/Phone) mode services
+                    Log.d(TAG,"DEVICE_MODE_SWITCH_SERVICES_TURN_OFF "
+                        +"mPendingDeviceModeState="+mPendingDeviceModeState);
+                    if (AdapterService.HEADSET_MODE == mPendingDeviceModeState) {
+                        // Turn off Default mode
+                        if(!mAdapterService.
+                            setProfileStateForDeviceModeSwitch(
+                                AdapterService.DEFAULT_MODE, false)) {
+                            Log.e(TAG, "No services to turn OFF HEADSET_MODE");
+                            sendMessage(DEVICE_MODE_SWITCH_SERVICES_TURNED_OFF);
+                        }
+                    } else if (AdapterService.DEFAULT_MODE == mPendingDeviceModeState) {
+                        // Turn off Headset mode
+                        if(!mAdapterService.
+                            setProfileStateForDeviceModeSwitch(
+                                AdapterService.HEADSET_MODE, false)) {
+                            Log.e(TAG, "No services to turn OFF DEFAULT_MODE");
+                            sendMessage(DEVICE_MODE_SWITCH_SERVICES_TURNED_OFF);
+                        }
+                    }
+                    mIsDeviceModeSwitchTurningOff = true;
+                    break;
+
+                case DEVICE_MODE_SWITCH_SERVICES_TURNED_OFF:
+                    // Adapter service notifies after the service turned off
+                    // Also continue now initiate turn ON the services for the new Mode(Device/Phone)
+                    Log.d(TAG,"DEVICE_MODE_SWITCH_SERVICES_TURNED_OFF  "
+                        +"mPendingDeviceModeState="+mPendingDeviceModeState);
+                    mIsDeviceModeSwitchTurningOff = false;
+                    //fallthrough.Now turn on the service required for Device mode switch
+                case DEVICE_MODE_SWITCH_SERVICES_TURN_ON:
+                    Log.d(TAG,"DEVICE_MODE_SWITCH_SERVICES_TURN_ON "
+                        +"mPendingDeviceModeState="+mPendingDeviceModeState);
+                    mDeviceMode = mPendingDeviceModeState;
+
+                    if (AdapterService.HEADSET_MODE == mPendingDeviceModeState) {
+                        // Turn ON Headset mode services
+                        if(!mAdapterService.
+                            setProfileStateForDeviceModeSwitch(
+                                AdapterService.HEADSET_MODE, true)) {
+                            Log.e(TAG, "No services to turn OFF DEFAULT_MODE");
+                            sendMessage(DEVICE_MODE_SWITCH_SERVICES_TURN_ON);
+                        }
+                    } else if (AdapterService.DEFAULT_MODE == mPendingDeviceModeState) {
+                        // Turn ON Default mode services
+                        if(!mAdapterService.
+                            setProfileStateForDeviceModeSwitch(
+                                AdapterService.DEFAULT_MODE, true)) {
+                            Log.e(TAG, "No services to turn OFF DEFAULT_MODE");
+                            sendMessage(DEVICE_MODE_SWITCH_SERVICES_TURN_ON);
+                        }
+                    }
+                    mIsDeviceModeSwitchTurningOn = true;
+                    break;
+
+                case DEVICE_MODE_SWITCH_SERVICES_TURNED_ON:
+                    // Adapter service notifies after the service turned ON
+                    // Now restore from  pending state to Previous ON state
+                    Log.d(TAG,"DEVICE_MODE_SWITCH_SERVICES_TURNED_ON  "
+                        +"mPendingDeviceModeState="+mPendingDeviceModeState);
+                    mPendingDeviceModeState = -1;
+                    mIsDeviceModeSwitchTurningOn = false;
+                    mAdapterService.broadcastDeviceModeSwitchStatus();
+                    int adapterState = mAdapterService.getState();
+                    if (adapterState == BluetoothAdapter.STATE_ON)
+                        transitionTo(mOnState);
+                    else if (adapterState == BluetoothAdapter.STATE_BLE_ON)
+                        transitionTo(mBleOnState);
+                    else
+                        transitionTo(mOffState);
+
+                    break;
+
                 default:
+                    if (DBG) Log.d(TAG,"ERROR:UNEXPECTED MSG:CURRENT_STATE=PENDING,MSG = " +
+                                   msg.what);
                     return false;
+                // MStar Android Patch End
             }
             return true;
         }
diff --git a/src/com/android/bluetooth/btservice/BondStateMachine.java b/src/com/android/bluetooth/btservice/BondStateMachine.java
old mode 100644
new mode 100755
index 7bed94a..26d01b8
--- a/src/com/android/bluetooth/btservice/BondStateMachine.java
+++ b/src/com/android/bluetooth/btservice/BondStateMachine.java
@@ -23,6 +23,9 @@ import android.bluetooth.BluetoothDevice;
 import com.android.bluetooth.a2dp.A2dpService;
 import com.android.bluetooth.hid.HidService;
 import com.android.bluetooth.hfp.HeadsetService;
+// MStar Android Patch Begin
+import com.android.bluetooth.a2dp.A2dpSinkService;
+// MStar Android Patch End
 import android.content.Context;
 import android.content.Intent;
 import android.os.Message;
@@ -434,6 +437,9 @@ final class BondStateMachine extends StateMachine {
         HidService hidService = HidService.getHidService();
         A2dpService a2dpService = A2dpService.getA2dpService();
         HeadsetService headsetService = HeadsetService.getHeadsetService();
+        // MStar Android Patch Begin
+        A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
+        // MStar Android Patch End
 
         if ((hidService != null) &&
             (hidService.getPriority(device) == BluetoothProfile.PRIORITY_UNDEFINED)){
@@ -445,6 +451,13 @@ final class BondStateMachine extends StateMachine {
             a2dpService.setPriority(device,BluetoothProfile.PRIORITY_ON);
         }
 
+        // MStar Android Patch Begin
+        if ((a2dpSinkService != null) &&
+            (a2dpSinkService.getPriority(device) == BluetoothProfile.PRIORITY_UNDEFINED)){
+            a2dpSinkService.setPriority(device,BluetoothProfile.PRIORITY_ON);
+        }
+        // MStar Android Patch End
+
         if ((headsetService != null) &&
             (headsetService.getPriority(device) == BluetoothProfile.PRIORITY_UNDEFINED)){
             headsetService.setPriority(device,BluetoothProfile.PRIORITY_ON);
@@ -455,6 +468,9 @@ final class BondStateMachine extends StateMachine {
         HidService hidService = HidService.getHidService();
         A2dpService a2dpService = A2dpService.getA2dpService();
         HeadsetService headsetService = HeadsetService.getHeadsetService();
+        // MStar Android Patch Begin
+        A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
+        // MStar Android Patch End
 
         if (hidService != null)
             hidService.setPriority(device,BluetoothProfile.PRIORITY_UNDEFINED);
@@ -462,6 +478,10 @@ final class BondStateMachine extends StateMachine {
             a2dpService.setPriority(device,BluetoothProfile.PRIORITY_UNDEFINED);
         if(headsetService != null)
             headsetService.setPriority(device,BluetoothProfile.PRIORITY_UNDEFINED);
+        // MStar Android Patch Begin
+        if(a2dpSinkService != null)
+            a2dpSinkService.setPriority(device,BluetoothProfile.PRIORITY_UNDEFINED);
+        // MStar Android Patch End
     }
 
     private void infoLog(String msg) {
diff --git a/src/com/android/bluetooth/btservice/Config.java b/src/com/android/bluetooth/btservice/Config.java
old mode 100644
new mode 100755
index 4301cd9..3f2c7b6
--- a/src/com/android/bluetooth/btservice/Config.java
+++ b/src/com/android/bluetooth/btservice/Config.java
@@ -35,7 +35,7 @@ import com.android.bluetooth.pan.PanService;
 import com.android.bluetooth.gatt.GattService;
 import com.android.bluetooth.map.BluetoothMapService;
 import com.android.bluetooth.sap.SapService;
-
+import com.android.bluetooth.rtkbt.RtkbtService;
 public class Config {
     private static final String TAG = "AdapterServiceConfig";
     /**
@@ -45,6 +45,7 @@ public class Config {
     //Do not inclue OPP and PBAP, because their services
     //are not managed by AdapterService
     private static final Class[] PROFILE_SERVICES = {
+        RtkbtService.class,
         HeadsetService.class,
         A2dpService.class,
         A2dpSinkService.class,
@@ -61,6 +62,7 @@ public class Config {
      * Resource flag to indicate whether profile is supported or not.
      */
     private static final int[]  PROFILE_SERVICES_FLAG = {
+        R.bool.profile_supported_rtkbt,
         R.bool.profile_supported_hs_hfp,
         R.bool.profile_supported_a2dp,
         R.bool.profile_supported_a2dp_sink,
diff --git a/src/com/android/bluetooth/hfp/HeadsetService.java b/src/com/android/bluetooth/hfp/HeadsetService.java
index f6153cb..ae4f23e 100755
--- a/src/com/android/bluetooth/hfp/HeadsetService.java
+++ b/src/com/android/bluetooth/hfp/HeadsetService.java
@@ -290,6 +290,13 @@ public class HeadsetService extends ProfileService {
             if (service == null) return false;
             return service.disableWBS();
         }
+
+        // MStar Android Patch Begin
+        // broadcom patch
+        public void bindResponse(int ind_id, int ind_status) {
+
+        }
+        // MStar Android Patch End
     };
 
     //API methods
@@ -345,8 +352,9 @@ public class HeadsetService extends ProfileService {
         mStateMachine.sendMessage(HeadsetStateMachine.CONNECT, device);
         return true;
     }
-
-    boolean disconnect(BluetoothDevice device) {
+    // MStar Android Patch Begin
+    public boolean disconnect(BluetoothDevice device) {
+    // MStar Android Patch End
         enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
                                        "Need BLUETOOTH ADMIN permission");
         int connectionState = mStateMachine.getConnectionState(device);
@@ -361,11 +369,15 @@ public class HeadsetService extends ProfileService {
 
     public List<BluetoothDevice> getConnectedDevices() {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        // MStar Android Patch Begin
+        if (mStateMachine == null) return new ArrayList<BluetoothDevice>(0);
+        // MStar Android Patch End
         return mStateMachine.getConnectedDevices();
     }
-
-    private List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
-        enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+    // MStar Android Patch Begin
+    public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
+    // MStar Android Patch End
+		enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
         return mStateMachine.getDevicesMatchingConnectionStates(states);
     }
 
diff --git a/src/com/android/bluetooth/hfp/HeadsetStateMachine.java b/src/com/android/bluetooth/hfp/HeadsetStateMachine.java
old mode 100644
new mode 100755
index d226e7c..2fa4411
--- a/src/com/android/bluetooth/hfp/HeadsetStateMachine.java
+++ b/src/com/android/bluetooth/hfp/HeadsetStateMachine.java
@@ -419,8 +419,10 @@ final class HeadsetStateMachine extends StateMachine {
                     // the other profile connection should be initiated
                     AdapterService adapterService = AdapterService.getAdapterService();
                     if (adapterService != null) {
+                        // MStar Android Patch Begin
                         adapterService.connectOtherProfile(device,
-                                                           AdapterService.PROFILE_CONN_REJECTED);
+                            AdapterService.PROFILE_CONN_REJECTED, BluetoothProfile.HEADSET);
+                        // MStar Android Patch End
                     }
                 }
                 break;
@@ -448,8 +450,10 @@ final class HeadsetStateMachine extends StateMachine {
                     // the other profile connection should be initiated
                     AdapterService adapterService = AdapterService.getAdapterService();
                     if (adapterService != null) {
+                        // MStar Android Patch Begin
                         adapterService.connectOtherProfile(device,
-                                                           AdapterService.PROFILE_CONN_REJECTED);
+                            AdapterService.PROFILE_CONN_REJECTED, BluetoothProfile.HEADSET);
+                        // MStar Android Patch End
                     }
                 }
                 break;
@@ -670,7 +674,7 @@ final class HeadsetStateMachine extends StateMachine {
                             AdapterService adapterService = AdapterService.getAdapterService();
                             if (adapterService != null) {
                                 adapterService.connectOtherProfile(device,
-                                         AdapterService.PROFILE_CONN_REJECTED);
+                                         AdapterService.PROFILE_CONN_REJECTED, BluetoothProfile.HEADSET);
                             }
                         }
                     }
@@ -1070,7 +1074,7 @@ final class HeadsetStateMachine extends StateMachine {
                         AdapterService adapterService = AdapterService.getAdapterService();
                         if (adapterService != null) {
                             adapterService.connectOtherProfile(device,
-                                                        AdapterService.PROFILE_CONN_REJECTED);
+                                                        AdapterService.PROFILE_CONN_REJECTED, BluetoothProfile.HEADSET);
                         }
                     }
                     break;
@@ -1504,7 +1508,7 @@ final class HeadsetStateMachine extends StateMachine {
                          AdapterService adapterService = AdapterService.getAdapterService();
                          if (adapterService != null) {
                              adapterService.connectOtherProfile(device,
-                                             AdapterService.PROFILE_CONN_REJECTED);
+                                             AdapterService.PROFILE_CONN_REJECTED, BluetoothProfile.HEADSET);
                          }
                     }
                     break;
@@ -1922,7 +1926,7 @@ final class HeadsetStateMachine extends StateMachine {
                         AdapterService adapterService = AdapterService.getAdapterService();
                         if (adapterService != null) {
                             adapterService.connectOtherProfile(device,
-                                          AdapterService.PROFILE_CONN_REJECTED);
+                                          AdapterService.PROFILE_CONN_REJECTED, BluetoothProfile.HEADSET);
                         }
                     }
                 }
@@ -3142,11 +3146,14 @@ final class HeadsetStateMachine extends StateMachine {
     }
 
     private void onVolumeChanged(int type, int volume, byte[] address) {
+	
+	/*
         StackEvent event = new StackEvent(EVENT_TYPE_VOLUME_CHANGED);
         event.valueInt = type;
         event.valueInt2 = volume;
         event.device = getDevice(address);
         sendMessage(STACK_EVENT, event);
+	*/
     }
 
     private void onDialCall(String number, byte[] address) {
diff --git a/src/com/android/bluetooth/hfpclient/HeadsetClientStateMachine.java b/src/com/android/bluetooth/hfpclient/HeadsetClientStateMachine.java
old mode 100644
new mode 100755
index 7ff8fcf..606558e
--- a/src/com/android/bluetooth/hfpclient/HeadsetClientStateMachine.java
+++ b/src/com/android/bluetooth/hfpclient/HeadsetClientStateMachine.java
@@ -1395,8 +1395,11 @@ final class HeadsetClientStateMachine extends StateMachine {
                         // the other profile connection should be initiated
                         AdapterService adapterService = AdapterService.getAdapterService();
                         if (adapterService != null) {
+                            // MStar Android Patch Begin
                             adapterService.connectOtherProfile(device,
-                                    AdapterService.PROFILE_CONN_REJECTED);
+                                    AdapterService.PROFILE_CONN_REJECTED,
+                                    BluetoothProfile.HEADSET_CLIENT);
+                            // MStar Android Patch End
                         }
                     }
                     break;
diff --git a/src/com/android/bluetooth/hid/HidService.java b/src/com/android/bluetooth/hid/HidService.java
index be769fc..74014fe 100755
--- a/src/com/android/bluetooth/hid/HidService.java
+++ b/src/com/android/bluetooth/hid/HidService.java
@@ -21,6 +21,9 @@ import android.bluetooth.BluetoothInputDevice;
 import android.bluetooth.BluetoothProfile;
 import android.bluetooth.IBluetooth;
 import android.bluetooth.IBluetoothInputDevice;
+// MStar Android Patch Begin
+import android.bluetooth.IBluetoothHidHostCallback;
+// MStar Android Patch End
 import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.os.Bundle;
@@ -315,6 +318,19 @@ public class HidService extends ProfileService {
             return null;
         }
 
+        // MStar Android Patch Begin
+        // broadcom patch
+        public boolean registerCallback(IBluetoothHidHostCallback cb)
+                throws RemoteException {
+            return true;
+        }
+
+        public boolean unregisterCallback(IBluetoothHidHostCallback cb)
+                throws RemoteException {
+            return true;
+        }
+        // MStar Android Patch End
+
         public boolean connect(BluetoothDevice device) {
             HidService service = getService();
             if (service == null) return false;
@@ -392,6 +408,17 @@ public class HidService extends ProfileService {
             if (service == null) return false;
             return service.sendData(device, report);
         }
+
+        // MStar Android Patch Begin
+        // broadcom patch
+        public boolean getCurrentFWVersion(BluetoothDevice device) {
+            return true;
+        }
+
+        public boolean updateRCFirmware(BluetoothDevice device, String filepath) {
+            return true;
+        }
+        // MStar Android Patch End
     };
 
     //APIs
diff --git a/src/com/android/bluetooth/map/BluetoothMapContentObserver.java b/src/com/android/bluetooth/map/BluetoothMapContentObserver.java
old mode 100644
new mode 100755
index 08285bf..417be25
--- a/src/com/android/bluetooth/map/BluetoothMapContentObserver.java
+++ b/src/com/android/bluetooth/map/BluetoothMapContentObserver.java
@@ -48,6 +48,7 @@ import android.telephony.SmsManager;
 import android.telephony.SmsMessage;
 import android.telephony.TelephonyManager;
 import android.text.format.DateUtils;
+import android.util.EventLog;
 import android.util.Log;
 import android.util.Xml;
 import android.text.TextUtils;
@@ -3006,7 +3007,23 @@ public class BluetoothMapContentObserver {
                 return;
             }
 
-            if (action.equals(ACTION_MESSAGE_DELIVERY)) {
+            if (action.equals(ACTION_MESSAGE_SENT)) {
+                int result = intent.getIntExtra(EXTRA_MESSAGE_SENT_RESULT,
+                        Activity.RESULT_CANCELED);
+                msgInfo.partsSent++;
+                if(result != Activity.RESULT_OK) {
+                    /* If just one of the parts in the message fails, we need to send the
+                     * entire message again
+                     */
+                    msgInfo.failedSent = true;
+                }
+                if(D) Log.d(TAG, "onReceive: msgInfo.partsSent = " + msgInfo.partsSent
+                        + ", msgInfo.parts = " + msgInfo.parts + " result = " + result);
+
+                if (msgInfo.partsSent == msgInfo.parts) {
+                    actionMessageSent(context, intent, msgInfo);
+                }
+            } else if (action.equals(ACTION_MESSAGE_DELIVERY)) {
                 long timestamp = intent.getLongExtra(EXTRA_MESSAGE_SENT_TIMESTAMP, 0);
                 int status = -1;
                 if(msgInfo.timestamp == timestamp) {
@@ -3033,6 +3050,67 @@ public class BluetoothMapContentObserver {
             }
         }
 
+        private void actionMessageSent(Context context, Intent intent, PushMsgInfo msgInfo) {
+            /* As the MESSAGE_SENT intent is forwarded from the MAP service, we use the intent
+             * to carry the result, as getResult() will not return the correct value.
+             */
+            boolean delete = false;
+
+            if(D) Log.d(TAG,"actionMessageSent(): msgInfo.failedSent = " + msgInfo.failedSent);
+
+            msgInfo.sendInProgress = false;
+
+            if (msgInfo.failedSent == false) {
+                if(D) Log.d(TAG, "actionMessageSent: result OK");
+                if (msgInfo.transparent == 0) {
+                    if (!Sms.moveMessageToFolder(context, msgInfo.uri,
+                            Sms.MESSAGE_TYPE_SENT, 0)) {
+                        Log.w(TAG, "Failed to move " + msgInfo.uri + " to SENT");
+                    }
+                } else {
+                    delete = true;
+                }
+
+                Event evt = new Event(EVENT_TYPE_SENDING_SUCCESS, msgInfo.id,
+                        getSmsFolderName(Sms.MESSAGE_TYPE_SENT), null, mSmsType);
+                sendEvent(evt);
+
+            } else {
+                if (msgInfo.retry == 1) {
+                    /* Notify failure, but keep message in outbox for resending */
+                    msgInfo.resend = true;
+                    msgInfo.partsSent = 0; // Reset counter for the retry
+                    msgInfo.failedSent = false;
+                    Event evt = new Event(EVENT_TYPE_SENDING_FAILURE, msgInfo.id,
+                            getSmsFolderName(Sms.MESSAGE_TYPE_OUTBOX), null, mSmsType);
+                    sendEvent(evt);
+                } else {
+                    if (msgInfo.transparent == 0) {
+                        if (!Sms.moveMessageToFolder(context, msgInfo.uri,
+                                Sms.MESSAGE_TYPE_FAILED, 0)) {
+                            Log.w(TAG, "Failed to move " + msgInfo.uri + " to FAILED");
+                        }
+                    } else {
+                        delete = true;
+                    }
+
+                    Event evt = new Event(EVENT_TYPE_SENDING_FAILURE, msgInfo.id,
+                            getSmsFolderName(Sms.MESSAGE_TYPE_FAILED), null, mSmsType);
+                    sendEvent(evt);
+                }
+            }
+
+            if (delete == true) {
+                /* Delete from Observer message list to avoid delete notifications */
+                synchronized(getMsgListSms()) {
+                    getMsgListSms().remove(msgInfo.id);
+                }
+
+                /* Delete from DB */
+                mResolver.delete(msgInfo.uri, null, null);
+            }
+        }
+
         private void actionMessageDelivery(Context context, Intent intent, PushMsgInfo msgInfo) {
             Uri messageUri = intent.getData();
             msgInfo.sendInProgress = false;
@@ -3150,6 +3228,7 @@ public class BluetoothMapContentObserver {
             (context.checkCallingOrSelfPermission("android.Manifest.permission.WRITE_SMS")
                     != PackageManager.PERMISSION_GRANTED)) {
             Log.w(TAG, "actionSmsSentDisconnected: Not allowed to delete SMS/MMS messages");
+            EventLog.writeEvent(0x534e4554, "b/22343270", Binder.getCallingUid(), "");
             return;
         }
 
diff --git a/src/com/android/bluetooth/opp/BluetoothOppUtility.java b/src/com/android/bluetooth/opp/BluetoothOppUtility.java
old mode 100644
new mode 100755
index ea465f4..7315dc6
--- a/src/com/android/bluetooth/opp/BluetoothOppUtility.java
+++ b/src/com/android/bluetooth/opp/BluetoothOppUtility.java
@@ -301,7 +301,10 @@ public class BluetoothOppUtility {
         values.put(BluetoothShare.URI, transInfo.mFileUri);
         values.put(BluetoothShare.MIMETYPE, transInfo.mFileType);
         values.put(BluetoothShare.DESTINATION, transInfo.mDestAddr);
-
+        //REALTEK ADD START
+        Uri uri = Uri.parse(transInfo.mFileUri);
+        putSendFileInfo(uri, BluetoothOppSendFileInfo.generateFileInfo(context, uri, transInfo.mFileType));
+        //REALTEK ADD END
         final Uri contentUri = context.getContentResolver().insert(BluetoothShare.CONTENT_URI,
                 values);
         if (V) Log.v(TAG, "Insert contentUri: " + contentUri + "  to device: " +
diff --git a/src/com/android/bluetooth/pan/PanService.java b/src/com/android/bluetooth/pan/PanService.java
index ea9b97e..855945f 100755
--- a/src/com/android/bluetooth/pan/PanService.java
+++ b/src/com/android/bluetooth/pan/PanService.java
@@ -268,6 +268,13 @@ public class PanService extends ProfileService {
 
     boolean disconnect(BluetoothDevice device) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        //REALTEK ADD START
+        int connectionState = getConnectionState(device);
+        if (connectionState != BluetoothProfile.STATE_CONNECTED &&connectionState != BluetoothProfile.STATE_CONNECTING)
+        {
+            return false;
+        }
+        //REALTEK ADD END
         Message msg = mHandler.obtainMessage(MESSAGE_DISCONNECT,device);
         mHandler.sendMessage(msg);
         return true;
diff --git a/src/com/android/bluetooth/rtkbt/RtkbtService.java b/src/com/android/bluetooth/rtkbt/RtkbtService.java
new file mode 100755
index 0000000..f1a3b95
--- /dev/null
+++ b/src/com/android/bluetooth/rtkbt/RtkbtService.java
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.*/
+
+
+package com.android.bluetooth.rtkbt;
+
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.IBluetooth;
+import com.android.bluetooth.Utils;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.Handler;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.provider.Settings;
+import android.util.Log;
+import com.android.bluetooth.btservice.AdapterService;
+import com.android.bluetooth.btservice.ProfileService;
+import com.android.bluetooth.Utils;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import android.content.pm.PackageManager;
+
+import android.bluetooth.IBluetoothRtkbt;
+import android.bluetooth.BluetoothRtkbt;
+
+
+/**
+ * Provides Bluetooth Gatt Host profile, as a service in
+ * the Bluetooth application.
+ */
+public class RtkbtService extends ProfileService {
+    private static final boolean DBG = true;
+    private static final String TAG = "RtkbtService";
+
+    private static RtkbtService mRtkbtService;
+    public static final String RTKBT_PROFILE = "RtkbtProfile";
+
+    static {
+        classInitNative();
+    }
+
+    public String getName() {
+        return TAG;
+    }
+
+    public IProfileServiceBinder initBinder() {
+        if (DBG) log("initBinder()");
+        return new BluetoothRtkbtBinder(this);
+    }
+
+    protected boolean start() {
+        log("start RTKBT Service");
+        InitNative();
+        setRtkbtService(this);
+        return true;
+    }
+
+    protected boolean stop() {
+        if (DBG) log("Stopping RTKBT Service");
+        return true;
+    }
+
+    protected boolean cleanup() {
+        log("cleanup RTKBT Service");
+        clearRtkbtService();
+        CleanupNative();
+        return true;
+    }
+
+    public static synchronized RtkbtService getRtkbtService() {
+        if(mRtkbtService != null && mRtkbtService.isAvailable()) {
+            if (DBG) Log.d(TAG, "getRtkbtService(): returning " + mRtkbtService);
+            return mRtkbtService;
+        }
+        if(DBG){
+            if(mRtkbtService == null) {
+                Log.d(TAG, "getRtkbtService(): service is NULL");
+            } else if (!(mRtkbtService.isAvailable())) {
+                Log.d(TAG,"getRtkbtService(): service is not available");
+            }
+        }
+        return null;
+    }
+
+    private static synchronized void setRtkbtService(RtkbtService instance) {
+        if (instance != null && instance.isAvailable()) {
+            if (DBG) Log.d(TAG, "setRtkbtService(): set to: " + instance);
+            mRtkbtService = instance;
+        } else {
+            if (DBG){
+                if(mRtkbtService == null) {
+                    Log.d(TAG, "setRtkbtService(): service not available");
+                } else if (!mRtkbtService.isAvailable()) {
+                    Log.d(TAG,"setRtkbtService(): service is cleaning up");
+                }
+            }
+        }
+    }
+
+    private static synchronized void clearRtkbtService() {
+        mRtkbtService = null;
+    }
+
+
+    /**
+     * Handlers for incoming service calls
+     */
+    private static class BluetoothRtkbtBinder extends IBluetoothRtkbt.Stub implements IProfileServiceBinder
+    {
+        private RtkbtService mService;
+        public BluetoothRtkbtBinder(RtkbtService svc) {
+            mService = svc;
+        }
+
+        public boolean cleanup() {
+            mService = null;
+            return true;
+        }
+
+        private RtkbtService getService() {
+            if (!Utils.checkCaller()) {
+                Log.w(TAG,"InputDevice call not allowed for non-active user");
+                return null;
+            }
+
+            if (mService  != null && mService.isAvailable()) {
+                return mService;
+            }
+            return getRtkbtService();
+        }
+
+        public int GetFeature(int id) {
+            Log.d(TAG, "GetFeature");
+            RtkbtService service = getService();
+            int result = 0;
+            if (service == null) {
+                Log.w(TAG, "service is null");
+                return -9999;
+            }
+
+            try{
+                result =  service.GetFeature(id);
+            } catch(RemoteException e) {
+                Log.w(TAG, "GetFeature catch remote exception!");
+            }
+            return result;
+        }
+        public int GenericCommand(int id, int command, byte[] data, int len) {
+            Log.d(TAG, "GenericCommand");
+            RtkbtService service = getService();
+            int result = 0;
+            if (service == null) {
+                Log.w(TAG, "service is null");
+                return -9999;
+            }
+
+            try{
+                result =  service.GenericCommand(id, command, data, len);
+            } catch(RemoteException e) {
+                Log.w(TAG, "GenericCommand catch remote exception!");
+            }
+            return result;
+        }
+    };
+
+    //Methods
+    public int GetFeature(int id) throws RemoteException {
+        log("GetFeature id=" + id);
+        return GetFeatureNative(id);
+    }
+    public int GenericCommand(int id, int command, byte[] data, int len) throws RemoteException {
+        log("onGenericEvent id=" + id + " command="+ command +" len=" + len);
+        return GenericCommandNative(id, command, data, len);
+    }
+
+    //Events
+    public void onGenericEvent(int id , int event, byte[] data, int len) {
+        log("onGenericEvent id=" + id + " event="+ event +" len=" + len);
+        if(data == null)
+        {
+            Intent intent = new Intent(BluetoothRtkbt.ACTION_RTKBT_GENERIC_EVENT);
+            intent.putExtra(BluetoothRtkbt.ACTION_RTKBT_GENERIC_EVENT_id, id);
+            intent.putExtra(BluetoothRtkbt.ACTION_RTKBT_GENERIC_EVENT_event, event);
+            intent.putExtra(BluetoothRtkbt.ACTION_RTKBT_GENERIC_EVENT_len, len);
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            sendBroadcast(intent, BLUETOOTH_PERM);
+            return;
+        }
+        if(len <= data.length)
+        {
+            Intent intent = new Intent(BluetoothRtkbt.ACTION_RTKBT_GENERIC_EVENT);
+            intent.putExtra(BluetoothRtkbt.ACTION_RTKBT_GENERIC_EVENT_id, id);
+            intent.putExtra(BluetoothRtkbt.ACTION_RTKBT_GENERIC_EVENT_event, event);
+            intent.putExtra(BluetoothRtkbt.ACTION_RTKBT_GENERIC_EVENT_data, data);
+            intent.putExtra(BluetoothRtkbt.ACTION_RTKBT_GENERIC_EVENT_len, len);
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            sendBroadcast(intent, BLUETOOTH_PERM);
+        }else
+            log("onGenericEvent id=" + id + " event="+ event +" len=" + len +" Discard!!!");
+    }
+
+    public void log(String message){
+        if(DBG) Log.d(TAG, message);
+    }
+
+    //private native static void bt3ddClassInitNative();
+    private native static void classInitNative();
+    private native void InitNative();
+    private native void CleanupNative();
+    private native int GetFeatureNative(int id);
+    private native int GenericCommandNative(int id, int command, byte[] data, int len);
+}
+
+
diff --git a/src/com/broadcom/bt/service/IProfileStateChangeListener.java b/src/com/broadcom/bt/service/IProfileStateChangeListener.java
new file mode 100755
index 0000000..0b02dfa
--- /dev/null
+++ b/src/com/broadcom/bt/service/IProfileStateChangeListener.java
@@ -0,0 +1,52 @@
+/*******************************************************************************
+ *
+ *  Copyright (C) 2012 Broadcom Corporation
+ *
+ *  This program is the proprietary software of Broadcom Corporation and/or its
+ *  licensors, and may only be used, duplicated, modified or distributed
+ *  pursuant to the terms and conditions of a separate, written license
+ *  agreement executed between you and Broadcom (an "Authorized License").
+ *  Except as set forth in an Authorized License, Broadcom grants no license
+ *  (express or implied), right to use, or waiver of any kind with respect to
+ *  the Software, and Broadcom expressly reserves all rights in and to the
+ *  Software and all intellectual property rights therein.
+ *  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
+ *  SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+ *  ALL USE OF THE SOFTWARE.
+ *
+ *  Except as expressly set forth in the Authorized License,
+ *
+ *  1.     This program, including its structure, sequence and organization,
+ *         constitutes the valuable trade secrets of Broadcom, and you shall
+ *         use all reasonable efforts to protect the confidentiality thereof,
+ *         and to use this information only in connection with your use of
+ *         Broadcom integrated circuit products.
+ *
+ *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
+ *         "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+ *         REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+ *         OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+ *         DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+ *         NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+ *         ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ *         CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
+ *         OF USE OR PERFORMANCE OF THE SOFTWARE.
+ *
+ *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
+ *         ITS LICENSORS BE LIABLE FOR
+ *         (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
+ *               DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
+ *               YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
+ *               HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
+ *         (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
+ *               SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
+ *               LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
+ *               ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
+ *
+ *******************************************************************************/
+package com.broadcom.bt.service;
+
+public interface IProfileStateChangeListener {
+    public void onProfileStateChanged(String profileName, int newState, int oldState);
+    public void onDeviceModeSwitchComplete();
+}
diff --git a/src/com/broadcom/bt/service/ProfileConfig.java b/src/com/broadcom/bt/service/ProfileConfig.java
new file mode 100755
index 0000000..65bf505
--- /dev/null
+++ b/src/com/broadcom/bt/service/ProfileConfig.java
@@ -0,0 +1,499 @@
+/*******************************************************************************
+ *
+ *  Copyright (C) 2012 Broadcom Corporation
+ *
+ *  This program is the proprietary software of Broadcom Corporation and/or its
+ *  licensors, and may only be used, duplicated, modified or distributed
+ *  pursuant to the terms and conditions of a separate, written license
+ *  agreement executed between you and Broadcom (an "Authorized License").
+ *  Except as set forth in an Authorized License, Broadcom grants no license
+ *  (express or implied), right to use, or waiver of any kind with respect to
+ *  the Software, and Broadcom expressly reserves all rights in and to the
+ *  Software and all intellectual property rights therein.
+ *  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
+ *  SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+ *  ALL USE OF THE SOFTWARE.
+ *
+ *  Except as expressly set forth in the Authorized License,
+ *
+ *  1.     This program, including its structure, sequence and organization,
+ *         constitutes the valuable trade secrets of Broadcom, and you shall
+ *         use all reasonable efforts to protect the confidentiality thereof,
+ *         and to use this information only in connection with your use of
+ *         Broadcom integrated circuit products.
+ *
+ *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
+ *         "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+ *         REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+ *         OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+ *         DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+ *         NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+ *         ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ *         CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
+ *         OF USE OR PERFORMANCE OF THE SOFTWARE.
+ *
+ *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
+ *         ITS LICENSORS BE LIABLE FOR
+ *         (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
+ *               DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
+ *               YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
+ *               HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
+ *         (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
+ *               SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
+ *               LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
+ *               ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
+ *
+ *******************************************************************************/
+package com.broadcom.bt.service;
+
+import java.util.ArrayList;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.res.Resources;
+import android.provider.Settings;
+import android.util.Log;
+
+import com.android.bluetooth.R;
+import com.android.bluetooth.a2dp.A2dpService;
+import com.android.bluetooth.a2dp.A2dpSinkService;
+import com.android.bluetooth.btservice.Config;
+import com.android.bluetooth.hdp.HealthService;
+import com.android.bluetooth.hfp.HeadsetService;
+import com.android.bluetooth.hid.HidService;
+import com.android.bluetooth.pan.PanService;
+import com.android.bluetooth.avrcp.AvrcpControllerService;
+import com.android.bluetooth.sap.SapService;
+
+import com.android.bluetooth.rtkbt.RtkbtService;
+import com.android.bluetooth.gatt.GattService;
+
+import com.android.bluetooth.map.BluetoothMapService;
+import com.android.bluetooth.hfpclient.HeadsetClientService;
+
+
+import com.android.bluetooth.btservice.AdapterService;
+import android.content.SharedPreferences;
+import android.preference.PreferenceManager;
+
+
+/**
+ * Overrides the Bluedroid standard profile config and adds Broadcom specific
+ * profiles
+ *
+ * @author fredc
+ *
+ */
+public class ProfileConfig extends Config {
+    private static final String TAG = "BtSettings.ProfileConfig";
+    private static Context mContext;
+    /**
+     * List of profile services.
+     */
+    private static final int INDEX_CLASS_NAME=0;
+    private static final int INDEX_NAME=1;
+    private static final int INDEX_DESCRIPTION=2;
+    private static final int INDEX_SUPPORTED=3;
+    private static final int INDEX_DEFAULT_START=4;
+    private static final int INDEX_CONFIGURABLE=5;
+    private static final int INDEX_CFG_DEVICE_MODE = 6;
+    private static final int INDEX_DETAILED_FRAGMENT= 7;
+
+    // Profile will run in both device and phone mode and is Independent of device mode switching
+    // Typically for the profile which is not concerned about "device mode switching"
+    // will use CFG_MODE_DUAL
+    public static final int CFG_MODE_DUAL = 0;
+
+    // The profile will run only on Device and will be disabled in TV mode
+    public static final int CFG_MODE_DEVICE = 1;
+    // The profile will run only on TV and will be disabled in device mode
+    public static final int CFG_MODE_TV = 2;
+    // The same service supports both DEVICE and PHONE so a stop and restart
+    // of the same service is required when mode switch happens
+    public static final int CFG_MODE_DEVICE_OR_PHONE = 3;
+
+
+    // Do not include OPP and PBAP, because their services
+    // are not managed by AdapterService
+    private static final Object[][] PROFILE_SERVICES= {
+        //Headset/HFP configuration
+        {   HeadsetService.class,
+            R.string.profile_hs_hfp,
+            R.string.profile_description_hs_hfp,
+            R.bool.profile_supported_hs_hfp,
+            R.bool.profile_default_start_hs_hfp,
+            R.bool.profile_configurable_hs_hfp,
+            R.integer.profile_cfg_run_in_device_mode_hs_hfp,
+            null }
+        ,
+        //A2DP configuration
+        {   A2dpService.class,
+            R.string.profile_a2dp,
+            R.string.profile_description_a2dp,
+            R.bool.profile_supported_a2dp,
+            R.bool.profile_default_start_a2dp,
+            R.bool.profile_configurable_a2dp,
+            R.integer.profile_cfg_run_in_device_mode_a2dp,
+            null }
+        ,
+	//RTKBT
+	    {   RtkbtService.class,
+ 	        R.string.profile_rtkbt,
+	        R.string.profile_description_rtkbt,
+	        R.bool.profile_supported_rtkbt,
+            R.bool.profile_default_start_rtkbt,
+            R.bool.profile_configurable_rtkbt,
+            R.integer.profile_cfg_run_in_device_mode_rtkbt,
+            //null,
+	        null}
+		,
+        //HID Host configuration
+        {   HidService.class,
+            R.string.profile_hid,
+            R.string.profile_description_hid,
+            R.bool.profile_supported_hid,
+            R.bool.profile_default_start_hid,
+            R.bool.profile_configurable_hid,
+            R.integer.profile_cfg_run_in_device_mode_hid,
+            null }
+        ,
+        //Heath Profile configuration
+        {   HealthService.class,
+            R.string.profile_hdp,
+            R.string.profile_description_hdp,
+            R.bool.profile_supported_hdp,
+            R.bool.profile_default_start_hdp,
+            R.bool.profile_configurable_hdp,
+            R.integer.profile_cfg_run_in_device_mode_hdp,
+            null }
+        ,
+        //PAN configuration
+        {   PanService.class,
+            R.string.profile_pan,
+            R.string.profile_description_pan,
+            R.bool.profile_supported_pan,
+            R.bool.profile_default_start_pan,
+            R.bool.profile_configurable_pan,
+            R.integer.profile_cfg_run_in_device_mode_pan,
+            null }
+        ,
+        //Gatt configuration
+        {   GattService.class,
+            R.string.profile_gatt,
+            R.string.profile_description_gatt,
+            R.bool.profile_supported_gatt,
+            R.bool.profile_default_start_gatt,
+            R.bool.profile_configurable_gatt,
+            R.integer.profile_cfg_run_in_device_mode_gatt,
+            null }
+        ,
+        //MAP configuration (AOSP MAP Server)
+        {   BluetoothMapService.class,
+            R.string.profile_mse,
+            R.string.profile_description_mse,
+            R.bool.profile_supported_map,
+            R.bool.profile_default_start_mse,
+            R.bool.profile_configurable_mse,
+            R.integer.profile_cfg_run_in_device_mode_mse,
+            null
+            }
+        ,
+        //Sap configuration
+        {   SapService.class,
+            R.string.profile_sap,
+            R.string.profile_description_sap,
+            R.bool.profile_supported_sap,
+            R.bool.profile_default_start_sap,
+            R.bool.profile_configurable_sap,
+            R.integer.profile_cfg_run_in_device_mode_sap,
+            null }
+        ,
+        //AVRCP Controller profile configuration
+        {   AvrcpControllerService.class,
+            R.string.profile_avrcp_ct,
+            R.string.profile_description_avrcp_ct,
+            R.bool.profile_supported_avrcp_controller,
+            R.bool.profile_default_start_avrcp_ct,
+            R.bool.profile_configurable_avrcp_ct,
+            R.integer.profile_cfg_run_in_device_mode_avrcp_ct,
+            null }
+        ,
+        //HF client profile configuration (AOSP HF client implementation)
+        {   HeadsetClientService.class,
+            R.string.profile_hfclient,
+            R.string.profile_description_hfdevice,
+            R.bool.profile_supported_hfpclient,
+            R.bool.profile_default_start_hfclient,
+            R.bool.profile_configurable_hfclient,
+            R.integer.profile_cfg_run_in_device_mode_hfclient,
+            null }
+        ,
+        //A2DP SINK configuration
+        {   A2dpSinkService.class,
+            R.string.profile_a2dp_sink,
+            R.string.profile_description_a2dp_sink,
+            R.bool.profile_supported_a2dp_sink,
+            R.bool.profile_default_start_a2dp_sink,
+            R.bool.profile_configurable_a2dp_sink,
+            R.integer.profile_cfg_run_in_device_mode_a2dp_sink,
+            null }
+/*
+         ,
+	//RTKBT
+	{   RtkbtService.class,
+ 	    R.string.profile_rtkbt,
+	    R.string.profile_description_rtkbt,
+	    R.bool.profile_supported_rtkbt,
+            R.bool.profile_default_start_rtkbt,
+            R.bool.profile_configurable_rtkbt,
+            R.integer.profile_cfg_run_in_device_mode_rtkbt,
+            //null,
+	    null}
+*/
+
+    };
+
+    public static class ProfileCfg {
+        public String mName;
+        public String mDisplayName;
+        public String mDescription;
+        public boolean mDefaultStarted;
+        public boolean mUserConfigurable;
+        public int mDeviceModeCfg;
+        public String mSettingsActivityPkgClassName;
+    }
+
+    @SuppressWarnings("rawtypes")
+    private static Class[] SUPPORTED_PROFILES = new Class[0];
+    private static Class[] QUIET_MODE_PROFILES = new Class[0];
+    private static ProfileCfg[] SUPPORTED_PROFILES_CFG = new ProfileCfg[0];
+    private static final String SETTINGS_PREFIX = "bt_svcst_";
+
+    private static  boolean mDeviceModeCfgSupported = true;
+
+    private static void initSettings() {
+        // Initialize Bluetooth profile settins
+        if (mContext != null) {
+            ContentResolver cr = mContext.getContentResolver();
+            boolean settingsExist =  Settings.Global.getInt(cr, SETTINGS_PREFIX + "init", 0) != 0;
+            //if (!settingsExist) {
+                Log.e(TAG, "*********Initializing Bluetooth Profile Settings*******");
+                for (int i = 0; i < SUPPORTED_PROFILES_CFG.length; i++) {
+                    ProfileCfg cfg = SUPPORTED_PROFILES_CFG[i];
+                    Settings.Global.putInt(cr, SETTINGS_PREFIX + cfg.mName, cfg.mDefaultStarted ? 1
+                            : 0);
+                }
+                Settings.Global.putInt(cr, SETTINGS_PREFIX + "init", 1);
+            //}
+
+        }
+    }
+
+    private static void checkAndAdjustDeviceModeConfiguration() {
+
+        SharedPreferences settings = PreferenceManager.
+            getDefaultSharedPreferences(mContext);
+        int deviceMode = settings.getInt("DEVICEMODE",-1);
+        Log.d(TAG,"deviceMode from shared preference   " + deviceMode );
+        if( deviceMode == -1 )
+        {
+            Resources r = mContext.getResources();
+            boolean isDevicemode = r
+                    .getBoolean(com.android.bluetooth.R.bool.tv_mode);
+            if( isDevicemode )
+                deviceMode = AdapterService.DEFAULT_MODE;
+            else
+                deviceMode = AdapterService.HEADSET_MODE;
+        }
+        Log.d(TAG,"checkAndAdjustDeviceModeConfiguration deviceMode" + deviceMode );
+
+        for (int i = 0; i < SUPPORTED_PROFILES_CFG.length; i++) {
+            boolean isProfileEnabled = isProfileConfiguredEnabled(SUPPORTED_PROFILES_CFG[i].mName);
+            if (SUPPORTED_PROFILES_CFG[i].mDeviceModeCfg == CFG_MODE_DEVICE) {
+                //Enable Device mode profile if not enabled
+                //and disable Phone mode services if enabled
+                if ((AdapterService.HEADSET_MODE == deviceMode) &&
+                    !isProfileEnabled)
+                    saveProfileSetting(SUPPORTED_PROFILES_CFG[i].mName,true);
+                else if ((AdapterService.DEFAULT_MODE == deviceMode) &&
+                    isProfileEnabled &&
+                    // If service is configurable in UI leave the recovery state control to user
+                    (SUPPORTED_PROFILES_CFG[i].mUserConfigurable == false))
+                    saveProfileSetting(SUPPORTED_PROFILES_CFG[i].mName,false);
+            } else if (SUPPORTED_PROFILES_CFG[i].mDeviceModeCfg == CFG_MODE_TV) {
+                //Enable Phone mode profile if not enabled
+                //and disable Device mode services if enabled
+                if ((AdapterService.DEFAULT_MODE == deviceMode) &&
+                    !isProfileEnabled)
+                    saveProfileSetting(SUPPORTED_PROFILES_CFG[i].mName,true);
+                else if ((AdapterService.HEADSET_MODE == deviceMode) &&
+                    isProfileEnabled)
+                    saveProfileSetting(SUPPORTED_PROFILES_CFG[i].mName,false);
+            } else if (SUPPORTED_PROFILES_CFG[i].mDeviceModeCfg == CFG_MODE_DEVICE_OR_PHONE
+                     && !isProfileEnabled) {
+                     // For Device and Phone mode service enable if not enabled
+                 saveProfileSetting(SUPPORTED_PROFILES_CFG[i].mName,true);
+            }
+        }
+
+    }
+
+    @SuppressWarnings("rawtypes")
+    public static void init(Context ctx) {
+        if (ctx == null) {
+            return;
+        }
+        mContext = ctx;
+        Resources resources = ctx.getResources();
+        if (resources == null) {
+            return;
+        }
+        ArrayList<Class> profiles = new ArrayList<Class>(PROFILE_SERVICES.length);
+        ArrayList<ProfileCfg> cfgs = new ArrayList<ProfileCfg>(PROFILE_SERVICES.length);
+        for (int i = 0; i < PROFILE_SERVICES.length; i++) {
+            boolean supported = resources.getBoolean((Integer)PROFILE_SERVICES[i][INDEX_SUPPORTED]);
+            if (supported) {
+                Class profile = (Class)PROFILE_SERVICES[i][INDEX_CLASS_NAME];
+                Log.d(TAG, "Adding " +profile.getSimpleName());
+                profiles.add(profile);
+
+                ProfileCfg cfg = new ProfileCfg();
+                cfg.mName = profile.getName();
+                // Add display name
+                String displayName = null;
+                try {
+                    displayName = resources.getString((Integer)PROFILE_SERVICES[i][INDEX_NAME]);
+                } catch (Throwable t) {
+                    Log.w(TAG, "Profile display name not found", t);
+                }
+                cfg.mDisplayName = (displayName == null ? profile.getName()
+                        : displayName);
+
+                // Add description
+                String description = null;
+                try {
+                    description = resources.getString
+                            ((Integer)PROFILE_SERVICES[i][INDEX_DESCRIPTION]);
+                } catch (Throwable t) {
+                    Log.w(TAG, "Profile display name not found", t);
+                }
+                cfg.mDescription = (description == null ? profile.getName()
+                        : description);
+
+                // Add configuration flags
+                cfg.mDefaultStarted = resources.getBoolean
+                        ((Integer)PROFILE_SERVICES[i][INDEX_DEFAULT_START]);
+                cfg.mUserConfigurable = resources
+                        .getBoolean((Integer)PROFILE_SERVICES[i][INDEX_CONFIGURABLE]);
+                cfg.mDeviceModeCfg = resources
+                        .getInteger((Integer)PROFILE_SERVICES[i][INDEX_CFG_DEVICE_MODE]);
+                // Add activity
+                cfg.mSettingsActivityPkgClassName =
+                        ((String)PROFILE_SERVICES[i][INDEX_DETAILED_FRAGMENT]);
+                cfgs.add(cfg);
+            }
+        }
+        int totalProfiles = profiles.size();
+        SUPPORTED_PROFILES = new Class[totalProfiles];
+        SUPPORTED_PROFILES_CFG = new ProfileCfg[totalProfiles];
+        for (int i = 0; i < totalProfiles; i++) {
+            SUPPORTED_PROFILES[i] = profiles.get(i);
+            SUPPORTED_PROFILES_CFG[i] = cfgs.get(i);
+        }
+        mDeviceModeCfgSupported = resources.getBoolean((Integer)R.bool.supports_device_mode_cfg);
+
+        initSettings();
+        checkAndAdjustDeviceModeConfiguration();
+    }
+
+    private static int findProfileIndex(String className) {
+        for (int i = 0; i < SUPPORTED_PROFILES.length; i++) {
+            if (className.equals(SUPPORTED_PROFILES[i].getName())) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    @SuppressWarnings("rawtypes")
+    public static Class[] getSupportedProfiles() {
+        return SUPPORTED_PROFILES;
+    }
+
+    public static ProfileCfg[] getSupportedProfileCfgs() {
+        return SUPPORTED_PROFILES_CFG;
+    }
+
+    public boolean isProfileSupported(String profileName) {
+        return findProfileIndex(profileName) >= 0;
+    }
+
+
+    public static boolean isDeviceModeProfile(String profileName) {
+        if ( mDeviceModeCfgSupported== false) {
+            // Device mode configuration is not supported. Return false by default for all profiles.
+            return false;
+        }
+        for (int i = 0; i < SUPPORTED_PROFILES_CFG.length; i++)
+            if (SUPPORTED_PROFILES_CFG[i].mName.equals(profileName) &&
+                (SUPPORTED_PROFILES_CFG[i].mDeviceModeCfg == CFG_MODE_DEVICE ||
+                SUPPORTED_PROFILES_CFG[i].mDeviceModeCfg == CFG_MODE_DEVICE_OR_PHONE))
+                return true;
+        return false;
+    }
+
+    public static boolean isPhoneModeProfile(String profileName) {
+        if ( mDeviceModeCfgSupported== false) {
+            // Device mode configuration is not supported. Return false by default for all profiles.
+            return false;
+        }
+        for (int i = 0; i < SUPPORTED_PROFILES_CFG.length; i++)
+            if (SUPPORTED_PROFILES_CFG[i].mName.equals(profileName) &&
+                (SUPPORTED_PROFILES_CFG[i].mDeviceModeCfg == CFG_MODE_TV ||
+                SUPPORTED_PROFILES_CFG[i].mDeviceModeCfg == CFG_MODE_DEVICE_OR_PHONE))
+                return true;
+        return false;
+    }
+
+
+    /**
+     * Save the profile state (on or off)
+     *
+     * @param on
+     * @return
+     */
+    public static void saveProfileSetting(String profileName, boolean enabled) {
+        Log.d(TAG,"saveProfileSetting profileName= "+profileName+"enabled"+enabled);
+        if (mContext != null) {
+            ContentResolver cr = mContext.getContentResolver();
+            int profileIndex = findProfileIndex(profileName);
+            if (profileIndex < 0) {
+                Log.w(TAG, "Profile not supported: " + profileName);
+                return;
+            }
+
+            Settings.Global.putInt(cr, SETTINGS_PREFIX + profileName, enabled ? 1 : 0);
+        }
+    }
+
+    public static boolean isProfileConfiguredEnabled(String profileName) {
+        int profileIndex = findProfileIndex(profileName);
+        if (profileIndex < 0) {
+            return false;
+        }
+
+        if (mContext != null) {
+            ContentResolver cr = mContext.getContentResolver();
+            try {
+                Log.d(TAG, "getProfileSaveSetting: " + profileName);
+                return Settings.Global.getInt(cr, SETTINGS_PREFIX + profileName) == 1;
+            } catch (Throwable t) {
+                Log.d(TAG, "Unable to read settings", t);
+            }
+        }
+        // If the profile entry not present,
+        // return true assuming by default a profile is always enabled.
+        return true;
+    }
+
+}
diff --git a/src/com/broadcom/bt/settings/BluetoothAdvancedSettings.java b/src/com/broadcom/bt/settings/BluetoothAdvancedSettings.java
new file mode 100755
index 0000000..95b096a
--- /dev/null
+++ b/src/com/broadcom/bt/settings/BluetoothAdvancedSettings.java
@@ -0,0 +1,531 @@
+/*******************************************************************************
+ *
+ *  Copyright (C) 2012-2013 Broadcom Corporation
+ *
+ *  This program is the proprietary software of Broadcom Corporation and/or its
+ *  licensors, and may only be used, duplicated, modified or distributed
+ *  pursuant to the terms and conditions of a separate, written license
+ *  agreement executed between you and Broadcom (an "Authorized License").
+ *  Except as set forth in an Authorized License, Broadcom grants no license
+ *  (express or implied), right to use, or waiver of any kind with respect to
+ *  the Software, and Broadcom expressly reserves all rights in and to the
+ *  Software and all intellectual property rights therein.
+ *  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
+ *  SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+ *  ALL USE OF THE SOFTWARE.
+ *
+ *  Except as expressly set forth in the Authorized License,
+ *
+ *  1.     This program, including its structure, sequence and organization,
+ *         constitutes the valuable trade secrets of Broadcom, and you shall
+ *         use all reasonable efforts to protect the confidentiality thereof,
+ *         and to use this information only in connection with your use of
+ *         Broadcom integrated circuit products.
+ *
+ *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
+ *         "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+ *         REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+ *         OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+ *         DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+ *         NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+ *         ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ *         CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
+ *         OF USE OR PERFORMANCE OF THE SOFTWARE.
+ *
+ *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
+ *         ITS LICENSORS BE LIABLE FOR
+ *         (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
+ *               DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
+ *               YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
+ *               HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
+ *         (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
+ *               SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
+ *               LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
+ *               ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
+ *
+ *******************************************************************************/
+package com.broadcom.bt.settings;
+
+import java.util.List;
+
+import com.android.bluetooth.R;
+import com.android.bluetooth.btservice.AdapterService;
+
+import com.broadcom.bt.service.IProfileStateChangeListener;
+import com.broadcom.bt.service.ProfileConfig;
+import com.broadcom.bt.service.ProfileConfig.ProfileCfg;
+
+import com.broadcom.bt.settings.HeaderAdapter.HeaderViewHolder;
+import com.broadcom.bt.service.settings.ModeAdvancedSettings;
+
+import android.bluetooth.BluetoothAdapter;
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.os.Bundle;
+import android.preference.PreferenceActivity;
+import android.preference.PreferenceActivity.Header;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.Button;
+import android.widget.CompoundButton;
+import android.widget.ImageView;
+import android.widget.ListAdapter;
+import android.widget.Switch;
+import android.widget.TextView;
+import android.content.res.Resources;
+import android.app.Activity;
+
+import android.content.ContentResolver;
+import android.provider.Settings;
+import android.content.SharedPreferences;
+import android.preference.PreferenceManager;
+
+import com.android.bluetooth.hfp.HeadsetService;
+
+public class BluetoothAdvancedSettings extends PreferenceActivity implements
+        HeaderAdapter.OnCheckedChangeListener, IProfileStateChangeListener {
+    private static final String TAG = "BtSettings.BluetoothAdvancedSettings";
+    public static final String EXTRA_PROFILE_NAME = "profileName";
+
+    public static final String EXTRA_DEVICE_MODE = "deviceMode";
+
+    private static final String SETTINGS_PREFIX = "bt_svcst_";
+    private static Context mContext;
+    private static final Object[] MODE= {
+                            R.string.active_mode
+                        };
+
+    private static boolean isDeviceModeSwitchInProgress = false;
+
+    private static class AdvancedSettingsHeaderAdapter extends HeaderAdapter {
+        public boolean getSwitchState(Header header) {
+       String deviceModeName = header.extras
+                   .getString(BluetoothAdvancedSettings.EXTRA_DEVICE_MODE);
+
+            if (deviceModeName != null)
+            {
+                Log.d(TAG, "Getting device mode switch state for " + deviceModeName);
+                boolean isEnabled = isDeviceModeEnabled(deviceModeName);
+                Log.d(TAG, "device mode enabled? " + isEnabled);
+                return isEnabled;
+            }
+
+            String profileName = header.extras
+                    .getString(BluetoothAdvancedSettings.EXTRA_PROFILE_NAME);
+            Log.d(TAG, "Getting switch state for " + profileName);
+            boolean isEnabled = isProfileEnabledAndStarted(profileName);
+            Log.d(TAG, "Profile enabled? " + isEnabled);
+            return isEnabled;
+        }
+
+        public AdvancedSettingsHeaderAdapter(Context context, List<Header> objects) {
+            super(context, objects);
+        }
+
+        protected int getHeaderType(Header header) {
+            return HEADER_TYPE_SWITCH;
+        }
+
+        protected int getHeaderLayoutResId(int headerType) {
+            switch (headerType) {
+            case HEADER_TYPE_SWITCH:
+                return R.layout.preference_header_switch_item;
+            }
+            return -1;
+        }
+
+    }
+
+    protected boolean isValidFragment(String fragmentName) {
+        // TODO: Check validation of fragment after adding fragment.
+        return true;
+    }
+
+    private static boolean isProfileServiceStarted(String profileName) {
+        AdapterService svc = AdapterService.getAdapterService();
+        if (svc == null) {
+            return false;
+        }
+        return svc.isProfileStarted(profileName);
+    }
+
+    private static boolean isProfileEnabledAndStarted(String profileName) {
+        return ProfileConfig.isProfileConfiguredEnabled(profileName)
+                && isProfileServiceStarted(profileName);
+    }
+
+
+    private boolean setProfileState(String profileName, boolean setEnabled) {
+        ProfileConfig.saveProfileSetting(profileName, setEnabled);
+        AdapterService svc = AdapterService.getAdapterService();
+        boolean result = false;
+        if (svc == null) {
+            return false;
+        }
+        svc.setProfileStateChangeListener(this);
+
+        ProfileConfig.saveProfileSetting(profileName, setEnabled);
+
+        result = svc.setProfileState(profileName, setEnabled);
+
+        if (result == true)
+            svc.sendUUIDChange(AdapterService.MESSAGE_DELAY_FOR_SEND_UUID_CHANGED);
+
+        return result;
+    }
+
+
+    AdvancedSettingsHeaderAdapter mAdapter;
+    AdapterService mService;
+
+    protected void onCreate(Bundle savedInstanceState) {
+        Log.d(TAG, "onCreate"+mAdapter);
+        super.onCreate(savedInstanceState);
+        mService = AdapterService.getAdapterService();
+
+        if (mService != null) {
+            mService.setProfileStateChangeListener(this);
+        }
+    }
+
+    protected void onDestroy() {
+        Log.d(TAG, "onDestroy"+mAdapter);
+        if (mService != null) {
+            mService.unsetProfileStateChangeListener();
+            mService = null;
+        }
+        super.onDestroy();
+    }
+
+    public void onResume() {
+     Log.d(TAG, "onResume");
+
+     super.onResume();
+
+     if (mService != null) {
+         mService.setProfileStateChangeListener(this);
+     }
+
+
+     if (mAdapter == null) {
+         Log.w(TAG, "onResume(): mAdapter not found");
+         return;
+     }
+
+     int count = mAdapter.getCount();
+     for (int i = 0; i < count; i++) {
+         Header header = (Header) mAdapter.getItem(i);
+         String name = null;
+         if (header != null && header.extras != null
+                 && (name = header.extras.getString(EXTRA_DEVICE_MODE)) != null) {
+             HeaderViewHolder viewHolder = mAdapter.getHeaderViewHolder(i);
+             if (viewHolder != null && viewHolder.switch_ != null) {
+                 final CompoundButton button = viewHolder.switch_;
+                 runOnUiThread(new Runnable() {
+                     @Override
+                     public void run() {
+                     BluetoothAdapter btAdapter = BluetoothAdapter.getDefaultAdapter();
+                     // Do it only when there is no devie mode switch in progress
+                     // and Device mode Button is disabled due to device mode switch
+                      if ((!button.isEnabled()) && (isDeviceModeSwitchInProgress == false) )
+                         button.setEnabled(true);
+                     }
+                 });
+             }
+         }
+     }
+
+    }
+
+
+    public void onPause() {
+     Log.d(TAG, "onPause");
+        super.onPause();
+    }
+
+    @Override
+    public void onBuildHeaders(List<Header> headers) {
+        // Get a list of Bluetooth Profiles and add them
+        ProfileCfg[] supportedProfileCfgs = ProfileConfig.getSupportedProfileCfgs();
+        for (int i = 0; i < supportedProfileCfgs.length; i++) {
+            ProfileCfg p = supportedProfileCfgs[i];
+            try {
+                if (p.mUserConfigurable && ((p.mDeviceModeCfg != ProfileConfig.CFG_MODE_DEVICE) &&
+                (p.mDeviceModeCfg != ProfileConfig.CFG_MODE_TV))) {
+                    Header h = new Header();
+                    h.title = p.mDisplayName;
+                    h.summary = p.mDescription;
+                    h.extras = new Bundle();
+                    h.extras.putString(EXTRA_PROFILE_NAME, p.mName);
+                    h.fragment= ModeAdvancedSettings.class.getName();
+                    headers.add(h);
+                }
+            } catch (Throwable t) {
+                Log.w(TAG, "Error loading profile state: " + p.mName, t);
+            }
+        }
+
+        // FIXME -- merge with existing framework
+        mContext = this.getApplicationContext();
+            Resources resources = mContext.getResources();
+        String displayName = null;
+        String deviceModesummary = null;
+        int a2dpProfileDeviceMode = resources
+                    .getInteger((Integer)R.integer.profile_cfg_run_in_device_mode_a2dp);
+        int a2dpSinkProfileDeviceMode = resources
+                    .getInteger((Integer)R.integer.profile_cfg_run_in_device_mode_a2dp_sink);
+
+        int hfDeviceProfileDeviceMode = resources
+                    .getInteger((Integer)R.integer.profile_cfg_run_in_device_mode_hfdevice);
+        int headsetProfileDeviceMode = resources
+                    .getInteger((Integer)R.integer.profile_cfg_run_in_device_mode_hs_hfp);
+
+
+        if ((ProfileConfig.CFG_MODE_TV == a2dpProfileDeviceMode) &&
+            (ProfileConfig.CFG_MODE_DEVICE == a2dpSinkProfileDeviceMode) &&
+                (ProfileConfig.CFG_MODE_DEVICE == hfDeviceProfileDeviceMode) &&
+                (ProfileConfig.CFG_MODE_TV == headsetProfileDeviceMode) &&
+                (true == resources.getBoolean(R.bool.profile_supported_a2dp)) &&
+                (true == resources.getBoolean(R.bool.profile_supported_hfdevice)))
+            deviceModesummary = "AV-Src & HFP-AG when ON/ AVK & HFP-HF when OFF";
+        else if ((ProfileConfig.CFG_MODE_TV == a2dpProfileDeviceMode) &&
+                (ProfileConfig.CFG_MODE_DEVICE == a2dpSinkProfileDeviceMode) &&
+                (true == resources.getBoolean(R.bool.profile_supported_a2dp)))
+            deviceModesummary = "AV-Src when ON/ AVK when OFF";
+        else if ((ProfileConfig.CFG_MODE_DEVICE == hfDeviceProfileDeviceMode) &&
+                (ProfileConfig.CFG_MODE_TV == headsetProfileDeviceMode) &&
+                (true == resources.getBoolean(R.bool.profile_supported_hfdevice)))
+            deviceModesummary = "HFP-AG when ON/ HFP-HF when OFF";
+
+        if(null == deviceModesummary)// Do not shown configurable option in Advanced Settings
+            return;
+
+
+        try {
+            //resources.getString((Integer)MODE[0]);
+            displayName = resources.getString(R.string.TV_mode);
+            if (displayName == null)
+                return;
+            Header h = new Header();
+            h.title = displayName;
+            h.summary = deviceModesummary;
+            h.extras = new Bundle();
+            h.extras.putString(EXTRA_DEVICE_MODE, displayName);
+            h.fragment=ModeAdvancedSettings.class.getName();
+            headers.add(h);
+        } catch (Throwable t) {
+            Log.w(TAG, "Error loading :" + displayName );
+        }
+    }
+
+    @Override
+    public void setListAdapter(ListAdapter adapter) {
+        if (adapter == null) {
+            super.setListAdapter(null);
+        } else {
+            mAdapter = new AdvancedSettingsHeaderAdapter(this, getHeaders());
+            mAdapter.setCheckedChangeListener(this);
+            super.setListAdapter(mAdapter);
+        }
+    }
+
+ public boolean setDeviceMode( String deviceModeName,boolean isChecked, int deviceMode) {
+        saveDeviceModeSetting(deviceModeName, isChecked);
+        AdapterService svc = AdapterService.getAdapterService();
+        if (svc == null) {
+            return false;
+        }
+        mContext = this.getApplicationContext();
+        SharedPreferences.Editor editor = PreferenceManager.
+            getDefaultSharedPreferences(mContext).edit();
+
+        svc.setProfileStateChangeListener(this);
+
+        Log.d(TAG,"BluetoothAdvancedSettings  mDeviceMode   " + deviceMode );
+        editor.putInt("DEVICEMODE",deviceMode);
+        editor.apply();
+        isDeviceModeSwitchInProgress = true;
+
+        return svc.setDeviceMode(deviceMode);
+    }
+
+
+     @Override
+    public void onCheckedChanged(int position, boolean isChecked) {
+        if (mAdapter == null) {
+            Log.w(TAG, "mAdapter not found");
+            return;
+
+        }
+        // Get the header
+        Header header = (Header) mAdapter.getItem(position);
+        if (header == null) {
+            Log.w(TAG, "Header not found for position " + position);
+            return;
+        }
+        Bundle b = header.extras;
+        if (b == null) {
+            Log.w(TAG, "Bundle not found for position " + position);
+            return;
+        }
+
+        // fixme -- integrate into existing profile framework
+        String deviceMode = b.getString(EXTRA_DEVICE_MODE);
+
+        if (deviceMode != null)
+        {
+            HeaderViewHolder viewHolder = mAdapter.getHeaderViewHolder(position);
+            if (viewHolder == null) {
+                Log.w(TAG, "ViewHolder not found for position " + position);
+                return;
+            }
+            final CompoundButton cpButton = viewHolder.switch_;
+            if (cpButton == null) {
+                Log.w(TAG, "Button not found for position " + position);
+                return;
+            }
+            final TextView tv_title = viewHolder.title;
+           if (tv_title == null) {
+               Log.w(TAG, "Title not found for position " + position);
+               return;
+           }
+            BluetoothAdapter btAdapter = BluetoothAdapter.getDefaultAdapter();
+            if(isChecked) {
+                setDeviceMode(deviceMode,isChecked,mService.DEFAULT_MODE);
+                tv_title.setClickable(false);
+            //    BluetoothAdapter btAdapter = BluetoothAdapter.getDefaultAdapter();
+		btAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE);
+            } else {
+                setDeviceMode(deviceMode,isChecked,mService.HEADSET_MODE);
+                btAdapter.setDiscoverableTimeout(0);
+		btAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE,0);
+                tv_title.setClickable(false);
+           }
+            cpButton.setEnabled(false);
+
+
+            return;
+        }
+
+        String profileName = b.getString(EXTRA_PROFILE_NAME);
+        if (profileName == null) {
+            Log.w(TAG, "Profile name not found for position " + position);
+            return;
+        }
+
+        Log.d(TAG, "onCheckChanged: profileName=" + profileName + ", isChecked=" + isChecked);
+        HeaderViewHolder viewHolder = mAdapter.getHeaderViewHolder(position);
+        if (viewHolder == null) {
+            Log.w(TAG, "ViewHolder not found for position " + position);
+            return;
+        }
+        Button button = viewHolder.switch_;
+        if (button == null) {
+            Log.w(TAG, "Button not found for position " + position);
+            return;
+        }
+        button.setEnabled(false);
+        setProfileState(profileName, isChecked);
+    }
+
+  /**
+     * Save the  device mode  (DEFAULT or HEADSET)
+     *
+     * @param on
+     * @return
+     */
+    public static void saveDeviceModeSetting(String deviceModeName, boolean enabled) {
+        if (mContext != null) {
+            ContentResolver cr = mContext.getContentResolver();
+            Settings.Global.putInt(cr, SETTINGS_PREFIX + deviceModeName, enabled ? 1 : 0);
+        }
+    }
+    //The default device mode displayed should be "TV".Content Resolver will be be NULL
+    //initially.
+    public static boolean isDeviceModeEnabled(String deviceModeName) {
+        boolean ret = true;
+        if (mContext != null) {
+            ContentResolver cr = mContext.getContentResolver();
+            try {
+                Log.d(TAG, "getProfileSaveSetting: " + deviceModeName);
+                if( Settings.Global.getInt(cr, SETTINGS_PREFIX + deviceModeName) != 1)
+                    ret = false;
+            } catch (Throwable t) {
+                Log.d(TAG, "Unable to read settings", t);
+            }
+        }
+        return ret;
+    }
+
+    @Override
+    public void onDeviceModeSwitchComplete() {
+
+        Log.w(TAG, "onDeviceModeSwitchComplete()");
+
+        isDeviceModeSwitchInProgress = false;
+        if (mAdapter == null) {
+            Log.w(TAG, "onDeviceModeSwitchComplete(): mAdapter not found");
+            return;
+        }
+
+        int count = mAdapter.getCount();
+        for (int i = 0; i < count; i++) {
+            Header header = (Header) mAdapter.getItem(i);
+            String name = null;
+            if (header != null && header.extras != null
+                    && (name = header.extras.getString(EXTRA_DEVICE_MODE)) != null) {
+                HeaderViewHolder viewHolder = mAdapter.getHeaderViewHolder(i);
+                if (viewHolder != null && viewHolder.switch_ != null) {
+                    final CompoundButton button = viewHolder.switch_;
+                    runOnUiThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            button.setEnabled(true);
+                            button.refreshDrawableState();
+                            mAdapter.notifyDataSetChanged();
+                        }
+                    });
+                }
+            }
+        }
+    }
+
+    @Override
+    public void onProfileStateChanged(final String profileName, final int newState,
+            final int oldState) {
+        if (mAdapter == null) {
+            Log.w(TAG, "onProfileStateChanged(): mAdapter not found");
+            return;
+        }
+        int count = mAdapter.getCount();
+        for (int i = 0; i < count; i++) {
+            Header header = (Header) mAdapter.getItem(i);
+            String name = null;
+            if (header != null && header.extras != null
+                    && (name = header.extras.getString(EXTRA_PROFILE_NAME)) != null
+                    && name.equals(profileName)) {
+                HeaderViewHolder viewHolder = mAdapter.getHeaderViewHolder(i);
+                if (viewHolder != null && viewHolder.switch_ != null) {
+                    final CompoundButton button = viewHolder.switch_;
+                    runOnUiThread(new Runnable() {
+
+                        @Override
+                        public void run() {
+                            boolean checked = (newState == BluetoothAdapter.STATE_ON);
+                            if (checked != button.isChecked()) {
+                                button.setOnCheckedChangeListener(null);
+                                button.setChecked(checked);
+                                button.setOnCheckedChangeListener(mAdapter);
+                            }
+                            button.setEnabled(true);
+                        }
+                    });
+                }
+            }
+        }
+    }
+}
diff --git a/src/com/broadcom/bt/settings/HeaderAdapter.java b/src/com/broadcom/bt/settings/HeaderAdapter.java
new file mode 100755
index 0000000..8f4dde0
--- /dev/null
+++ b/src/com/broadcom/bt/settings/HeaderAdapter.java
@@ -0,0 +1,224 @@
+/*******************************************************************************
+ *
+ *  Copyright (C) 2012-2013 Broadcom Corporation
+ *
+ *  This program is the proprietary software of Broadcom Corporation and/or its
+ *  licensors, and may only be used, duplicated, modified or distributed
+ *  pursuant to the terms and conditions of a separate, written license
+ *  agreement executed between you and Broadcom (an "Authorized License").
+ *  Except as set forth in an Authorized License, Broadcom grants no license
+ *  (express or implied), right to use, or waiver of any kind with respect to
+ *  the Software, and Broadcom expressly reserves all rights in and to the
+ *  Software and all intellectual property rights therein.
+ *  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
+ *  SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+ *  ALL USE OF THE SOFTWARE.
+ *
+ *  Except as expressly set forth in the Authorized License,
+ *
+ *  1.     This program, including its structure, sequence and organization,
+ *         constitutes the valuable trade secrets of Broadcom, and you shall
+ *         use all reasonable efforts to protect the confidentiality thereof,
+ *         and to use this information only in connection with your use of
+ *         Broadcom integrated circuit products.
+ *
+ *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
+ *         "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+ *         REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+ *         OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+ *         DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+ *         NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+ *         ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ *         CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
+ *         OF USE OR PERFORMANCE OF THE SOFTWARE.
+ *
+ *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
+ *         ITS LICENSORS BE LIABLE FOR
+ *         (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
+ *               DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
+ *               YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
+ *               HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
+ *         (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
+ *               SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
+ *               LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
+ *               ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
+ *
+ *******************************************************************************/
+package com.broadcom.bt.settings;
+
+import java.util.List;
+
+import android.content.Context;
+import android.preference.PreferenceActivity.Header;
+import android.text.TextUtils;
+import android.util.Log;
+import android.util.SparseArray;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.CompoundButton;
+import android.widget.ImageView;
+import android.widget.Switch;
+import android.widget.TextView;
+
+import com.android.bluetooth.R;
+
+public abstract class HeaderAdapter extends ArrayAdapter<Header> implements
+        CompoundButton.OnCheckedChangeListener {
+    private static final String TAG="BtSettings.HeaderAdapter";
+    static final int HEADER_TYPE_CATEGORY = 0;
+    static final int HEADER_TYPE_NORMAL = 1;
+    static final int HEADER_TYPE_SWITCH = 2;
+    private static final int HEADER_TYPE_COUNT = HEADER_TYPE_SWITCH + 1;
+
+    public static interface OnCheckedChangeListener {
+        public void onCheckedChanged(int position, boolean isChecked);
+    }
+
+    public static class HeaderViewHolder {
+        public ImageView icon;
+        public TextView title;
+        public TextView summary;
+        public Switch switch_;
+    }
+
+    private LayoutInflater mInflater;
+
+
+    private SparseArray<HeaderViewHolder> mHeaderViews =
+                          new SparseArray<HeaderAdapter.HeaderViewHolder>();
+
+    public HeaderViewHolder getHeaderViewHolder(int pos) {
+        return mHeaderViews.get(pos);
+    }
+
+    protected void setHeaderViewHolder(int pos, HeaderViewHolder h) {
+        mHeaderViews.put(pos, h);
+    }
+
+    protected abstract int getHeaderType(Header header);
+
+    protected abstract int getHeaderLayoutResId(int headerType);
+
+    protected abstract boolean getSwitchState(Header header);
+
+    @Override
+    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+        Log.d(TAG, "onCheckChanged: isChecked = " + isChecked);
+        Log.d(TAG, "view=" + buttonView);
+
+        if (mCheckedChangeListener != null) {
+            Integer switchPosition = (Integer) buttonView.getTag();
+            Log.d(TAG, "SwitchPosition = " + switchPosition);
+            if (switchPosition != null) {
+                mCheckedChangeListener.onCheckedChanged(switchPosition, isChecked);
+            }
+        }
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+        Header header = getItem(position);
+        return getHeaderType(header);
+    }
+
+    @Override
+    public boolean areAllItemsEnabled() {
+        return false; // because of categories
+    }
+
+    @Override
+    public boolean isEnabled(int position) {
+        return getItemViewType(position) != HEADER_TYPE_CATEGORY;
+    }
+
+    @Override
+    public int getViewTypeCount() {
+        return HEADER_TYPE_COUNT;
+    }
+
+    @Override
+    public boolean hasStableIds() {
+        return true;
+    }
+
+    private OnCheckedChangeListener mCheckedChangeListener;
+
+    public void setCheckedChangeListener(OnCheckedChangeListener listener) {
+        mCheckedChangeListener = listener;
+    }
+
+    public HeaderAdapter(Context context, List<Header> objects) {
+        super(context, 0, objects);
+        mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+    }
+
+    @Override
+    public View getView(int position, View convertView, ViewGroup parent) {
+
+        Header header = getItem(position);
+        int headerType = getHeaderType(header);
+        View view = null;
+        Log.d(TAG, "getView(): position = " + position + ", convertView = "
+                + convertView);
+
+        HeaderViewHolder holder = getHeaderViewHolder(position);
+        if (holder == null) {
+            holder = new HeaderViewHolder();
+            setHeaderViewHolder(position, holder);
+        }
+
+        if (convertView == null) {
+            switch (headerType) {
+            case HEADER_TYPE_CATEGORY:
+                view = new TextView(getContext(), null, android.R.attr.listSeparatorTextViewStyle);
+                break;
+            case HEADER_TYPE_SWITCH:
+                view = mInflater.inflate(getHeaderLayoutResId(headerType), parent, false);
+                break;
+            case HEADER_TYPE_NORMAL:
+                view = mInflater.inflate(getHeaderLayoutResId(headerType), parent, false);
+                break;
+            }
+        } else {
+            view = convertView;
+        }
+
+        Log.d(TAG, "view=" + view);
+        // All view fields must be updated every time, because the view may be
+        // recycled
+        switch (headerType) {
+        case HEADER_TYPE_CATEGORY:
+            holder.title = (TextView) view;
+            holder.title.setText(header.getTitle(getContext().getResources()));
+            break;
+
+        case HEADER_TYPE_SWITCH:
+            holder.switch_ = (Switch) view.findViewById(R.id.switchWidget);
+            // No break, fall through on purpose to update common fields
+            boolean isChecked = getSwitchState(header);
+            holder.switch_.setOnCheckedChangeListener(null);
+            holder.switch_.setTag(position);
+            holder.switch_.setChecked(isChecked);
+            holder.switch_.setOnCheckedChangeListener(this);
+            //$FALL-THROUGH$
+        case HEADER_TYPE_NORMAL:
+            // holder.icon = (ImageView) view.findViewById(R.id.icon);
+            holder.title = (TextView) view.findViewById(com.android.internal.R.id.title);
+            holder.summary = (TextView) view.findViewById(com.android.internal.R.id.summary);
+            // holder.icon.setImageResource(header.iconRes);
+            holder.title.setText(header.getTitle(getContext().getResources()));
+            CharSequence summary = header.getSummary(getContext().getResources());
+            if (!TextUtils.isEmpty(summary)) {
+                holder.summary.setVisibility(View.VISIBLE);
+                holder.summary.setText(summary);
+            } else {
+                holder.summary.setVisibility(View.GONE);
+            }
+            break;
+        }
+        return view;
+    }
+
+}
diff --git a/src/com/broadcom/bt/settings/ModeAdvancedSettings.java b/src/com/broadcom/bt/settings/ModeAdvancedSettings.java
new file mode 100755
index 0000000..b72e535
--- /dev/null
+++ b/src/com/broadcom/bt/settings/ModeAdvancedSettings.java
@@ -0,0 +1,69 @@
+/*******************************************************************************
+ *
+ *  Copyright (C) 2013 Broadcom Corporation
+ *
+ *  This program is the proprietary software of Broadcom Corporation and/or its
+ *  licensors, and may only be used, duplicated, modified or distributed
+ *  pursuant to the terms and conditions of a separate, written license
+ *  agreement executed between you and Broadcom (an "Authorized License").
+ *  Except as set forth in an Authorized License, Broadcom grants no license
+ *  (express or implied), right to use, or waiver of any kind with respect to
+ *  the Software, and Broadcom expressly reserves all rights in and to the
+ *  Software and all intellectual property rights therein.
+ *  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
+ *  SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+ *  ALL USE OF THE SOFTWARE.
+ *
+ *  Except as expressly set forth in the Authorized License,
+ *
+ *  1.     This program, including its structure, sequence and organization,
+ *         constitutes the valuable trade secrets of Broadcom, and you shall
+ *         use all reasonable efforts to protect the confidentiality thereof,
+ *         and to use this information only in connection with your use of
+ *         Broadcom integrated circuit products.
+ *
+ *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
+ *         "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+ *         REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+ *         OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+ *         DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+ *         NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+ *         ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ *         CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
+ *         OF USE OR PERFORMANCE OF THE SOFTWARE.
+ *
+ *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
+ *         ITS LICENSORS BE LIABLE FOR
+ *         (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
+ *               DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
+ *               YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
+ *               HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
+ *         (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
+ *               SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
+ *               LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
+ *               ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
+ *
+ *******************************************************************************/
+package com.broadcom.bt.service.settings;
+
+import com.android.bluetooth.R;
+import android.app.Fragment;
+import android.os.Bundle;
+import android.util.Log;
+
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+public class ModeAdvancedSettings extends Fragment {
+    private static final String TAG = "ModeAdvancedSettings";
+    public static final String SHARED_PREFERENCE_NAME = "ModeSharedPreferences";
+
+    public void onCreate(Bundle b) {
+        super.onCreate(b);
+    }
+        @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+       return null;
+    }
+}
